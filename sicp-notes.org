#+STARTUP: show2levels
#+TITLE:     SICP Reading Notes
#+AUTHOR:    Calvin Xu
#+EMAIL:     calvinxu806@gmail.com

#+LATEX_HEADER: \usepackage{amsmath}
* SICP Reading Notes
** 0 Misc
#+NAME: sicp
#+BEGIN_SRC racket
#lang sicp

(define (average a b)
  (/ (+ a b) 2))

(define (square x)
  (* x x))

(define (cube x)
  (* x x x))

(define (expt b n)
  (define (iter a b n)
    (cond
      [(< n 0) (iter a (/ 1 b) (- n))]
      [(= n 0) a]
      [(even? n) (iter a (* b b) (/ n 2))]
      [else (iter (* a b) (* b b) (/ (- n 1) 2))]))
  (iter 1 b n))

(define (fib n)
  (define (iter a b count)
    (if (= count 0) b (iter (+ a b) a (- count 1))))
  (iter 1 0 n))

(define (gcd a b)
  (if (= b 0) a (gcd b (remainder a b))))

(define (square-with-check x n)
  (cond
    [(and (not (= 1 x)) (not (= (- n 1) x)) (= 1 (remainder (square x) n))) 0]
    [else (square x)]))

(define (expmod base exp m)
  (cond
    [(= exp 0) 1]
    [(even? exp) (remainder (square-with-check (expmod base (/ exp 2) m) m) m)]
    [else (remainder (* base (expmod base (- exp 1) m)) m)]))

(define (miller-rabin-test n)
  (define (test a)
    (= (expmod a (- n 1) n) 1))
  (test (+ 1 (random (- n 1)))))

(define (fast-prime? n times)
  (cond
    [(= times 0) true]
    [(miller-rabin-test n) (fast-prime? n (- times 1))]
    [else false]))

(define (prime? n)
  (fast-prime? n 10))

(define (iterative-improve good-enough? improve)
  (define (try guess)
    (let ([next (improve guess)]) (if (good-enough? guess) guess (try next))))
  try)

(define (fixed-point f first-guess)
  (define tolerance 0.000000000000001)
  (define (close-enough? a b)
    (< (abs (- a b)) tolerance))
  ((iterative-improve (lambda (x) (close-enough? x (f x))) f) first-guess))

;; (define (deriv g)
;;   (define dx 0.0000001)
;;   (lambda (x) (/ (- (g (+ x dx)) (g x)) dx)))

(define (newton-transform g)
  (lambda (x) (- x (/ (g x) ((deriv g) x)))))

(define (newtons-method g guess)
  (fixed-point (newton-transform g) guess))

(define (compose f g)
  (lambda (x) (f (g x))))

(define (repeated f n)
  (if (<= n 1) f (compose f (repeated f (- n 1)))))

(define (average-damp f)
  (lambda (x) (average x (f x))))

(define (filter predicate sequence)
  (cond
    [(null? sequence) nil]
    [(predicate (car sequence)) (cons (car sequence) (filter predicate (cdr sequence)))]
    [else (filter predicate (cdr sequence))]))

(define (accumulate op initial sequence)
  (if (null? sequence) initial (op (car sequence) (accumulate op initial (cdr sequence)))))

(define (accumulate-n op init seqs)
  (if (null? (car seqs))
      nil
      (cons (accumulate op init (map car seqs)) (accumulate-n op init (map cdr seqs)))))

(define (enumerate-interval low high)
  (if (> low high) nil (cons low (enumerate-interval (+ low 1) high))))

(define (enumerate-tree tree)
  (cond
    [(null? tree) nil]
    [(not (pair? tree)) (list tree)]
    [else (append (enumerate-tree (car tree)) (enumerate-tree (cdr tree)))]))

(define (fold-right op initial sequence)
  (accumulate op initial sequence))

(define (fold-left op initial sequence)
  (define (iter result rest)
    (if (null? rest) result (iter (op result (car rest)) (cdr rest))))
  (iter initial sequence))

(define (flatmap proc seq)
  (accumulate append nil (map proc seq)))

(define (remove item sequence)
  (filter (lambda (x) (not (= x item))) sequence))

(define (permutations s)
  (if (null? s)
      (list nil)
      (flatmap (lambda (x) (map (lambda (p) (cons x p)) (permutations (remove x s)))) s)))
#+END_SRC

#+NAME: accumulate
#+BEGIN_SRC racket
(define (accumulate op initial sequence)
  (if (null? sequence) initial (op (car sequence) (accumulate op initial (cdr sequence)))))
#+END_SRC

#+NAME: flatmap
#+BEGIN_SRC racket :noweb yes
<<accumulate>>
(define (flatmap proc seq)
  (accumulate append nil (map proc seq)))
#+END_SRC

#+NAME: data-directed-table
   #+BEGIN_SRC racket :noweb yes
#lang racket

(require rnrs/base-6)
(require rnrs/mutable-pairs-6)

(define (assoc key records)
  (cond
    [(null? records) false]
    [(equal? key (caar records)) (car records)]
    [else (assoc key (cdr records))]))

(define (make-table)
  (let ([local-table (list '*table*)])
    (define (lookup key-1 key-2)
      (let ([subtable (assoc key-1 (cdr local-table))])
        (if subtable
            (let ([record (assoc key-2 (cdr subtable))]) (if record (cdr record) false))
            false)))
    (define (insert! key-1 key-2 value)
      (let ([subtable (assoc key-1 (cdr local-table))])
        (if subtable
            (let ([record (assoc key-2 (cdr subtable))])
              (if record
                  (set-cdr! record value)
                  (set-cdr! subtable (cons (cons key-2 value) (cdr subtable)))))
            (set-cdr! local-table (cons (list key-1 (cons key-2 value)) (cdr local-table)))))
      'insertion_complete)
    (define (dispatch m)
      (cond
        [(eq? m 'lookup-proc) lookup]
        [(eq? m 'insert-proc!) insert!]
        [else (error "Unknown operation -- TABLE" m)]))
    dispatch))

(define operation-table (make-table))
(define get (operation-table 'lookup-proc))
(define put (operation-table 'insert-proc!))
   #+END_SRC

#+NAME: tagging
#+BEGIN_SRC racket :noweb yes
(define (attach-tag type-tag contents)
  (cons type-tag contents))

(define (type-tag datum)
  (if (pair? datum)
      (car datum)
      (error "Bad tagged datum - TYPE-TAG" datum)))

(define (contents datum)
  (if (pair? datum)
      (cdr datum)
      (error "Bad tagged datum - CONTENTS" datum)))
#+END_SRC

#+NAME: apply-generic
#+BEGIN_SRC racket :noweb yes
(define (apply-generic op . args)
  (let ([type-tags (map type-tag args)])
    (let ([proc (get op type-tags)])
      (if proc
          (apply proc (map contents args))
          (error "No method for these types - APPLY-GENERIC" (list op type-tags))))))
#+END_SRC

** DONE 1 Building Abstractions with Procedures
*** DONE 1.1 The Elements of Programming
**** DONE 1.1.1 Expressions

#+BEGIN_SRC racket :lang sicp
  "Hello World"
#+END_SRC

#+RESULTS:
: "Hello World"

#+begin_src racket :lang sicp
486
(+ 137 349)
(- 1000 334)
(* 5 99)
(/ 10 5)
(+ 2.7 10)
#+end_src

#+RESULTS:
: 486
: 486
: 666
: 495
: 2
: 12.7

- prefix notation; may take arbitrary number of arguments
- allows nesting combinations

#+begin_src racket :lang sicp
  (+ 21 35 12 7)
  (* 25 4 12)
  (+ (* 3 5) (- 10 6))
#+end_src

#+RESULTS:
: 75
: 1200
: 19

**** DONE 1.1.2 Naming and the Environment

#+BEGIN_SRC racket :lang sicp
  (define size 2)
  size
  (* 5 size)
#+END_SRC

#+RESULTS:
: 2
: 10

**** DONE 1.1.3 Evaluating Combinations

to evaluate combination:
- evaluate each subexpression (recursion & shortcircuit? opportunity)
- apply (operator operand)

#+BEGIN_SRC racket :lang sicp
  (* (+ 2 (* 4 6)) (+ 3 5 7))
#+END_SRC

#+RESULTS:
: 390

**** DONE 1.1.4 Compound Procedures

=(define (<name> <formal parameters>) <body>)=

#+BEGIN_SRC racket :lang sicp
(define (square x) (* x x))
(square 21)
(square (square 3))
(define (sum-of-squares x y) (+ (square x) (square y)))
(sum-of-squares 3 4)
#+END_SRC

#+RESULTS:
: 441
: 81
: 25

**** DONE 1.1.5 The Substitution Model for Procedure Application

#+BEGIN_SRC racket
(define (square x) (* x x))
(define (sum-of-squares x y) (+ (square x) (square y)))
(define (f a)
  (sum-of-squares (+ a 1) (* a 2)))
(f 5)
#+END_SRC

#+RESULTS:
: 136

Applicative order:
- evaluate the operator and operands, then apply
- used by Lisp

~(f 5)~
~(sum-of-squares (+ a 1) (* a 2))~
~(sum-of-squares (+ 5 1) (* 5 2))~
~(sum-of-squares 6 10)~
~(+ (square 6) (square 10))~
~(+ (* 6 6) (* 10 10))~
~(+ 36 100)~
~136~

Normal order:
- expand everything at every step
- until only primitive operators are in expressions
- evaluate (reduce)

~(f 5)~
~(sum-of-squares (+ 5 1) (* 5 2))~
~(+ (square (+ 5 1)) (square (* 5 2)))~
~(+ (* (+ 5 1) (+ 5 1)) (* (* 5 2) (* 5 2)))~
~(+ (* 6 6) (* 10 10))~
~(+ 36 100)~
~136~

note that ~(+ 5 1)~ and ~(* 5 2)~ are evaluated twice
  
**** DONE 1.1.6 Conditional Expressions and Predicates

#+BEGIN_SRC racket :lang sicp
;; clauses of conditions and predicates
(define (abs1 x)
  (cond ((> x 0) x)
        ((= x 0) 0)
        ((< x 0) (- x))))

(define (abs2 x)
  (cond ((< x 0) (- x))
        (else x)))
;; if for having exactly two cases
(define (abs3 x)
  (if (< x 0)
      (- x)
      x))

(abs2 -10)
#+END_SRC

#+RESULTS:
: 10

***** Exercise 1.1
What is the result printed by the interpreter in response to each expression? Assume that the sequence is to be evaluated in the order in which it is presented.

#+BEGIN_SRC racket :lang sicp
10
(+ 5 3 4)
(- 9 1)
(/ 6 2)
(+ (* 2 4) (- 4 6))
(define a 3)
(define b (+ a 1))
(+ a b (* a b))
(= a b)
(if (and (> b a) (< b (* a b)))
    b
    a)
(cond ((= a 4) 6)
      ((= b 4) (+ 6 7 a))
      (else 25))
(+ 2 (if (> b a) b a))
(* (cond ((> a b) a)
         ((< a b) b)
         (else -1))
   (+ a 1))
#+END_SRC

#+RESULTS:
#+begin_example
10
12
8
3
6
19
#f
4
16
6
16
#+end_example

***** Exercise 1.2
Translate the following expression into prefix form

\[\frac{5 + 4 + (2 - (3 - (6 + \frac{4}{5})))}{3 (6 - 2) (2 - 7)}\]

#+BEGIN_SRC racket :lang sicp
(/ (+ 5 4 (- 2 (- 3 (+ 6 (/ 4 5))))) (* 3 (- 6 2) (- 2 7)))
#+END_SRC

#+RESULTS:
: -37/150

***** Exercise 1.3
Define a procedure that takes three numbers as arguments and returns the sum of the squares of the two larger numbers.

#+BEGIN_SRC racket :lang sicp
(define (square x)
  (* x x))
(define (sum-of-squares x y)
  (+ (square x) (square y)))
(define (sum-larger-squares a b c)
  (cond
    [(and (<= a b) (<= a c)) (sum-of-squares b c)]
    [(and (>= a b) (<= b c)) (sum-of-squares a c)]
    ;; ((and (>= a c) (>= b c))
    ;; (sum-of-squares a b))
    [else (sum-of-squares a b)]
    ))
 (sum-larger-squares 1 2 3) 
 ;Value: 13 
 (sum-larger-squares 1 1 1) 
 ;Value: 2 
 (sum-larger-squares 1 2 2) 
 ;Value: 8 
 (sum-larger-squares 1 1 2) 
 ;Value: 5 
 (sum-larger-squares 1 4 3) 
 ;Value: 25
#+END_SRC

#+RESULTS:
: 13
: 2
: 8
: 5
: 25

***** Exercise 1.4
Observe that our model of evaluation allows for combinations whose operators are compound expressions. Use this observation to describe the behavior of the following procedure:

#+BEGIN_SRC racket :lang sicp
(define (a-plus-abs-b a b)
  ((if (> b 0) + -) a b))
#+END_SRC

if b > 0 return a + b alse return a - b;
in effect returns \(a + |b|\)
***** Exercise 1.5
Ben Bitdiddle has invented a test to determine whether the interpreter he is faced with is using applicative order evaluation or normal-order evaluation. He defines the following two procedures:

#+BEGIN_SRC racket :lang sicp
(define (p)
  (p))
(define (test x y)
  (if (= x 0) 0 y))
#+END_SRC

Then he evaluates the expression ~(test 0 (p))~

What behavior will Ben observe with an interpreter that uses applicative-order evaluation? What behavior will he observe with an interpreter that uses normal-order evaluation? Explain your answer. (Assume that the evaluation rule for the special form if is the same whether the interpreter is using normal or applicative order: The predicate expression is evaluated first, and the result determines whether to evaluate the consequent or the alternative expression.)

Applicative order:
~(test 0 (p))~
~(test 0 (p))~
never terminates because (p) is always expanded to itself

Normal order:
~(test 0 (p))~
~(if (= 0 0) 0 (p))~~
~(if #t 0 (p))~
~0~

**** DONE 1.1.7 Example: Square Roots by Newton’s Method

#+BEGIN_SRC racket :lang sicp
(define (square x)
  (* x x))

(define (sqrt x)
  (sqrt-iter 1.0 x))

(define (good-enough? guess x)
  (< (abs (- (square guess) x)) 0.001))

(define (average x y)
  (/ (+ x y) 2))

(define (improve guess x)
  (average guess (/ x guess)))

(define (sqrt-iter guess x)
  (if (good-enough? guess x) guess (sqrt-iter (improve guess x) x)))

(sqrt 2)
#+END_SRC

#+RESULTS:
: 1.4142156862745097

Note that using =1= instead of =1.0= produces a rational number (fraction output) instead of a decimal.

***** Exercise 1.6
:PROPERTIES:
:CUSTOM_ID: exercise-1.6
:END:

Alyssa P. Hacker doesn't see why ~if~ needs to be provided as a special form.  "Why can't I just define it as an ordinary procedure in terms of ~cond~?"  she asks.  Alyssa's friend Eva Lu Ator claims this can indeed be done, and she defines a new version of ~if~:

#+BEGIN_SRC scheme
(define (new-if predicate then-clause else-clause)
  (cond (predicate then-clause)
        (else else-clause)))
#+END_SRC

Eva demonstrates the program for Alyssa:

#+BEGIN_SRC scheme
(new-if (= 2 3) 0 5)
5

(new-if (= 1 1) 0 5)
0
#+END_SRC

Delighted, Alyssa uses ~new-if~ to rewrite the square-root program:

#+BEGIN_SRC scheme
(define (sqrt-iter guess x)
  (new-if (good-enough? guess x)
          guess
          (sqrt-iter (improve guess x)
                     x)))
#+END_SRC

What happens when Alyssa attempts to use this to compute square
roots?  Explain.

Answer:

So it seems that ~if~ (~(if ⟨ predicate ⟩ ⟨ consequent ⟩ ⟨ alternative ⟩~) is a special form in that it evaluates the predicate first, and if the predicate evaluates to true it evaluates the consequent (p.24).

However, ~new-if~ is written as a procedure, which is evaluated in applicative order (evaluate the operator and operands, then apply); this means ~(sqrt-iter (improve guess x) x)~ is always evaluated, which
eventually reaches the recursion limit.

***** Exercise 1.7
:PROPERTIES:
:CUSTOM_ID: exercise-1.7
:END:

The ~good-enough?~ test used in computing square roots will not be very effective for finding the square roots of very small numbers.  Also, in real computers, arithmetic operations are almost always performed with limited precision.  This makes our test inadequate for very large numbers.  Explain these statements, with examples showing how the test fails for small and large numbers.  An alternative strategy for implementing ~good-enough?~ is to watch how ~guess~ changes from one iteration to the next and to stop when the change is a very small fraction of the guess.  Design a square-root procedure that uses this kind of end test.  Does this work better for small and large numbers?

Answer:
Kind of obvious why the fixed threshold is bad for small values; for big values, it's the matter of floating point precision. I happen to happily have implemented cmath.h in pure C for fun back then [https://gist.github.com/Calvin-Xu/7f5381babba06993b93b1c2297d2d139], and had to deal with this issue, for the ~sqrt~ function too actually.

The problem is that, say, ~double~ has 53 bits of mantissa, which gives you \(\log_{10}(2^{53}) = 15.9546\) digits of decimal precision. For a large value, you use up all these digits before you can get to the ~0.001~ part for comparison.

I saw a very clever way of stopping iteration when the change becomes very small:

#+BEGIN_SRC racket :lang sicp
(define (square x)
  (* x x))

(define (sqrt x)
  (sqrt-iter 1.0 x))

(define (good-enough? guess x)
  (= (improve guess x) guess))

(define (average x y)
  (/ (+ x y) 2))

(define (improve guess x)
  (average guess (/ x guess)))

(define (sqrt-iter guess x)
  (if (good-enough? guess x) guess (sqrt-iter (improve guess x) x)))

(sqrt 2)
#+END_SRC

#+RESULTS:
: 1.414213562373095

A more conventional solution that adheres to the problem statement:

#+BEGIN_SRC racket :lang sicp
(define (square x)
  (* x x))

(define (sqrt x)
  (sqrt-iter 1.0 0 x))

(define (good-enough? guess prev)
  (if (= guess 0) guess (< (abs (- guess prev)) (* guess 0.001))))

(define (average x y)
  (/ (+ x y) 2))

(define (improve guess x)
  (average guess (/ x guess)))

(define (sqrt-iter guess prev x)
  (if (good-enough? guess prev) guess (sqrt-iter (improve guess x) guess x)))

(sqrt 2)
(sqrt 0)
#+END_SRC

#+RESULTS:
: 1.4142135623746899
: 0.0

***** Exercise 1.8
:PROPERTIES:
:CUSTOM_ID: exercise-1.8
:END:

Newton's method for cube roots is based on the fact that if y is an approximation to the cube root of x, then a better approximation is given by the value

#+BEGIN_EXAMPLE
 x/y^2 + 2y
 ----------
     3
#+END_EXAMPLE

Use this formula to implement a cube-root procedure analogous to the square-root procedure.  (In section [[#section-1.3.4][1.3.4]] we will see how to implement Newton's method in general as an abstraction of these square-root and cube-root procedures.)

#+BEGIN_SRC racket :lang sicp
(define (cube-root x)
  (cube-root-iter 1.0 x))

(define (improve guess x)
  (/ (+ (/ x (* guess guess)) (* 2 guess)) 3))

(define (cube-root-iter guess x)
  (if (= (improve guess x) guess) guess (cube-root-iter (improve guess x) x)))

(cube-root 3.0)
#+END_SRC

#+RESULTS:
: 1.4422495703074085

**** DONE 1.1.8 Procedures as Black-Box Abstractions

Block structure with lexical scoping!

Free variables (~x~ in this case) in a procedure are looked up for bindings in enclosing procedure definitions.

#+BEGIN_SRC scheme
(define (sqrt x)
  (define (good-enough? guess)
    (< (abs (- (square guess) x)) 0.001))
  (define (improve guess)
    (average guess (/ x guess)))
  (define (sqrt-iter guess)
    (if (good-enough? guess)
        guess
        (sqrt-iter (improve guess))))
  (sqrt-iter 1.0))
#+END_SRC

*** DONE 1.2 Procedures and the Processes They Generate
**** DONE 1.2.1 Linear Recursion and Iteration
***** Linear recursion:

#+BEGIN_SRC racket :lang sicp
(define (factorial n)
  (if (= n 1)
      1
      (* n (factorial (- n 1)))))
(factorial 6)
#+END_SRC

#+RESULTS:
: 720

#+BEGIN_EXAMPLE
 (factorial 6)        ------------------------.
 (* 6 (factorial 5))                          |
 (* 6 (* 5 (factorial 4)))                    |
 (* 6 (* 5 (* 4 (factorial 3))))              |
 (* 6 (* 5 (* 4 (* 3 (factorial 2)))))        |
 (* 6 (* 5 (* 4 (* 3 (* 2 (factorial 1))))))  |
 (* 6 (* 5 (* 4 (* 3 (* 2 1)))))              |
 (* 6 (* 5 (* 4 (* 3 2))))                    |
 (* 6 (* 5 (* 4 6)))                          |
 (* 6 (* 5 24))                               |
 (* 6 120)                                    |
 720          <-------------------------------'
#+END_EXAMPLE

The number of deferred operations grows linearly with n.

***** Linear iterations

#+BEGIN_SRC racket :lang sicp
(define (factorial n)
  (define (iter product counter)
    (if (> counter n) product (iter (* counter product) (+ counter 1))))
  (iter 1 1))

(factorial 6)
#+END_SRC

#+RESULTS:
: 720

#+BEGIN_EXAMPLE
 (factorial 6)   -----.
 (fact-iter   1 1 6)  |
 (fact-iter   1 2 6)  |
 (fact-iter   2 3 6)  |
 (fact-iter   6 4 6)  |
 (fact-iter  24 5 6)  |
 (fact-iter 120 6 6)  |
 (fact-iter 720 7 6)  V
 720
#+END_EXAMPLE

The number of iterations grows linearly with n.

Note that although the procedure itself is recursive, the process is not. Its state is described completely by the 3 vars (~product~, ~counter~, ~n~).

MIT Scheme uses tail recursion; executes iterative process in constant memory space, even if the process is implemented by a recursive procedure as above.

Languages such as C use more and more stack space for recursive procedures even if the procedure is in principle iterative.

***** DONE Exercise 1.9
:PROPERTIES:
:CUSTOM_ID: exercise-1.9
:END:

Each of the following two procedures defines a method for adding two positive integers in terms of the procedures ~inc~, which increments its argument by 1, and ~dec~, which decrements its argument by 1.

#+BEGIN_SRC scheme
(define (+ a b)
  (if (= a 0)
      b
      (inc (+ (dec a) b))))

(define (+ a b)
  (if (= a 0)
      b
      (+ (dec a) (inc b))))
#+END_SRC

Using the substitution model, illustrate the process generated by each procedure in evaluating ~(+ 4 5)~.  Are these processes iterative or recursive?

Answer:
The first implementation is linearly recursive:

#+BEGIN_EXAMPLE
 (+ 4 5)              ------------------------.
 (inc (+ 3 5))                                |
 (inc (inc (+ 2 5)))                          |
 (inc (inc (inc (+ 1 5))))                    |
 (inc (inc (inc (inc (+ 0 5)))))              |
 (inc (inc (inc (inc 5))))                    |
 (inc (inc (inc 6)))                          |
 (inc (inc 7))                                |
 (inc 8)                                      |
 9          <-------------------------------'
#+END_EXAMPLE

The second implementation is linearly iterative (again, although implemented (tail) recursively):

#+BEGIN_EXAMPLE
 (+ 4 5)            ------------------------.
 (+ (dec 4) (inc 5))                        |
 (+ 3 6)                                    |
 (+ (dec 3) (inc 6))                        |
 (+ 2 7)                                    |
 (+ (dec 2) (inc 7))                        |
 (+ 1 8)                                    |
 (+ (dec 1) (inc 8))                        |
 (+ 0 9)                                    |
 9          <-------------------------------'
#+END_EXAMPLE

***** DONE Exercise 1.10
:PROPERTIES:
:CUSTOM_ID: exercise-1.10
:END:

The following procedure computes a mathematical function called Ackermann's function.

#+BEGIN_SRC scheme
(define (A x y)
  (cond ((= y 0) 0)
        ((= x 0) (* 2 y))
        ((= y 1) 2)
        (else (A (- x 1)
                 (A x (- y 1))))))
#+END_SRC

What are the values of the following expressions?

#+BEGIN_SRC scheme
(A 1 10)

(A 2 4)

(A 3 3)
#+END_SRC

Answer:

Let's play with it

#+BEGIN_SRC racket :lang sicp
(define (A x y)
  (cond
    [(= y 0) 0]
    [(= x 0) (* 2 y)]
    [(= y 1) 2]
    [else (A (- x 1) (A x (- y 1)))]))

(A 1 10)
(A 2 4)
(A 3 3)
#+END_SRC

#+RESULTS:
: 1024
: 65536
: 65536

So tracing the execution, for the first one, you get to ~(A 0 (A 1 9))~, then ~(A 0 (A 0 (A 1 8)))~, etc. Eventually you have 9 nested ~A(0)~ and finally ~(A 1 1)~, which returns 2, and going back up the stack the whole thing returns ~2^10 = 1024~. More generally, ~(A 1 n)~ computes ~2^n~, except for ~n = 0~ when it returns 0.

Things are more interesting when x is greater than 1; it gets decremented eventually to the ~(A 1 n)~ form. Someone cared to draw the stacks:

#+BEGIN_EXAMPLE
(A 1 10)
(A 0 (A 1 9))
(A 0 (A 0 (A 1 8)))
(A 0 (A 0 (A 0 (A 1 7))))
(A 0 (A 0 (A 0 (A 0 (A 1 6)))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 1 5))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 4)))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 3))))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 2)))))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 1))))))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 2)))))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 4))))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 8)))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 16))))))
(A 0 (A 0 (A 0 (A 0 (A 0 32)))))
(A 0 (A 0 (A 0 (A 0 64))))
(A 0 (A 0 (A 0 128)))
(A 0 (A 0 256))
(A 0 512)
1024

(A 2 4)
(A 1 (A 2 3))
(A 1 (A 1 (A 2 2)))
(A 1 (A 1 (A 1 (A 2 1))))
(A 1 (A 1 (A 1 2)))
(A 1 (A 1 (A 0 (A 1 1))))
(A 1 (A 1 (A 0 2)))
(A 1 (A 1 4))
(A 1 (A 0 (A 1 3)))
(A 1 (A 0 (A 0 (A 1 2))))
(A 1 (A 0 (A 0 (A 0 (A 1 1)))))
(A 1 (A 0 (A 0 (A 0 2))))
(A 1 (A 0 (A 0 4)))
(A 1 (A 0 8))
(A 1 16)
2^16
6536
#+END_EXAMPLE

Consider the following procedures, where ~A~ is the procedure defined above:

#+BEGIN_SRC scheme
(define (f n) (A 0 n))

(define (g n) (A 1 n))

(define (h n) (A 2 n))

(define (k n) (* 5 n n))
#+END_SRC

Give concise mathematical definitions for the functions computed by the procedures ~f~, ~g~, and ~h~ for positive integer values of n. For example, ~(k n)~ computes 5n^2.

Answer:

~(f n)~ computes ~2*n~. ~(g n)~ computes ~2^n~ for ~n != 0~ (returns 0 for ~n = 0~). ~(h n)~ computes \(2^{2^n}\) for ~n > 1~ (returns 2 for ~n = 1~ and 0 for ~n = 0~).

**** DONE 1.2.2 Tree Recursion

#+BEGIN_SRC racket :lang sicp
(define (fib n)
  (cond
    [(= n 0) 0]
    [(= n 1) 1]
    [else (+ (fib (- n 1)) (fib (- n 2)))]))

(fib 5)
#+END_SRC

#+RESULTS:
: 5

Bad, exponential complexity. Linearly iterative version:

#+BEGIN_SRC racket :lang sicp
(define (fib n)
  (define (iter a b count)
    (if (= count 0) b (iter (+ a b) a (- count 1))))
  (iter 1 0 n))

(fib 5)
#+END_SRC

#+RESULTS:
: 5

#+BEGIN_SRC racket :lang sicp
(define (count-change amount)
  (define (first-denomination kinds-of-coins)
    (cond
      [(= kinds-of-coins 1) 1]
      [(= kinds-of-coins 2) 5]
      [(= kinds-of-coins 3) 10]
      [(= kinds-of-coins 4) 25]
      [(= kinds-of-coins 5) 50]))
  (define (rec a kinds-of-coins)
    (cond
      [(= a 0) 1]
      [(or (< a 0) (= kinds-of-coins 0)) 0]
      [else
       (+ (rec a (- kinds-of-coins 1))
          (rec (- a (first-denomination kinds-of-coins)) kinds-of-coins))]))
  (rec amount 5))

(count-change 100)
#+END_SRC

#+RESULTS:
: 292

***** DONE Exercise 1.11
:PROPERTIES:
:CUSTOM_ID: exercise-1.11
:END:

A function f is defined by the rule that f(n) = n if n<3 and f(n) = f(n - 1) + 2f(n - 2) + 3f(n - 3) if n>= 3.  Write a procedure that computes f by means of a recursive process.  Write a procedure that computes f by means of an iterative process.

#+BEGIN_SRC racket :lang sicp
(define (f n)
  (cond
    [(< n 3) n]
    [else (+ (f (- n 1)) (* 2 (f (- n 2))) (* 3 (f (- n 3))))]))

(f 15)
#+END_SRC

#+RESULTS:
: 142717

~f(4) = 14 = 2 + 2 * 2 + 3 * 1 = 11~

#+BEGIN_SRC racket :lang sicp
(define (f n)
  (define (iter fn-1 fn-2 fn-3 count)
    (cond
      [(< n 3) n]
      [(< count 3) fn-1]
      [else (iter (+ fn-1 (* 2 fn-2) (* 3 fn-3)) fn-1 fn-2 (- count 1))]))
  (iter 2 1 0 n))

(f 15)
#+END_SRC

#+RESULTS:
: 142717

***** DONE Exercise 1.12
:PROPERTIES:
:CUSTOM_ID: exercise-1.12
:END:

The following pattern of numbers is called <<i281>> Pascal's triangle.

#+BEGIN_EXAMPLE
         1
       1   1
     1   2   1
   1   3   3   1
 1   4   6   4   1
#+END_EXAMPLE

The numbers at the edge of the triangle are all 1, and each number inside the triangle is the sum of the two numbers above it.[fn:35] Write a procedure that computes elements of Pascal's triangle by means of a recursive process.

#+BEGIN_SRC racket :lang sicp
(define (pascal n k)
  (cond
    [(= n 0) 1]
    [(= k 0) 1]
    [(= n k) 1]
    [else (+ (pascal (- n 1) (- k 1)) (pascal (- n 1) k))]))

(pascal 4 2)
#+END_SRC

#+RESULTS:
: 6

***** DONE Exercise 1.13
:PROPERTIES:
:CUSTOM_ID: exercise-1.13
:END:

Prove that Fib(n) is the closest integer to \(\phi^n/\sqrt{5}\), where \(\phi = (1 + \sqrt{5})/2\).  Hint: Let \(\psi = (1 - \sqrt{5})/2\).  Use induction and the definition of the Fibonacci numbers (see section [[#section-1.2.2][1.2.2]]) to prove that \(Fib(n) = (\phi^n - \psi^n)/\sqrt{5}\).

Proof. By strong induction, let \(P(n)\) be the statement "\(Fib(n) = (\phi^n -
\psi^n)/\sqrt{5}\)". We will prove that \(P(n)\) is true for all \(n \in
\mathbb{N}\) from which the result follows.

For the base case, we prove \(P(0)\) and \(P(1)\), that \(Fib(0) = (\phi^0 -
\psi^0)/\sqrt{5}\). Both sides of each equation evaluate to 0. Thus \(P(0)\) holds.

For the inductive step, assume that \(P(k)\) is true for some \(k \in
\mathbb{N}\) where \(k > 0\) that for all \(0 < k' \le k\), \(P(k')\) holds such that \(Fib(k') = (\phi^{k'} - \psi^{k'})/\sqrt{5}\).

We will prove that \(P(k + 1)\) is true, namely that \(Fib(k + 1) = (\phi^{k +
1} - \psi^{k + 1})/\sqrt{5}\).
By definition, \(Fib(k + 1) = Fib(k) + Fib(k - 1)\). By our inductive
hypothesis, that is equal to \((\phi^{k - 1} - \psi^{k - 1})/\sqrt{5} +
(\phi^{k} - \psi^{k})/\sqrt{5}\). Simplify into:

\[\frac{\phi^{k - 1}(\phi + 1) - \psi^{k - 1}(\psi + 1)}{\sqrt{5}}\]

Consider that by definition, \(\phi\) and \(\psi\) are the golden ratio where \(\phi^2
= \phi + 1\) and \(\psi^2 = \psi + 1\). Substituting this in:

\[\frac{\phi^{k - 1}(\phi^2) - \psi^{k - 1}(\psi^2)}{\sqrt{5}}\]
\[\frac{\phi^{k + 1} - \psi^{k + 1}}{\sqrt{5}}\]

Thus \(P(k + 1)\) holds, completing the induction.

Since we have proven that \(Fib(n) = (\phi^n - \psi^n)/\sqrt{5} =
\phi^n/\sqrt{5} - \psi^n/\sqrt{5}\), and \(\psi^n/\sqrt{5} < 1\) for all
\(n \in \mathbb{N}\), Fib(n) is the closest integer to \(\phi^n/\sqrt{5}\).

**** DONE 1.2.3 Orders of Growth
***** DONE Exercise 1.14
:PROPERTIES:
:CUSTOM_ID: exercise-1.14
:END:

Draw the tree illustrating the process generated by the ~count-change~ procedure of section [[#section-1.2.2][1.2.2]] in making change for 11 cents.  What are the orders of growth of the space and number of steps used by this process as the amount to be changed increases?

Here is a review of ~count-change~:

#+BEGIN_SRC racket :lang sicp
(define (count-change amount)
  (define (first-denomination kinds-of-coins)
    (cond
      [(= kinds-of-coins 1) 1]
      [(= kinds-of-coins 2) 5]
      [(= kinds-of-coins 3) 10]
      [(= kinds-of-coins 4) 25]
      [(= kinds-of-coins 5) 50]))
  (define (rec a kinds-of-coins)
    (cond
      [(= a 0) 1]
      [(or (< a 0) (= kinds-of-coins 0)) 0]
      [else
       (+ (rec a (- kinds-of-coins 1))
          (rec (- a (first-denomination kinds-of-coins)) kinds-of-coins))]))
  (rec amount 5))

(count-change 11)
#+END_SRC

#+RESULTS:
: 4

I drew on a whiteboard. There are good ASCII graphs on
[[http://community.schemewiki.org/?sicp-ex-1.14][SchemeWiki]].

Let ~n~ be amount and ~k~ be ~kinds-of-coins~, though I used these interchangeably below:

On the space complexity:

This is a very interesting tree-recursive problem that shines on what "the order of" implies. The space used is linear, mostly corresponding to the deepest stack used by the branch that keeps decrementing the total amount by 1. Certain caveats that do not detract from the overall linear order:

- the branch that eventually gets decrements by 1 until the amount reaches 0 first goes through each denomination (~(rec a (- kinds-of-coins 1))~). So ~n~ is not exactly the overall amount (assuming the smallest denomination is 1). In the implementation, the stack is ~n + k~ deep.
- obviously, the other branches also take up stack space. but note that none of them can be longer than this branch, so assuming there are ~m~ other branches, hand-wavily the worst case is that the overall space used is ~n * m~, still on the same order.

On the time complexity:

This is more difficult; first of all, think that the number of denominations is probably the greatest contributor because it keeps creating more branches. Moreover, consider the left branch of ~rec~, where ~(rec a (- kinds-of-coins 1))~; this creates the same problem with n the same and k one smaller. The right branch of ~rec~ is going to be roughly ~O(n)~ (consider the longest right branch where you keep decrementing ~n~ by 1). So you have ~O(n)~ that you do ~k~ times, the overall time complexity being ~O(n^k)~.

***** DONE Exercise 1.15
:PROPERTIES:
:CUSTOM_ID: exercise-1.15
:END:

The sine of an angle (specified in radians) can be computed by making use of the approximation ~sin~ xapprox x if x is sufficiently small, and the trigonometric identity

#+BEGIN_EXAMPLE
                x             x
 sin x = 3 sin --- - 4 sin^3 ---
                3             3
#+END_EXAMPLE

to reduce the size of the argument of ~sin~.  (For purposes of this exercise an angle is considered "sufficiently small" if its magnitude is not greater than 0.1 radians.)  These ideas are incorporated in the following procedures:

#+BEGIN_SRC scheme
(define (cube x) (* x x x))

(define (p x) (- (* 3 x) (* 4 (cube x))))

(define (sine angle)
  (if (not (> (abs angle) 0.1))
      angle
      (p (sine (/ angle 3.0)))))
#+END_SRC

a. How many times is the procedure ~p~ applied when ~(sine 12.15)~ is evaluated?

   Answer: ~p~ is applied 5 times as ~12.15~ is repeatedly divided by 3 until is is ~0.04995885~.

b. What is the order of growth in space and number of steps (as a function of a) used by the process generated by the ~sine~ procedure when ~(sine a)~ is evaluated?

   Answer: dividing n each time, classic logarithmic time complexity (~O(log(a))~). Since a new stack is used each time, this is also the space complexity.

**** DONE 1.2.4 Exponentiation

Recursive (O(n) steps and space):
#+BEGIN_SRC racket :lang sicp
(define (expt b n)
  (if (= n 0) 1 (* b (expt b (- n 1)))))

(expt 5 10)
#+END_SRC

#+RESULTS:
: 9765625

Iterative (O(n) steps and O(1) space):
#+BEGIN_SRC racket :lang sicp
(define (expt b n)
  (define (iter b counter product)
    (if (= counter 0) product (iter b (- counter 1) (* b product))))
  (iter b n 1))

(expt 5 10)
#+END_SRC

#+RESULTS:
: 9765625

Exponentiation by squaring (O(log(n) steps and space)):
#+BEGIN_SRC racket :lang sicp
(define (square x)
  (* x x))

(define (fast-expt b n)
  (cond
    [(= n 0) 1]
    [(even? n) (square (fast-expt b (/ n 2)))]
    [else (* b (fast-expt b (- n 1)))]))

(fast-expt 5 10)
#+END_SRC

#+RESULTS:
: 9765625

***** DONE Exercise 1.16
:PROPERTIES:
:CUSTOM_ID: exercise-1.16
:END:

Design a procedure that evolves an iterative exponentiation process that uses successive squaring and uses a logarithmic number of steps, as does ~fast-expt~.  (Hint: Using the observation that (b^(n/2))^2 = (b^2)^(n/2), keep, along with the exponent n and the base b, an additional state variable a, and define the state transformation in such a way that the product a b^n is unchanged from state to state.  At the beginning of the process a is taken to be 1, and the answer is given by the value of a at the end of the process.  In general, the technique of defining an <<i196>> invariant quantity that remains unchanged from state to state is a powerful way to think about the design of iterative algorithms.)

#+BEGIN_SRC racket :lang sicp
(define (fast-expt b n)
  (define (iter a b n)
    (cond
      [(< n 0) (iter a (/ 1 b) (- n))]
      [(= n 0) a]
      [(even? n) (iter a (* b b) (/ n 2))]
      [else (iter (* a b) (* b b) (/ (- n 1) 2))]))
  (iter 1 b n))

(fast-expt 5 -2)
#+END_SRC

#+RESULTS:
: 1/25

I've written this in C. Feels cooler in Lisp due to the closure.

***** DONE Exercise 1.17
:PROPERTIES:
:CUSTOM_ID: exercise-1.17
:END:

The exponentiation algorithms in this section are based on performing exponentiation by means of repeated multiplication.  In a similar way, one can perform integer multiplication by means of repeated addition.  The following multiplication procedure (in which it is assumed that our language can only add, not multiply) is analogous to the ~expt~ procedure:

#+BEGIN_SRC scheme
(define (* a b)
  (if (= b 0)
      0
      (+ a (* a (- b 1)))))
#+END_SRC

This algorithm takes a number of steps that is linear in ~b~.  Now suppose we include, together with addition, operations ~double~, which doubles an integer, and ~halve~, which divides an (even) integer by 2.  Using these, design a multiplication procedure analogous to ~fast-expt~ that uses a logarithmic number of steps.

#+BEGIN_SRC racket :lang sicp
(define (double x)
  (* 2 x))

(define (halve x)
  (/ x 2))

(define (fast-* a b)
  (define (iter a b)
    (if (= a 1) b (iter (halve a) (double b))))
  (if (even? a) (iter a b) (+ b (iter (- a 1) b))))

(fast-* 5 8)
#+END_SRC

#+RESULTS:
: 40

Hmm what was I thinking, that was not iterative.

#+BEGIN_SRC racket :lang sicp
(define (double x)
  (* 2 x))

(define (halve x)
  (/ x 2))

(define (fast-* a b)
  (cond
    [(= a 0) 0]
    [(even? a) (double (fast-* (halve a) b))]
    [else (+ b (double (fast-* (halve (- a 1)) b)))]))

(fast-* 5 8)
#+END_SRC

#+RESULTS:
: 40

***** DONE Exercise 1.18
:PROPERTIES:
:CUSTOM_ID: exercise-1.18
:END:

Using the results of [[#exercise-1.16][Exercise 1.16]] and [[#exercise-1.17][Exercise 1.17]], devise a procedure that generates an iterative process for multiplying two integers in terms of adding, doubling, and halving and uses a logarithmic number of steps.[fn:40]

#+BEGIN_SRC racket :lang sicp
(define (double x)
  (* 2 x))

(define (halve x)
  (/ x 2))

(define (fast-* a b)
  (define (iter a b product)
    (cond
      [(= a 0) product]
      [(even? a) (iter (halve a) (double b) product)]
      [else (iter (- a 1) b (+ product b))]))
  (iter a b 0))

(fast-* 5 8)
#+END_SRC

#+RESULTS:
: 40

This can be optimized by doing more in calls where ~a~ is odd:

#+BEGIN_SRC racket :lang sicp
(define (double x)
  (* 2 x))

(define (halve x)
  (/ x 2))

(define (fast-* a b)
  (define (iter a b product)
    (cond
      [(= a 0) product]
      [(even? a) (iter (halve a) (double b) product)]
      [else (iter (halve (- a 1)) (double b) (+ product b))]))
  (iter a b 0))

(fast-* 5 8)
#+END_SRC

#+RESULTS:
: 40

Also, now I'm understanding better how tail recursion is just about the final action of a procedure being calling itself. You must not keep any information on the stack (like ~(+ 1 (call))~) or the stack space cannot be reclaimed & reused. It seems non-functional languages don't want to support tailcall optimization; I suppose it is understandable that they prefer explicit loop constructs.

***** DONE Exercise 1.19
:PROPERTIES:
:CUSTOM_ID: exercise-1.19
:END:

There is a clever algorithm for computing the Fibonacci numbers in a logarithmic number of steps.  Recall the transformation of the state variables a and b in the ~fib-iter~ process of section [[#section-1.2.2][1.2.2]]: a <- a + b and b <- a.  Call this transformation T, and observe that applying T over and over again n times, starting with 1 and 0, produces the pair Fib(n + 1) and Fib(n).  In other words, the Fibonacci numbers are produced by applying T^n, the nth power of the transformation T, starting with the pair (1,0).  Now consider T to be the special case of p = 0 and q = 1 in a family of transformations T_(pq), where T_(pq) transforms the pair (a,b) according to a <- bq + aq + ap and b <- bp + aq.  Show that if we apply such a transformation T_(pq) twice, the effect is the same as using a single transformation T_(p'q') of the same form, and compute p' and q' in terms of p and q.  This gives us an explicit way to square these transformations, and thus we can compute T^n using successive squaring, as in the ~fast-expt~ procedure.  Put this all together to complete the following procedure, which runs in a logarithmic number of steps:[fn:41]

#+BEGIN_SRC racket :lang sicp
(define (fib n)
  (fib-iter 1 0 0 1 n))

(define (fib-iter a b p q count)
  (cond ((= count 0) b)
        ((even? count)
         (fib-iter a
                   b
                   (+ (* p p) (* q q))                 ; compute p'
                   (+ (* q q) (* 2 p q))               ; compute q'
                   (/ count 2)))
        (else (fib-iter (+ (* b q) (* a q) (* a p))
                        (+ (* b p) (* a q))
                        p
                        q
                        (- count 1)))))

(fib 10)
#+END_SRC

#+RESULTS:
: 55

The problem gives very clear insturctions so this just becomes some algebra. So we have \(T_{pq}\) where \(a \leftarrow bq + aq + ap\) and \(b \leftarrow bp + aq\). If we apply \(T_{pq}\) twice:

\begin{align}
a & \leftarrow bq + aq + ap \\
  & \leftarrow q(bp + aq) + (p + q)(bq + aq + ap) \\
  & \leftarrow qbp + qaq + pbq + paq + pap + qbq + qaq + qap \\
  & \leftarrow qaq + qaq + qap + qap + pap + qbq + qbp + qbp \\
  & \leftarrow (p^2 + 2pq + 2q^2)a + (2pq + q^2)b \\
\end{align}
\begin{align}
b & \leftarrow bp + aq \\
  & \leftarrow p(bp + aq) + q(bq + aq + ap) \\
  & \leftarrow (2pq + q^2)a + (p^2 + q^2)b \\
\end{align}
Matching the coefficients, we find that \(p' = p^2 + q^2\) and \(q' = q^2 + 2pq\).

**** DONE 1.2.5 Greatest Common Divisors

#+BEGIN_SRC racket :lang sicp
(define (gcd a b)
  (if (= b 0) a (gcd b (remainder a b))))

(gcd 206 40)
#+END_SRC

#+RESULTS:
: 2

***** Exercise 1.20
:PROPERTIES:
:CUSTOM_ID: exercise-1.20
:END:

The process that a procedure generates is of course dependent on the rules used by the interpreter.  As an example, consider the iterative ~gcd~ procedure given above.  Suppose we were to interpret this procedure using normal-order evaluation, as discussed in section [[#section-1.1.5][1.1.5]].  (The normal-order-evaluation rule for ~if~ is described in [[#exercise-1.5][Exercise 1.5]].)  Using the substitution method (for normal order), illustrate the process generated in evaluating ~(gcd 206 40)~ and indicate the ~remainder~ operations that are actually performed.  How many ~remainder~ operations are actually performed in the normal-order evaluation of ~(gcd 206 40)~?  In the applicative-order evaluation?

Normal order (expand everything at every step) from SchemeWiki:

#+BEGIN_EXAMPLE
(gcd 206 40) 
  
(if (= 40 0) ...) 
  
(gcd 40 (remainder 206 40)) 
  
(if (= (remainder 206 40) 0) ...) 
  
(if (= 6 0) ...) 
  
(gcd (remainder 206 40) (remainder 40 (remainder 206 40))) 
  
(if (= (remainder 40 (remainder 206 40)) 0) ...) 
  
(if (= 4 0) ...) 
  
(gcd (remainder 40 (remainder 206 40)) (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))) 
  
(if (= (remainder (remainder 206 40) (remainder 40 (remainder 206 40))) 0) ...) 
  
(if (= 2 0) ...) 
  
(gcd (remainder (remainder 206 40) (remainder 40 (remainder 206 40))) (remainder (remainder 40 (remainder 206 40)) (remainder (remainder 206 40) (remainder 40 (remainder 206 40))))) 
  
(if (= (remainder (remainder 40 (remainder 206 40)) (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))) 0) ...) 
  
(if (= 0 0) ...) 
(remainder (remainder 206 40) (remainder 40 (remainder 206 40)))
#+END_EXAMPLE

Note that ~if~ is a special form ([[#exercise-1.6]]) that evaluates the predicate first. So most of the ~remainder~ operations were performed for in the predicates (14 in this case) and 4 were performed for the final calculation for a total of 18 calls.

Applicative order (evaluate operator and operands, then apply):

#+BEGIN_EXAMPLE
(gcd 206 40)
(gcd 40 (remainder 206 40))
(gcd 40 6)
(gcd 6 (remainder 40 6))
(gcd 6 4)
(gcd 4 (remainder 6 4))
(gcd 4 2)
(gcd 2 (remainder 4 2))
(gcd 2 0)
2
#+END_EXAMPLE

Just 4 ~remainder~ operations, same as the number of toal steps - 1.

**** DONE 1.2.6 Example: Testing for Primality

#+NAME: square
#+BEGIN_SRC racket :lang sicp
(define (square x)
  (* x x))
#+END_SRC

#+RESULTS: square

#+BEGIN_SRC racket :lang sicp :noweb yes
<<square>>

(define (smallest-divisor n)
  (find-divisor n 2))

;; if n can be divided by test-divisor returns it
;; else increments test-divisor & continues
;; if test-divisor squared is greater than the number being tested
;; has no divisors other than self
(define (find-divisor n test-divisor)
  (cond
    [(> (square test-divisor) n) n]
    [(divides? test-divisor n) test-divisor]
    [else (find-divisor n (+ test-divisor 1))]))

(define (divides? a b)
  (= (remainder b a) 0))

(define (prime? n)
  (= n (smallest-divisor n)))

(prime? 7)
(prime? 9)
#+END_SRC

#+RESULTS:
: #t
: #f

*Fermat's Little Theorem:* Let \(n \in \mathbb{N}\) be a prime number and let \(a \in \mathbb{N}\) where \(0 < a < n\). Then \(a^n \equiv_n a\).

#+NAME: expmod
#+BEGIN_SRC racket :lang sicp :noweb yes
<<square>>
(define (expmod base exp m)
  (cond
    [(= exp 0) 1]
    [(even? exp) (remainder (square (expmod base (/ exp 2) m)) m)]
    [else (remainder (* base (expmod base (- exp 1) m)) m)]))
#+END_SRC

#+RESULTS: expmod

Refer to [[#exercise-1.25]] for why this is implemented separately.

#+NAME: fermat-test
#+BEGIN_SRC racket :lang sicp :noweb yes
<<expmod>>
(define (fermat-test n)
  (define (try-it a)
    (= (expmod a n n) a))
  (try-it (+ 1 (random (- n 1)))))
#+END_SRC

#+RESULTS:

#+BEGIN_SRC racket :lang sicp :noweb yes
<<fermat-test>>
(define (fast-prime? n times)
  (cond
    [(= times 0) true]
    [(fermat-test n) (fast-prime? n (- times 1))]
    [else false]))

(fast-prime? 97 5)
#+END_SRC

#+RESULTS:
: #t

Carmichael numbers: numbers n that share the property of prime numbers in Fermat's Little Theorem.

***** DONE Exercise 1.21
:PROPERTIES:
:CUSTOM_ID: exercise-1.21
:END:

Use the ~smallest-divisor~ procedure to find the smallest divisor of each of the following numbers: 199, 1999, 19999.

Way too trivial. Just call the procedure already written. They are 199, 1999 and 7 respectively.

***** DONE Exercise 1.22
:PROPERTIES:
:CUSTOM_ID: exercise-1.22
:END:

Most Lisp implementations include a primitive called ~runtime~ that returns an integer that specifies the amount of time the system has been running (measured, for example, in microseconds).  The following ~timed-prime-test~ procedure, when called with an integer n, prints n and checks to see if n is prime.  If n is prime, the procedure prints three asterisks followed by the amount of time used in performing the test.

#+BEGIN_SRC scheme
(define (timed-prime-test n)
  (newline)
  (display n)
  (start-prime-test n (runtime)))

(define (start-prime-test n start-time)
  (if (prime? n)
      (report-prime (- (runtime) start-time))))

(define (report-prime elapsed-time)
  (display " *** ")
  (display elapsed-time))
#+END_SRC

Using this procedure, write a procedure ~search-for-primes~ that checks the primality of consecutive odd integers in a specified range.  Use your procedure to find the three smallest primes larger than 1000; larger than 10,000; larger than 100,000; larger than 1,000,000.  Note the time needed to test each prime.  Since the testing algorithm has order of growth of \theta([sqrt](n)), you should expect that testing for primes around 10,000 should take about [sqrt](10) times as long as testing for primes around 1000.  Do your timing data bear this out?  How well do the data for 100,000 and 1,000,000 support the [sqrt](n) prediction?  Is your result compatible with the notion that programs on your machine run in time proportional to the number of steps required for the computation?

#+BEGIN_SRC racket :noweb yes
#lang sicp

<<square>>

(define (start-prime-test n start-time)
  (if (prime? n) (report-prime n (- (runtime) start-time)) #f))

(define (report-prime n elapsed-time)
  (newline)
  (display n)
  (display " *** ")
  (display elapsed-time))

(define (smallest-divisor n)
  (find-divisor n 2))

(define (find-divisor n test-divisor)
  (cond
    [(> (square test-divisor) n) n]
    [(divides? test-divisor n) test-divisor]
    [else (find-divisor n (+ test-divisor 1))]))

(define (divides? a b)
  (= (remainder b a) 0))

(define (prime? n)
  (= n (smallest-divisor n)))

(define (search-for-primes start n)
  (cond
    [(= n 0) (newline)]
    [(even? start) (search-for-primes (+ start 1) n)]
    [(start-prime-test start (runtime)) (search-for-primes (+ start 2) (- n 1))]
    [else (search-for-primes (+ start 2) n)]))

(search-for-primes 100000 3)
(search-for-primes 1000000 3)
(search-for-primes 10000000 3)
#+END_SRC

#+RESULTS:
#+begin_example

100003 *** 5
100019 *** 5
100043 *** 5

1000003 *** 15
1000033 *** 14
1000037 *** 15

10000019 *** 45
10000079 *** 45
10000103 *** 45
#+end_example

Wow, the order of growth is roughly \(O(\sqrt{n})\). Every time n increases tenfold the time increases by about 3.3/

***** DONE Exercise 1.23
:PROPERTIES:
:CUSTOM_ID: exercise-1.23
:END:

The ~smallest-divisor~ procedure shown at the start of this section does lots of needless testing: After it checks to see if the number is divisible by 2 there is no point in checking to see if it is divisible by any larger even numbers.  This suggests that the values used for ~test-divisor~ should not be 2, 3, 4, 5, 6, ..., but rather 2, 3, 5, 7, 9, ....  To implement this change, define a procedure ~next~ that returns 3 if its input is equal to 2 and otherwise returns its input plus 2.  Modify the ~smallest-divisor~ procedure to use ~(next test-divisor)~ instead of ~(+ test-divisor 1)~.  With ~timed-prime-test~ incorporating this modified version of ~smallest-divisor~, run the test for each of the 12 primes found in [[#exercise-1.22][Exercise 1.22]].  Since this modification halves the number of test steps, you should expect it to run about twice as fast.  Is this expectation confirmed?  If not, what is the observed ratio of the speeds of the two algorithms, and how do you explain the fact that it is different from 2?

#+BEGIN_SRC racket :noweb yes
#lang sicp

<<square>>

(define (start-prime-test n start-time)
  (if (prime? n) (report-prime n (- (runtime) start-time)) #f))

(define (report-prime n elapsed-time)
  (newline)
  (display n)
  (display " *** ")
  (display elapsed-time))

(define (smallest-divisor n)
  (find-divisor n 2))

(define (next n)
  (if (= n 2) 3 (+ n 2)))

(define (find-divisor n test-divisor)
  (cond
    [(> (square test-divisor) n) n]
    [(divides? test-divisor n) test-divisor]
    [else (find-divisor n (next test-divisor))]))

(define (divides? a b)
  (= (remainder b a) 0))

(define (prime? n)
  (= n (smallest-divisor n)))

(define (search-for-primes start n)
  (cond
    [(= n 0) (newline)]
    [(even? start) (search-for-primes (+ start 1) n)]
    [(start-prime-test start (runtime)) (search-for-primes (+ start 2) (- n 1))]
    [else (search-for-primes (+ start 2) n)]))

(search-for-primes 100000 3)
(search-for-primes 1000000 3)
(search-for-primes 10000000 3)
#+END_SRC

#+RESULTS:
#+begin_example

100003 *** 2
100019 *** 3
100043 *** 2

1000003 *** 7
1000033 *** 8
1000037 *** 7

10000019 *** 23
10000079 *** 23
10000103 *** 23
#+end_example

The runtime did halve! I think the question prompt expects the new implementation to be slightly less than twice as fast, due to that the ~next~ procedure has its own overhead, which can also be observed, though there is some variance when running the code through Babel.

***** DONE Exercise 1.24
:PROPERTIES:
:CUSTOM_ID: exercise-1.24
:END:

Modify the ~timed-prime-test~ procedure of [[#exercise-1.22][Exercise 1.22]] to use ~fast-prime?~ (the Fermat method), and test each of the 12 primes you found in that exercise.  Since the Fermat test has \theta(log n) growth, how would you expect the time to test primes near 1,000,000 to compare with the time needed to test primes near 1000?  Do your data bear this out?  Can you explain any discrepancy you find?

#+BEGIN_SRC racket :noweb yes
#lang sicp

(define (start-prime-test n start-time)
  (if (prime? n) (report-prime n (- (runtime) start-time)) #f))

(define (report-prime n elapsed-time)
  (newline)
  (display n)
  (display " *** ")
  (display elapsed-time))

<<fermat-test>>
(define (fast-prime? n times)
  (cond
    [(= times 0) true]
    [(fermat-test n) (fast-prime? n (- times 1))]
    [else false]))

(define (prime? n)
  (fast-prime? n 20))

(define (search-for-primes start n)
  (cond
    [(= n 0) (newline)]
    [(even? start) (search-for-primes (+ start 1) n)]
    [(start-prime-test start (runtime)) (search-for-primes (+ start 2) (- n 1))]
    [else (search-for-primes (+ start 2) n)]))

(search-for-primes 100 3)
(search-for-primes 10000 3)
(search-for-primes 100000000 3)
#+END_SRC

#+RESULTS:
#+begin_example

101 *** 12
103 *** 7
107 *** 7

10007 *** 13
10009 *** 13
10037 *** 13

100000007 *** 23
100000037 *** 23
100000039 *** 24
#+end_example

Doubling the number of digits roughly doubles the runtime, suggesting \(O(\log{n})\) growth.

***** DONE Exercise 1.25
:PROPERTIES:
:CUSTOM_ID: exercise-1.25
:END:

Alyssa P. Hacker complains that we went to a lot of extra work in writing ~expmod~.  After all, she says, since we already know how to compute exponentials, we could have simply written

#+BEGIN_SRC scheme
(define (expmod base exp m)
  (remainder (fast-expt base exp) m))
#+END_SRC

Is she correct?  Would this procedure serve as well for our fast prime tester?  Explain.

This works, but at first sight you can tell that the original ~expmod~ is trying to do something clever by calling ~remainder~ at each level. Indeed, as footnote 46 explains, ~x * y % m = ((x % m) * (y % m)) % m~; in ~expmod~, this works as ~((base^(exp / 2) % m) * (base^(exp / 2) % m)) % m~ (with recurcion), so that it does not need to calculate the mod for a very large number in the end.

***** DONE Exercise 1.26
:PROPERTIES:
:CUSTOM_ID: exercise-1.26
:END:

Louis Reasoner is having great difficulty doing [[#exercise-1.24][Exercise 1.24]].  His ~fast-prime?~ test seems to run more slowly than his ~prime?~ test.  Louis calls his friend Eva Lu Ator over to help.  When they examine Louis's code, they find that he has rewritten the ~expmod~ procedure to use an explicit multiplication, rather than calling ~square~:

#+BEGIN_SRC scheme
(define (expmod base exp m)
  (cond ((= exp 0) 1)
        ((even? exp)
         (remainder (* (expmod base (/ exp 2) m)
                       (expmod base (/ exp 2) m))
                    m))
        (else
         (remainder (* base (expmod base (- exp 1) m))
                    m))))
#+END_SRC

"I don't see what difference that could make," says Louis.  "I do."  says Eva.  "By writing the procedure like that, you have transformed the \theta(log n) process into a \theta(n) process."  Explain.

The whole idea of ~expmod~ being \(O(\log{n})\) is that it keeps dividing the exponent by two while squaring to make up for that, so that the number of times it needs to call itself is on logarithmic scale. The above implementation would call ~expmod~ twice in each step (in applicative order), making it tree recursion on exponential scale. This nullifies the benefit of exponentiation by squaring.

In other words, you have \(O(n^{log{n}}) = O(n)\) in the end.

***** DONE Exercise 1.27
:PROPERTIES:
:CUSTOM_ID: exercise-1.27
:END:

Demonstrate that the Carmichael numbers listed in [fn:47] really do fool the Fermat test.  That is, write a procedure that takes an integer n and tests whether a^n is congruent to a modulo n for every a<n, and try your procedure on the given Carmichael numbers.

#+BEGIN_SRC racket :noweb yes
#lang sicp
<<expmod>>

(define (test-congrent n)
  (define (iter a)
    (cond
      [(= a n) #t]
      [(= (expmod a n n) a) (iter (+ a 1))]
      [else #f]))
  (iter 0))

(test-congrent 100)
(test-congrent 560)
(test-congrent 561)
(test-congrent 1105)
(test-congrent 1729)
(test-congrent 2465)
(test-congrent 2821)
(test-congrent 6601)
#+END_SRC

#+RESULTS:
: #f
: #f
: #t
: #t
: #t
: #t
: #t
: #t

***** DONE Exercise 1.28
:PROPERTIES:
:CUSTOM_ID: exercise-1.28
:END:

One variant of the Fermat test that cannot be fooled is called the <<i238>> Miller-Rabin test (Miller 1976; Rabin 1980).  This starts from an alternate form of Fermat's Little Theorem, which states that if n is a prime number and a is any positive integer less than n, then a raised to the (n - 1)st power is congruent to 1 modulo n.  To test the primality of a number n by the Miller-Rabin test, we pick a random number a<n and raise a to the (n - 1)st power modulo n using the ~expmod~ procedure.  However, whenever we perform the squaring step in ~expmod~, we check to see if we have discovered a "nontrivial square root of 1 modulo n," that is, a number not equal to 1 or n - 1 whose square is equal to 1 modulo n.  It is possible to prove that if such a nontrivial square root of 1 exists, then n is not prime.  It is also possible to prove that if n is an odd number that is not prime, then, for at least half the numbers a<n, computing a^(n-1) in this way will reveal a nontrivial square root of 1 modulo n.  (This is why the Miller-Rabin test cannot be fooled.)  Modify the ~expmod~ procedure to signal if it discovers a nontrivial square root of 1, and use this to implement the Miller-Rabin test with a procedure analogous to ~fermat-test~.  Check your procedure by testing various known primes and non-primes.  Hint: One convenient way to make ~expmod~ signal is to have it return 0.

#+BEGIN_SRC racket :noweb yes
#lang sicp
<<square>>

(define (square-with-check x n)
  (cond
    [(and (not (= 1 x)) (not (= (- n 1) x)) (= 1 (remainder (square x) n))) 0]
    [else (square x)]))

(define (expmod base exp m)
  (cond
    [(= exp 0) 1]
    [(even? exp) (remainder (square-with-check (expmod base (/ exp 2) m) m) m)]
    [else (remainder (* base (expmod base (- exp 1) m)) m)]))

(define (miller-rabin-test n)
  (define (test a)
    (= (expmod a (- n 1) n) 1))
  (test (+ 1 (random (- n 1)))))

(define (fast-prime? n times)
  (cond
    [(= times 0) true]
    [(miller-rabin-test n) (fast-prime? n (- times 1))]
    [else false]))

(define (prime? n)
  (fast-prime? n 10))

(prime? 89)
(prime? 97)
(prime? 101)
(prime? 103)
(prime? 107)
(newline)
(prime? 561)
(prime? 1729)
(prime? 2465)
(prime? 2821)
(prime? 6601)
#+END_SRC

#+RESULTS:
#+begin_example
#t
#t
#t
#t
#t

#f
#f
#f
#f
#f
#+end_example

Passing the check result for "nontrivial square root of 1 modulo n" feels pretty hacky (actually checked in ~square-with-check~, which would return 0, which would cause ~expmod~ to return 0 as a result of ~0 mod m~).

Feels kind of bad to just be implementing this without a proof. Some very good material can be found [[https://crypto.stanford.edu/pbc/notes/numbertheory/millerrabin.html][here]] and [[http://math.bu.edu/people/dmm/341/Handouts/sqrts-one-modm.pdf][here]]. To paraphrase, the most important fact is that some \(n\) is an odd prime if and only if the solutions of \(x^2 \equiv_n 1\) are \(x = \pm 1\), which is what this exercise asks us to check during the squaring step.

To see this, rewrite as \(x^2 - 1 \equiv_n 0\) and \((x - 1)(x + 1) \equiv_n 0\). The trivial square roots are \(x = \pm 1\). If \(n\) is an odd prime, then it divides at least one of \(x - 1\) and \(x + 1\) (Euclid's lemma). Moreover, we can show that it only divides one of them because if \(n | (x - 1)\) and \(n | (x + 1)\), \(n | ((x + 1) - (x - 1)) \Rightarrow x | 2\). Since \(x\) is odd, this is impossible.

Without the loss of generality, consider \(n|(x + 1)\Rightarrow (x + 1) \equiv_n 0 \Rightarrow x \equiv_n -1\). The other case yields \(x \equiv_n 1\). Hence the only possible solutions are \(x \equiv_n \pm 1\). Since \(x\) is always smaller than \(n\) in our algorithm (x is output from ~expmod~, which does ~a^n % n~), the only solutions are \(x = \pm 1\).

#+RESULTS:
#+begin_example
#t
#t
#t
#t
#t

#f
#f
#f
#f
#f
#+end_example

*** DONE 1.3 Formulating Abstractions with Higher-Order Procedures
**** DONE 1.3.1 Procedures as Arguments

#+BEGIN_SRC racket
#lang sicp
(define (sum-integers a b)
  (if (> a b) 0 (+ a (sum-integers (+ a 1) b))))

(sum-integers 1 10)
#+END_SRC

#+RESULTS:
: 55

#+NAME: cube
#+BEGIN_SRC racket
(define (cube x)
  (* x x x))
#+END_SRC

#+BEGIN_SRC racket :noweb yes
#lang sicp
<<cube>>
(define (sum-cubes a b)
  (if (> a b) 0 (+ (cube a) (sum-cubes (+ a 1) b))))

(sum-cubes 1 3)
#+END_SRC

#+RESULTS:
: 36

#+BEGIN_SRC racket
#lang sicp
(define (pi-sum a b)
  (if (> a b) 0 (+ (/ 1.0 (* a (+ a 2))) (pi-sum (+ a 4) b))))

(* 8 (pi-sum 1 100000))
#+END_SRC

#+RESULTS:
: 3.141572653589795

Abstraction for series summation:

#+BEGIN_SRC scheme
(define (<NAME> a b)
  (if (> a b)
      0
      (+ (<TERM> a)
         (<NAME> (<NEXT> a) b))))
#+END_SRC

#+BEGIN_SRC racket :noweb yes
#lang sicp
<<cube>>

(define (sum term a next b)
  (if (> a b) 0 (+ (term a) (sum term (next a) next b))))

(define (inc n)
  (+ n 1))

(define (sum-cubes a b)
  (sum cube a inc b))

(sum-cubes 1 10)

(define (identity x)
  x)

(define (sum-integers a b)
  (sum identity a inc b))

(sum-integers 1 10)

(define (pi-sum a b)
  (define (pi-term x)
    (/ 1.0 (* x (+ x 2))))
  (define (pi-next x)
    (+ x 4))
  (sum pi-term a pi-next b))

(* 8 (pi-sum 1 100000))

(define (integral f a b dx)
  (define (add-dx x)
    (+ x dx))
  (* (sum f (+ a (/ dx 2.0)) add-dx b) dx))

(integral cube 0 1 0.0001)
#+END_SRC

#+RESULTS:
: 3025
: 55
: 3.141572653589795
: 0.24999999874993412

***** DONE Exercise 1.29
:PROPERTIES:
:CUSTOM_ID: exercise-1.29
:END:

Simpson's Rule is a more accurate method of numerical integration than the method illustrated above.  Using Simpson's Rule, the integral of a function f between a and b is approximated as

#+BEGIN_EXAMPLE
 h
 - (y_0 + 4y_1 + 2y_2 + 4y_3 + 2y_4 + ... + 2y_(n-2) + 4y_(n-1) + y_n)
 3
#+END_EXAMPLE

where h = (b - a)/n, for some even integer n, and y_k = f(a + kh).  (Increasing n increases the accuracy of the approximation.)  Define a procedure that takes as arguments f, a, b, and n and returns the value of the integral, computed using Simpson's Rule.  Use your procedure to integrate ~cube~ between 0 and 1 (with n = 100 and n = 1000), and compare the results to those of the ~integral~ procedure shown above.

#+BEGIN_SRC racket :noweb yes
#lang sicp
<<cube>>

(define (sum term a next b i)
  (if (> a b)
      0
      (+ (cond
           [(or (= i 0) (= a b)) (term a)]
           [(odd? i) (* 4 (term a))]
           [else (* 2 (term a))])
         (sum term (next a) next b (+ i 1)))))

(define (simpson f a b n)
  (define (add-dx x)
    (+ x (/ (- b a) n)))
  (* (/ (/ (- b a) n) 3.0) (sum f a add-dx b 0)))

(simpson cube 0 1 1000)
#+END_SRC

#+RESULTS:
: 0.25

Saw a solution from SchemeWiki that I like:

#+BEGIN_SRC racket :noweb yes
#lang sicp
<<cube>>

(define (sum-iter ans f a next b)
  (if (> a b) ans (sum-iter (+ ans (f a)) f (next a) next b)))

(define (simpson-integral f a b n)
  (define h (/ (- b a) n))
  (define (y k)
    (f (+ a (* k h))))
  (define (intersimp k)
    (* (cond
         [(or (= k 0) (= k n)) 1]
         [(even? k) 2]
         [else 4])
       (y k)))
  (define (inc a)
    (+ a 1))
  (* (sum-iter 0 intersimp 0 inc n) (/ h 3.0)))

(simpson-integral cube 0 1 100)
#+END_SRC

#+RESULTS:
: 0.25

So it's a good idea to just make each variable a procedure even though they are not mutated directly. Also a good idea to feed k and n into ~sum~ instead of a and b.

***** DONE Exercise 1.30
:PROPERTIES:
:CUSTOM_ID: exercise-1.30
:END:

The ~sum~ procedure above generates a linear recursion.  The procedure can be rewritten so that the sum is performed iteratively.  Show how to do this by filling in the missing expressions in the following definition:

#+BEGIN_SRC racket :noweb yes
#lang sicp
<<cube>>
(define (sum term a next b)
  (define (iter a result)
    (if (> a b) result (iter (next a) (+ result (term a)))))
  (iter a 0))

(define (integral f a b dx)
  (define (add-dx x)
    (+ x dx))
  (* (sum f (+ a (/ dx 2.0)) add-dx b) dx))

(integral cube 0 1 0.0001)
#+END_SRC

#+RESULTS:
: 0.24999999874993337

***** DONE Exercise 1.31
:PROPERTIES:
:CUSTOM_ID: exercise-1.31
:END:

a. The ~sum~ procedure is only the simplest of a vast number of similar abstractions that can be captured as higher-order procedures.[fn:51] Write an analogous procedure called ~product~ that returns the product of the values of a function at points over a given range.  Show how to define ~factorial~ in terms of ~product~.  Also use ~product~ to compute approximations to \pi using the formula[fn:52]

#+BEGIN_EXAMPLE
 pi   2 * 4 * 4 * 6 * 6 * 8 ...
 -- = ---------------------
  4   3 * 3 * 5 * 5 * 7 * 7 ...
#+END_EXAMPLE

   #+BEGIN_SRC racket
   #lang sicp

   ;; recursive
   (define (product f a next b)
     (if (> a b) 1 (* (f a) (product f (next a) next b))))

   (define (factorial n)
     (define (identity x)
       x)
     (define (inc x)
       (+ 1 x))
     (product identity 1 inc n))

   (factorial 10)

   (define (pi-sum n)
     (define (term-upper i)
       (+ i (if (odd? i) 3 2)))
     (define (term-lower i)
       (+ i (if (even? i) 3 2)))
     (define (inc x)
       (+ 1 x))
     (* 4.0 (/ (product term-upper 0 inc n) (product term-lower 0 inc n))))

   (pi-sum 10000)
   #+END_SRC

   #+RESULTS:
   : 3628800
   : 3.1414356249917024

b. If your ~product~ procedure generates a recursive process, write one that generates an iterative process.  If it generates an iterative process, write one that generates a recursive process.

   #+BEGIN_SRC racket
   #lang sicp

   ;; iterative
   (define (product f a next b)
     (define (iter a result)
       (if (> a b) result (iter (next a) (* (f a) result))))
     (iter a 1))

   (define (factorial n)
     (define (identity x)
       x)
     (define (inc x)
       (+ 1 x))
     (product identity 1 inc n))

   (factorial 10)

   (define (pi-sum n)
     (define (term-upper i)
       (+ i (if (odd? i) 3 2)))
     (define (term-lower i)
       (+ i (if (even? i) 3 2)))
     (define (inc x)
       (+ 1 x))
     (* 4.0 (/ (product term-upper 0 inc n) (product term-lower 0 inc n))))

   (pi-sum 10000)
   #+END_SRC

   #+RESULTS:
   : 3628800
   : 3.1414356249917024

***** DONE Exercise 1.32
:PROPERTIES:
:CUSTOM_ID: exercise-1.32
:END:

a. Show that ~sum~ and ~product~ ([[#exercise-1.31][Exercise 1.31]]) are both special cases of a still more general notion called ~accumulate~ that combines a collection of terms, using some general accumulation function:

#+BEGIN_SRC scheme
(accumulate combiner null-value term a next b)
#+END_SRC

~accumulate~ takes as arguments the same term and range specifications as ~sum~ and ~product~, together with a ~combiner~ procedure (of two arguments) that specifies how the current term is to be combined with the accumulation of the preceding terms and a ~null-value~ that specifies what base value to use when the terms run out.  Write ~accumulate~ and show how ~sum~ and ~product~ can both be defined as simple calls to ~accumulate~.

#+BEGIN_SRC racket
#lang sicp

;; recursive
(define (accumulate combiner null-value term a next b)
  (if (> a b) null-value (combiner (term a) (accumulate combiner null-value term (next a) next b))))

(define (sum term a next b)
  (define (combiner a b)
    (+ a b))
  (accumulate combiner 0 term a next b))

(define (sum-integers a b)
  (define (identity x)
    x)
  (define (inc x)
    (+ x 1))
  (sum identity a inc b))

(sum-integers 1 10)

(define (product term a next b)
  (define (combiner a b)
    (* a b))
  (accumulate combiner 1 term a next b))

(define (factorial n)
  (define (identity x)
    x)
  (define (inc x)
    (+ 1 x))
  (product identity 1 inc n))

(factorial 10)
#+END_SRC

#+RESULTS:
: 55
: 3628800

b. If your ~accumulate~ procedure generates a recursive process, write one that generates an iterative process.  If it generates an iterative process, write one that generates a recursive process.

#+BEGIN_SRC racket
#lang sicp

;; iterative
(define (accumulate combiner null-value term a next b)
  (define (iter a result)
    (if (> a b)
        result
        (iter (next a) (combiner (term a) result))))
  (iter a null-value))

(define (sum term a next b)
  (define (combiner a b)
    (+ a b))
  (accumulate combiner 0 term a next b))

(define (sum-integers a b)
  (define (identity x)
    x)
  (define (inc x)
    (+ x 1))
  (sum identity a inc b))

(sum-integers 1 10)

(define (product term a next b)
  (define (combiner a b)
    (* a b))
  (accumulate combiner 1 term a next b))

(define (factorial n)
  (define (identity x)
    x)
  (define (inc x)
    (+ 1 x))
  (product identity 1 inc n))

(factorial 10)
#+END_SRC

#+RESULTS:
: 55
: 3628800

***** DONE Exercise 1.33
:PROPERTIES:
:CUSTOM_ID: exercise-1.33
:END:

You can obtain an even more general version of ~accumulate~ ([[#exercise-1.32][Exercise 1.32]]) by introducing the notion of a <<i137>> filter on the terms to be combined.  That is, combine only those terms derived from values in the range that satisfy a specified condition.  The resulting ~filtered-accumulate~ abstraction takes the same arguments as accumulate, together with an additional predicate of one argument that specifies the filter.  Write ~filtered-accumulate~ as a procedure.  Show how to express the following using ~filtered-accumulate~:

a. the sum of the squares of the prime numbers in the interval a to b (assuming that you have a ~prime?~ predicate already written)

b. the product of all the positive integers less than n that are relatively prime to n (i.e., all positive integers i < n such that GCD(i,n) = 1).

#+BEGIN_SRC racket
#lang sicp

(define (filtered-accumulate combiner filter null-value term a next b)
  (define (iter a result)
    (if (> a b) result (iter (next a) (if (filter a) (combiner (term a) result) result))))
  (iter a null-value))

(define (square x)
  (* x x))

(define (square-with-check x n)
  (cond
    [(and (not (= 1 x)) (not (= (- n 1) x)) (= 1 (remainder (square x) n))) 0]
    [else (square x)]))

(define (expmod base exp m)
  (cond
    [(= exp 0) 1]
    [(even? exp) (remainder (square-with-check (expmod base (/ exp 2) m) m) m)]
    [else (remainder (* base (expmod base (- exp 1) m)) m)]))

(define (miller-rabin-test n)
  (define (test a)
    (= (expmod a (- n 1) n) 1))
  (test (+ 1 (random (- n 1)))))

(define (fast-prime? n times)
  (cond
    [(= times 0) true]
    [(miller-rabin-test n) (fast-prime? n (- times 1))]
    [else false]))

(define (prime? n)
  (cond
    [(= n 0) #f]
    [(= n 1) #f]
    [else (fast-prime? n 10)]))

(define (gcd a b)
  (if (= b 0) a (gcd b (remainder a b))))

(define (sum-square-primes a b)
  (define (inc x)
    (+ x 1))
  (define (add a b)
    (+ a b))
  (filtered-accumulate add prime? 0 square a inc b))

(sum-square-primes 1 10)

(define (product-relative-primes n)
  (define (inc x)
    (+ x 1))
  (define (identity x)
    x)
  (define (product a b)
    (* a b))
  (define (relative-prime? x)
    (= (gcd x n) 1))
  (filtered-accumulate product relative-prime? 1 identity 1 inc n))

(product-relative-primes 10)
#+END_SRC

#+RESULTS:
: 87
: 189

**** DONE 1.3.2 Constructing Procedures Using Lambda

#+BEGIN_SRC racket :noweb yes
#lang sicp

(define (sum term a next b)
  (define (iter a result)
    (if (> a b) result (iter (next a) (+ result (term a)))))
  (iter a 0))

(define (pi-sum a b)
  (sum (lambda (x) (/ 1.0 (* x (+ x 2)))) a (lambda (x) (+ x 4)) b))

(define (integral f a b dx)
  (* (sum f (+ a (/ dx 2.0)) (lambda (x) (+ x dx)) b) dx))

(* 8 (pi-sum 1 100000))
(integral (lambda (x) (* x x x)) 0 1 0.0001)
#+END_SRC

#+RESULTS:
: 3.141572653589808
: 0.24999999874993337

#+BEGIN_SRC racket
#lang sicp

((lambda (x y z) (+ x y ((lambda (x) (* x x)) z))) 1 2 3)
#+END_SRC

#+RESULTS:
: 12

~let~

#+BEGIN_SRC racket
#lang sicp

(define (f x y)
  (let ([a (+ 1 (* x y))] [b (- 1 y)]) (+ (* x (* a a)) (* y b) (* a b))))
#+END_SRC

is just syntactic sugar for:

#+BEGIN_SRC racket
#lang sicp

(define (f x y)
  ((lambda (a b) (+ (* x (* a a)) (* y b) (* a b))) (+ 1 (* x y)) (- 1 y)))

#+END_SRC

~let~ binds variables locally

#+BEGIN_SRC racket
#lang sicp

(+ (let ((x 3)) (+ x (* x 10))) (let ((x 5)) x))
#+END_SRC

#+RESULTS:
: 38

Note that the value of ~y~ depends on the value of the inner ~x~:

#+BEGIN_SRC racket
#lang sicp

(let ((x 2)) (let ((x 3) (y (+ x 2))) (* x y)))
#+END_SRC

#+RESULTS:
: 12

***** DONE Exercise 1.34
:PROPERTIES:
:CUSTOM_ID: exercise-1.34
:END:

Suppose we define the procedure

#+BEGIN_SRC scheme
(define (f g)
  (g 2))
#+END_SRC

Then we have

#+BEGIN_SRC scheme
(f square)
4

(f (lambda (z) (* z (+ z 1))))
6
#+END_SRC

What happens if we (perversely) ask the interpreter to evaluate the combination ~(f f)~?  Explain.

#+BEGIN_SRC racket
#lang sicp

(define (f g) (g 2))

(f f)
#+END_SRC

#+RESULTS:
: application: not a procedure;
:  expected a procedure that can be applied to arguments
:   given: 2
:   context...:
:    /var/folders/31/xkn6lwrs7_382lqhy5f9wzbc0000gn/T/ob-racket-nM8upz/ob-racketPneXJK.rkt:6:0
:    body of "/var/folders/31/xkn6lwrs7_382lqhy5f9wzbc0000gn/T/ob-racket-nM8upz/ob-racketPneXJK.rkt"

Just as I expected, this doesn't work. The interpreter likely tried to apply ~(f 2)~, then ~(2 2)~, which doesn't work because ~2~ is not a procedure, let alone one that takes arguments.

**** DONE 1.3.3 Procedures as General Methods

#+BEGIN_SRC racket
#lang sicp

(define (search f neg-point pos-point)
  (define (close-enough? x y)
    (< (abs (- x y)) 0.000000000000001))
  (define (average a b)
    (/ (+ a b) 2))
  (let ([midpoint (average neg-point pos-point)])
    (if (close-enough? neg-point pos-point)
        midpoint
        (let ([test-value (f midpoint)])
          (cond
            [(positive? test-value) (search f neg-point midpoint)]
            [(negative? test-value) (search f midpoint pos-point)]
            [else midpoint])))))

(define (half-interval-method f a b)
  (let ([a-value (f a)] [b-value (f b)])
    (cond
      [(and (negative? a-value) (positive? b-value)) (search f a b)]
      [(and (negative? b-value) (positive? a-value)) (search f b a)]
      [else (error "Values are not of opposite sign at" a b)])))

(half-interval-method sin 2.0 4.0)

(half-interval-method (lambda (x) (- (* x x x) (* 2 x) 3)) 1.0 2.0)
#+END_SRC

#+RESULTS:
: 3.1415926535897936
: 1.8932891963044978

#+BEGIN_SRC racket
#lang sicp

(define tolerance 0.000000000000001)
(define (fixed-point f first-guess)
  (define (close-enough? v1 v2)
    (< (abs (- v1 v2)) tolerance))
  (define (try guess)
    (let ([next (f guess)]) (if (close-enough? guess next) next (try next))))
  (try first-guess))

(fixed-point cos 1.0)

(fixed-point (lambda (y) (+ (sin y) (cos y))) 1.0)

(define (average a b)
  (/ (+ a b) 2))

(define (sqrt x)
  (fixed-point (lambda (y) (average y (/ x y))) 1.0))

(sqrt 2.0)
#+END_SRC

#+RESULTS:
: 0.7390851332151603
: 1.2587281774926762
: 1.414213562373095

For ~sqrt~, note that just finding the fixed point for \(y = x/y\) does not work because let \(y_2 = x / y_1\), then \(y_3 = x / y_2 = y_1\). Instead /average damping/ is applied such that the new guess is not as far from the previous one and the search converges.

***** DONE Exercise 1.35
:PROPERTIES:
:CUSTOM_ID: exercise-1.35
:END:

Show that the golden ratio \phi (section [[#section-1.2.2][1.2.2]]) is a fixed point of the transformation x |-> 1 + 1/x, and use this fact to compute \phi by means of the ~fixed-point~ procedure.

#+BEGIN_SRC racket
#lang sicp

(define tolerance 0.000000000000001)
(define (fixed-point f first-guess)
  (define (close-enough? v1 v2)
    (< (abs (- v1 v2)) tolerance))
  (define (try guess)
    (let ([next (f guess)]) (if (close-enough? guess next) next (try next))))
  (try first-guess))

(fixed-point (lambda (x) (+ 1 (/ 1.0 x))) 1.0)
#+END_SRC

#+RESULTS:
: 1.618033988749895

***** DONE Exercise 1.36
:PROPERTIES:
:CUSTOM_ID: exercise-1.36
:END:

Modify ~fixed-point~ so that it prints the sequence of approximations it generates, using the ~newline~ and ~display~ primitives shown in [[#exercise-1.22][Exercise 1.22]].  Then find a solution to x^x = 1000 by finding a fixed point of x |-> log(1000)/log(x).  (Use Scheme's primitive ~log~ procedure, which computes natural logarithms.)  Compare the number of steps this takes with and without average damping.  (Note that you cannot start ~fixed-point~ with a guess of 1, as this would cause division by log(1) = 0.)

#+BEGIN_SRC racket
#lang sicp

(define tolerance 0.000000001)
(define (fixed-point f first-guess)
  (define (close-enough? v1 v2)
    (< (abs (- v1 v2)) tolerance))
  (define (try guess)
    (display guess)
    (newline)
    (let ([next (f guess)]) (if (close-enough? guess next) next (try next))))
  (try first-guess))

(define (average a b)
  (/ (+ a b) 2))

(display "without damping\n")
(fixed-point (lambda (x) (/ (log 1000) (log x))) 2.0)
(display "with damping\n")
(fixed-point (lambda (x) (average x (/ (log 1000) (log x)))) 2.0)
#+END_SRC

#+RESULTS:
#+begin_example
without dampening
2.0
9.965784284662087
3.004472209841214
6.279195757507157
3.759850702401539
5.215843784925895
4.182207192401397
4.8277650983445906
4.387593384662677
4.671250085763899
4.481403616895052
4.6053657460929
4.5230849678718865
4.577114682047341
4.541382480151454
4.564903245230833
4.549372679303342
4.559606491913287
4.552853875788271
4.557305529748263
4.554369064436181
4.556305311532999
4.555028263573554
4.555870396702851
4.555315001192079
4.5556812635433275
4.555439715736846
4.555599009998291
4.555493957531389
4.555563237292884
4.555517548417651
4.555547679306398
4.555527808516254
4.555540912917957
4.555532270803653
4.555537970114198
4.555534211524127
4.555536690243655
4.555535055574168
4.5555361336081
4.555535422664798
4.5555358915186215
4.555535582318266
4.555535786230128
4.555535651754059
4.555535740438517
4.5555356819527715
4.555535720523029
4.555535695086664
4.555535711861472
4.555535700798798
4.555535708094425
4.555535703283096
4.5555357064560775
4.555535704363555
4.555535705743535
4.5555357048334635
with dampening
2.0
5.9828921423310435
4.922168721308343
4.628224318195455
4.568346513136242
4.5577305909237005
4.555909809045131
4.555599411610624
4.5555465521473675
4.555537551999825
4.555536019631145
4.555535758730802
4.555535714310077
4.555535706747033
4.555535705459354
4.555535705240114
#+end_example

Clearly it converges a lot faster with damping.

***** DONE Exercise 1.37
:PROPERTIES:
:CUSTOM_ID: exercise-1.37
:END:

a. An infinite <<i85>> continued fraction is an expression of the form

#+BEGIN_EXAMPLE
            N_1
 f = ---------------------
                N_2
     D_1 + ---------------
                    N_3
           D_2 + ---------
                 D_3 + ...
#+END_EXAMPLE

As an example, one can show that the infinite continued fraction expansion with the n_i and the D_i all equal to 1 produces 1/\phi, where \phi is the golden ratio (described in section [[#section-1.2.2][1.2.2]]).  One way to approximate an infinite continued fraction is to truncate the expansion after a given number of terms.  Such a truncation--a so-called <<i200>> k-term finite continued fraction--has the form

#+BEGIN_EXAMPLE
        N_1
 -----------------
           N_2
 D_1 + -----------
       ...    N_K
           + -----
              D_K
#+END_EXAMPLE

Suppose that ~n~ and ~d~ are procedures of one argument (the term index i) that return the n_i and D_i of the terms of the continued fraction.  Define a procedure ~cont-frac~ such that evaluating ~(cont-frac n d k)~ computes the value of the k-term finite continued fraction.  Check your procedure by approximating 1/\phi using

#+BEGIN_SRC scheme
(cont-frac (lambda (i) 1.0)
           (lambda (i) 1.0)
           k)
#+END_SRC

for successive values of ~k~.  How large must you make ~k~ in order to get an approximation that is accurate to 4 decimal places?

#+BEGIN_SRC racket
#lang sicp

(define (cont-frac n d k)
  (define (rec i)
    (if (= k i) (/ (n i) (d i)) (/ (n i) (+ (d i) (rec (+ i 1))))))
  (rec 1))

(cont-frac (lambda (i) 1.0) (lambda (i) 1.0) 10)
(cont-frac (lambda (i) 1.0) (lambda (i) 1.0) 100)
(cont-frac (lambda (i) 1.0) (lambda (i) 1.0) 100000)
#+END_SRC

#+RESULTS:
: 0.6179775280898876
: 0.6180339887498948
: 0.6180339887498948

~k~ needs to be 10.

b. If your ~cont-frac~ procedure generates a recursive process, write one that generates an iterative process.  If it generates an iterative process, write one that generates a recursive process.

#+BEGIN_SRC racket
#lang sicp

(define (cont-frac n d k)
  (define (iter i res)
    (if (= i 1) (/ (n i) (+ (d i) res)) (iter (- i 1) (/ (n i) (+ (d i) res)))))
  (iter k 0.0))

(cont-frac (lambda (i) 1.0) (lambda (i) 1.0) 10)
(cont-frac (lambda (i) 1.0) (lambda (i) 1.0) 100)
(cont-frac (lambda (i) 1.0) (lambda (i) 1.0) 100000)
#+END_SRC

#+RESULTS:
: 0.6179775280898876
: 0.6180339887498948
: 0.6180339887498948

***** DONE Exercise 1.38
:PROPERTIES:
:CUSTOM_ID: exercise-1.38
:END:

In 1737, the Swiss mathematician Leonhard Euler published a memoir 'De Fractionibus Continuis', which included a continued fraction expansion for e - 2, where e is the base of the natural logarithms.  In this fraction, the n_i are all 1, and the D_i are successively 1, 2, 1, 1, 4, 1, 1, 6, 1, 1, 8, ....  Write a program that uses your ~cont-frac~ procedure from [[#exercise-1.37][Exercise 1.37]] to approximate e, based on Euler's expansion.

#+BEGIN_SRC racket
#lang sicp

(define (cont-frac n d k)
  (define (rec i)
    (if (= k i) (/ (n i) (d i)) (/ (n i) (+ (d i) (rec (+ i 1))))))
  (rec 1))

(+ 2 (cont-frac (lambda (i) 1.0) (lambda (i) (if (= (remainder i 3) 2) (* 2 (+ 1 (floor (/ i 3)))) 1)) 100))
#+END_SRC

#+RESULTS:
: 2.7182818284590455

***** DONE Exercise 1.39
:PROPERTIES:
:CUSTOM_ID: exercise-1.39
:END:

A continued fraction representation of the tangent function was published in 1770 by the German mathematician J.H. Lambert:

#+BEGIN_EXAMPLE
               x
 tan x = ---------------
                 x^2
         1 - -----------
                   x^2
             3 - -------
                 5 - ...
#+END_EXAMPLE

where x is in radians.  Define a procedure ~(tan-cf x k)~ that computes an approximation to the tangent function based on Lambert's formula.  ~k~ specifies the number of terms to compute, as in [[#exercise-1.37][Exercise 1.37]].

#+BEGIN_SRC racket
#lang sicp

(define (cont-frac n d k)
  (define (rec i)
    (if (= k i) (/ (n i) (d i)) (/ (n i) (+ (d i) (rec (+ i 1))))))
  (rec 1))

(define (tan-cf x k)
  (cont-frac (lambda (i) (if (= 1 i) x (- (* x x)))) (lambda (i) (- (* 2 i) 1)) k))

(#%require racket/math)

(tan-cf (/ pi 4) 100)
(tan-cf (/ pi 8) 100)
#+END_SRC

#+RESULTS:
: 1.0
: 0.41421356237309503

**** DONE 1.3.4 Procedures as Returned Values

#+BEGIN_SRC racket :noweb yes
<<sicp>>

(define (average-damp f)
  (lambda (x) (average x (f x))))

((average-damp square) 10)

(define (sqrt x)
  (fixed-point (average-damp (lambda (y) (/ x y))) 1.0))

(sqrt 2)

(define (cube-root x)
  (fixed-point (average-damp (lambda (y) (/ x (square y)))) 1.0))

(cube-root 3)
#+END_SRC

#+RESULTS:
: 55
: 1.414213562373095
: 1.4422495703074083

#+BEGIN_SRC racket :noweb yes
<<sicp>>

(define (deriv g)
  (define dx 0.0000001)
  (lambda (x) (/ (- (g (+ x dx)) (g x)) dx)))

((deriv cube) 5)

(define (newton-transform g)
  (lambda (x) (- x (/ (g x) ((deriv g) x)))))

(define (newtons-method g guess)
  (fixed-point (newton-transform g) guess))

(define (sqrt x)
  (newtons-method (lambda (y) (- (square y) x)) 1))

(sqrt 2)
#+END_SRC

#+RESULTS:
: 75.00000165805432
: 1.414213562373095

#+BEGIN_SRC racket :noweb yes
<<sicp>>

(define (fixed-point-of-transform g transform guess)
  (fixed-point (transform g) guess))

(define (sqrt-1 x)
  (fixed-point-of-transform (lambda (y) (/ x y)) average-damp 1.0))

(define (sqrt-2 x)
  (fixed-point-of-transform (lambda (y) (- (square y) x)) newton-transform 1.0))
#+END_SRC

First class procedures!!!

- may be variables
- may be passed as arguments
- may be returns by procedures
- may be included in data structures

***** DONE Exercise 1.40
:PROPERTIES:
:CUSTOM_ID: exercise-1.40
:END:

Define a procedure ~cubic~ that can be used together with the ~newtons-method~ procedure in expressions of the form

#+BEGIN_SRC scheme
(newtons-method (cubic a b c) 1)
#+END_SRC

to approximate zeros of the cubic x^3 + ax^2 + bx + c.

#+BEGIN_SRC racket :noweb yes
<<sicp>>

(define (cubic a b c)
  (lambda (x) (+ (cube x) (* a (square x)) (* b x) c)))

(newtons-method (cubic 4 2 -1) 1)
#+END_SRC

#+RESULTS:
: 0.3027756377319947

***** DONE Exercise 1.41
:PROPERTIES:
:CUSTOM_ID: exercise-1.41
:END:

Define a procedure ~double~ that takes a procedure of one argument as argument and returns a procedure that applies the original procedure twice.  For example, if ~inc~ is a procedure that adds 1 to its argument, then ~(double inc)~ should be a procedure that adds 2.  What value is returned by

#+BEGIN_SRC scheme
(((double (double double)) inc) 5)
#+END_SRC

#+BEGIN_SRC racket :noweb yes
<<sicp>>

(define (double f)
  (lambda (x) (f (f x))))

(((double (double double)) inc) 5)
#+END_SRC

#+RESULTS:
: 21

The important insight to understanding how ~(double double)~ results in nesting is that as:

#+BEGIN_EXAMPLE
((double f) x)
(f (f x))
#+END_EXAMPLE

then:

#+BEGIN_EXAMPLE
(((double double) f) x)
((double (double f)) x)
#+END_EXAMPLE

and:

#+BEGIN_EXAMPLE
(((double (double double)) inc) 5)
(((double double) ((double double) inc)) 5)
(((double double) (double (double inc))) 5)
(((double (double (double (double inc))))) 5)
#+END_EXAMPLE

***** DONE Exercise 1.42
:PROPERTIES:
:CUSTOM_ID: exercise-1.42
:END:

Let f and g be two one-argument functions.  The <<i72>> composition f after g is defined to be the function x |-> f(g(x)).  Define a procedure ~compose~ that implements composition.  For example, if ~inc~ is a procedure that adds 1 to its argument,

#+BEGIN_SRC scheme
((compose square inc) 6)
49
#+END_SRC

#+BEGIN_SRC racket :noweb yes
<<sicp>>

(define (compose f g)
  (lambda (x) (f (g x))))

((compose square inc) 6)
#+END_SRC

#+RESULTS:
: 49

***** DONE Exercise 1.43
:PROPERTIES:
:CUSTOM_ID: exercise-1.43
:END:

If f is a numerical function and n is a positive integer, then we can form the nth repeated application of f, which is defined to be the function whose value at x is f(f(...(f(x))...)).  For example, if f is the function x |-> x + 1, then the nth repeated application of f is the function x |-> x + n.  If f is the operation of squaring a number, then the nth repeated application of f is the function that raises its argument to the 2^nth power.  Write a procedure that takes as inputs a procedure that computes f and a positive integer n and returns the procedure that computes the nth repeated application of f.  Your procedure should be able to be used as follows:

#+BEGIN_SRC scheme
((repeated square 2) 5)
625
#+END_SRC

Hint: You may find it convenient to use ~compose~ from [[#exercise-1.42][Exercise 1.42]].

#+BEGIN_SRC racket :noweb yes

(define (square x)
  (* x x))

(define (compose f g)
  (lambda (x) (f (g x))))

(define (repeated f n)
  (if (= n 1) f (compose f (repeated f (- n 1)))))

((repeated square 2) 5)
((repeated square 3) 5)
((repeated square 4) 5)
#+END_SRC

#+RESULTS:
: 625
: 390625
: 152587890625

Note that this is not correct:

#+BEGIN_SRC racket :noweb yes
(define (square x)
  (* x x))

(define (compose f g)
  (lambda (x) (f (g x))))

(define (bad-repeated f n)
  (if (= n 1) f (bad-repeated (compose f f) (- n 1))))

((bad-repeated square 2) 5)
((bad-repeated square 3) 5)
((bad-repeated square 4) 5)
#+END_SRC

#+RESULTS:
: 625
: 152587890625
: 86361685550944446253863518628003995711160003644362813850237034701685918031624270579715075034722882265605472939461496635969950989468319466936530037770580747746862471103668212890625

It repeats ~f~ on the order of 2^(2 * (n - 1)) (i.e., it raised 5 to the 4th, 16th and 256th powers).

Note the wording of the problem prompt. So the nth repeated application of ~square~ apparently should result in "the function that raises its argument to the 2^nth power", and the prompt wants ~((repeated square 2) 5)~ to raise 5 to the 2^2th power. So the 1st "repeated application" should just square it? Likewise for the increment function, the 1st "repeated application" should result in x + 1 already instead of x + 2? This is why the check for ~n~ is at 1. The prompt apparently considers the 1st repeated application of ~f~ to just be ~f~.

***** DONE Exercise 1.44
:PROPERTIES:
:CUSTOM_ID: exercise-1.44
:END:

The idea of <<i356>> smoothing a function is an important concept in signal processing.  If f is a function and dx is some small number, then the smoothed version of f is the function whose value at a point x is the average of f(x - dx), f(x), and f(x + dx).  Write a procedure ~smooth~ that takes as input a procedure that computes f and returns a procedure that computes the smoothed f.  It is sometimes valuable to repeatedly smooth a function (that is, smooth the smoothed function, and so on) to obtained the <<i250>> n-fold smoothed function.  Show how to generate the n-fold smoothed function of any given function using ~smooth~ and ~repeated~ from [[#exercise-1.43][Exercise 1.43]].

#+BEGIN_SRC racket :noweb yes
<<sicp>>

(define (compose f g)
  (lambda (x) (f (g x))))

(define (repeated f n)
  (if (= n 1) f (compose f (repeated f (- n 1)))))

(define (smooth f)
  (let ([dx 0.1]) (lambda (x) (/ (+ (f (- x dx)) (f x) (f (+ x dx))) 3))))

(sin 0.1)

((smooth sin) 0.1)

(define (repeated-smooth n f)
  (repeated smooth n)
  f)

((repeated-smooth 5 sin) 0.1)
#+END_SRC

#+RESULTS:
: 0.09983341664682815
: 0.09950091581396313
: 0.09983341664682815

Note that if you instead do this for ~repeated-smooth~:

#+begin_example
(define (repeated-smooth n f)
  (repeated (smooth f) n))
#+end_example

This is wrong because ~smooth~ is going to do nested ~(smooth (f (smooth (f ...))))~ instead of the desired behavior of ~(smooth (smooth ... (smooth (f))))~.

***** DONE Exercise 1.45
:PROPERTIES:
:CUSTOM_ID: exercise-1.45
:END:

We saw in section [[#section-1.3.3][1.3.3]] that attempting to compute square roots by naively finding a fixed point of y |-> x/y does not converge, and that this can be fixed by average damping.  The same method works for finding cube roots as fixed points of the average-damped y |-> x/y^2.  Unfortunately, the process does not work for fourth roots--a single average damp is not enough to make a fixed-point search for y |-> x/y^3 converge.  On the other hand, if we average damp twice (i.e., use the average damp of the average damp of y |-> x/y^3) the fixed-point search does converge.  Do some experiments to determine how many average damps are required to compute nth roots as a fixed-point search based upon repeated average damping of y |-> x/y^(n-1).  Use this to implement a simple procedure for computing nth roots using ~fixed-point~, ~average-damp~, and the ~repeated~ procedure of [[#exercise-1.43][Exercise 1.43]].  Assume that any arithmetic operations you need are available as primitives.

#+BEGIN_SRC racket :noweb yes
<<sicp>>

(define (find-nth-root n x k)
  (fixed-point ((repeated average-damp k) (lambda (y) (/ x (expt y (- n 1))))) 1.0))

(find-nth-root 2 3 0)
(find-nth-root 3 3 1)
(find-nth-root 4 3 2)
(find-nth-root 5 3 2)
(find-nth-root 6 3 2)
(find-nth-root 7 3 2)
(find-nth-root 8 3 3)
(find-nth-root 15 3 4)
(find-nth-root 16 3 4)
(find-nth-root 17 3 4)
(find-nth-root 31 3 5)
(find-nth-root 32 3 5)
(find-nth-root 63 3 6)
(find-nth-root 64 3 6)
#+END_SRC

#+RESULTS:
#+begin_example
1.7320508075688772
1.4422495703074083
1.3160740129524924
1.2457309396155174
1.200936955176003
1.1699308127586865
1.1472026904398769
1.075989624725346
1.0710754830729146
1.0667581171328453
1.0360745555722937
1.0349277670798647
1.0175912249602233
1.0173139963058921
#+end_example

The pattern seems fairly reliable by this point:

#+BEGIN_SRC racket :noweb yes
<<sicp>>

(define (find-nth-root n x)
  (fixed-point ((repeated average-damp (log (+ n 1) 2)) (lambda (y) (/ x (expt y (- n 1))))) 1.0))

(find-nth-root 2 3)
(find-nth-root 3 3)
(find-nth-root 4 3)
(find-nth-root 5 3)
(find-nth-root 6 3)
(find-nth-root 7 3)
(find-nth-root 8 3)
(find-nth-root 15 3)
(find-nth-root 16 3)
(find-nth-root 17 3)
(find-nth-root 31 3)
(find-nth-root 32 3)
(find-nth-root 63 3)
(find-nth-root 64 3)
#+END_SRC

#+RESULTS:
#+begin_example
1.7320508075688765
1.4422495703074087
1.3160740129524915
1.2457309396155174
1.200936955176003
1.169930812758687
1.147202690439876
1.075989624725346
1.0710754830729137
1.0667581171328446
1.0360745555722937
1.0349277670798638
1.0175912249602233
1.0173139963058915
#+end_example

***** DONE Exercise 1.46
:PROPERTIES:
:CUSTOM_ID: exercise-1.46
:END:

Several of the numerical methods described in this chapter are instances of an extremely general computational strategy known as <<i198>> iterative improvement.  Iterative improvement says that, to compute something, we start with an initial guess for the answer, test if the guess is good enough, and otherwise improve the guess and continue the process using the improved guess as the new guess.  Write a procedure ~iterative-improve~ that takes two procedures as arguments: a method for telling whether a guess is good enough and a method for improving a guess.  ~iterative-improve~ should return as its value a procedure that takes a guess as argument and keeps improving the guess until it is good enough.  Rewrite the ~sqrt~ procedure of section [[#section-1.1.7][1.1.7]] and the ~fixed-point~ procedure of section [[#section-1.3.3][1.3.3]] in terms of ~iterative-improve~.

#+BEGIN_SRC racket :noweb yes
<<sicp>>

(define (iterative-improve good-enough? improve)
  (define (try guess)
    (let ([next (improve guess)]) (if (good-enough? guess) guess (try next))))
  try)

(define tolerance 0.000000000000001)
(define (close-enough? a b)
  (< (abs (- a b)) tolerance))

(define (sqrt x)
  ((iterative-improve (lambda (guess) (close-enough? x (square guess))) (lambda (guess) (average guess (/ x guess)))) 1.0))

(define (fixed-point f first-guess)
  ((iterative-improve (lambda (x) (close-enough? x (f x))) f) first-guess))

(sqrt 2.0)
(fixed-point cos 1.0)
#+END_SRC

#+RESULTS:
: 1.414213562373095
: 0.7390851332151611

** DONE 2 Building Abstractions with Data
*** DONE 2.1 Introduction to Data Abstraction
**** DONE 2.1.1 Example: Arithmetic Operations for Rational Numbers

#+BEGIN_SRC racket :noweb yes
<<sicp>>

(define x (cons 1 2))

(car x)

(cdr x)
#+END_SRC

#+RESULTS:
: 1
: 2

#+BEGIN_SRC racket :noweb yes
<<sicp>>

(define x (cons 1 2))
(define y (cons 3 4))
(define z (cons x y))

(car (car z))

(car (cdr z))
#+END_SRC

#+RESULTS:
: 1
: 3

#+BEGIN_SRC racket :noweb yes
<<sicp>>

(define (make-rat n d)
  (let ([g (gcd n d)]) (cons (/ n g) (/ d g))))
(define (numer x)
  (car x))
(define (denom x)
  (cdr x))

;; (define make-rat cons)
;; (define number car)
;; (define denom cdr)

;; essentially function aliases
;; clever and saves a call
;; but might make debugging hard

(define (add-rat x y)
  (make-rat (+ (* (numer x) (denom y)) (* (numer y) (denom x))) (* (denom x) (denom y))))

(define (sub-rat x y)
  (make-rat (- (* (numer x) (denom y)) (* (numer y) (denom x))) (* (denom x) (denom y))))

(define (mul-rat x y)
  (make-rat (* (numer x) (numer y)) (* (denom x) (denom y))))

(define (div-rat x y)
  (make-rat (* (numer x) (denom y)) (* (denom x) (numer y))))

(define (equal-rat? x y)
  (= (* (numer x) (denom y)) (* (numer y) (denom x))))

(define (print-rat x)
  (newline)
  (display (numer x))
  (display "/")
  (display (denom x)))

(define one-half (make-rat 1 2))

(define one-third (make-rat 1 3))

(print-rat one-half)

(print-rat (add-rat one-half one-third))

(print-rat (mul-rat one-half one-third))

(print-rat (add-rat one-third one-third))
#+END_SRC

#+RESULTS:
: 
: 1/2
: 5/6
: 1/6
: 2/3

***** DONE Exercise 2.1
:PROPERTIES:
:CUSTOM_ID: exercise-2.1
:END:

Define a better version of ~make-rat~ that handles both positive and negative arguments.  ~make-rat~ should normalize the sign so that if the rational number is positive, both the numerator and denominator are positive, and if the rational number is negative, only the numerator is negative.

#+BEGIN_SRC racket :noweb yes
<<sicp>>

(define (make-rat n d)
  (let ([g (abs (gcd n d))])
    (cond
      [(< d 0) (cons (- (/ n g)) (- (/ d g)))]
      [else (cons (/ n g) (/ d g))])))

(define (numer x)
  (car x))
(define (denom x)
  (cdr x))

(define (print-rat x)
  (newline)
  (display (numer x))
  (display "/")
  (display (denom x)))

(print-rat (make-rat -6 -9))
(print-rat (make-rat 6 -9))
(print-rat (make-rat -6 9))
(print-rat (make-rat 6 9))
#+END_SRC

#+RESULTS:
: 
: 2/3
: -2/3
: -2/3
: 2/3

**** DONE 2.1.2 Abstraction Barriers

<<figure-2.1>> Data-abstraction barriers in the rational-number package.

#+BEGIN_EXAMPLE
         +------------------------------------+
 --------| Programs that use rational numbers |--------
         +------------------------------------+
           Rational numbers in promblem domain
             +---------------------------+
 ------------|   add-rat  sub-rat  ...   |-------------
             +---------------------------+
    Rational numbers as numerators and denominators
               +------------------------+
 --------------| make-rat  numer  denom |--------------
               +------------------------+
               Rational numbers as pairs
                   +----------------+
 ------------------| cons  car  cdr |------------------
                   +----------------+
             However pairs are implemented
#+END_EXAMPLE

***** DONE Exercise 2.2
:PROPERTIES:
:CUSTOM_ID: exercise-2.2
:END:

Consider the problem of representing line segments in a plane.  Each segment is represented as a pair of points: a starting point and an ending point.  Define a constructor ~make-segment~ and selectors ~start-segment~ and ~end-segment~ that define the representation of segments in terms of points.  Furthermore, a point can be represented as a pair of numbers: the x coordinate and the y coordinate.  Accordingly, specify a constructor ~make-point~ and selectors ~x-point~ and ~y-point~ that define this representation.  Finally, using your selectors and constructors, define a procedure ~midpoint-segment~ that takes a line segment as argument and returns its midpoint (the point whose coordinates are the average of the coordinates of the endpoints).  To try your procedures, you'll need a way to print points:

#+BEGIN_SRC scheme
(define (print-point p)
  (newline)
  (display "(")
  (display (x-point p))
  (display ",")
  (display (y-point p))
  (display ")"))
#+END_SRC

#+BEGIN_SRC racket :noweb yes
<<sicp>>

(define (make-segment a b)
  (cons a b))

(define (start-segment s)
  (car s))

(define (end-segment s)
  (cdr s))

(define (make-point x y)
  (cons x y))

(define (x-point p)
  (car p))

(define (y-point p)
  (cdr p))

(define (midpoint-segment s)
  (make-point (average (x-point (start-segment s)) (x-point (end-segment s)))
              (average (y-point (start-segment s)) (y-point (end-segment s)))))

(define (print-point p)
  (newline)
  (display "(")
  (display (x-point p))
  (display ",")
  (display (y-point p))
  (display ")"))

(print-point (midpoint-segment (make-segment (make-point 0 0) (make-point 3 4))))
#+END_SRC

#+RESULTS:
: 
: (3/2,2)

***** DONE Exercise 2.3
:PROPERTIES:
:CUSTOM_ID: exercise-2.3
:END:

Implement a representation for rectangles in a plane.  (Hint: You may want to make use of [[#exercise-2.2][Exercise 2.2]].)  In terms of your constructors and selectors, create procedures that compute the perimeter and the area of a given rectangle.  Now implement a different representation for rectangles.  Can you design your system with suitable abstraction barriers, so that the same perimeter and area procedures will work using either representation?

This implementation is not allowing rotated rectangles, but tbh I got bored.

#+BEGIN_SRC racket :noweb yes
<<sicp>>

(define (point x y)
  (cons x y))

(define (x p)
  (car p))

(define (y p)
  (cdr p))

;; (define (rectangle p1 p2)
;;   (cons p1 p2))

(define (rectangle p l w)
  (cons p (point (+ (x p) l) (+ (y p) w))))

(define (length rect)
  (abs (- (x (car rect)) (x (cdr rect)))))

(define (width rect)
  (abs (- (y (car rect)) (y (cdr rect)))))

(define (perimeter rect)
  (* 2 (+ (length rect) (width rect))))

(define (area rect)
  (* (length rect) (width rect)))

;; (define (test) (rectangle (point 0 0) (point 3 4)))
(define (test) (rectangle (point 0 0) 3 4))

(perimeter (test))

(area (test))
#+END_SRC

#+RESULTS:
: 14
: 12

**** DONE 2.1.3 What Is Meant by Data?

#+BEGIN_SRC racket :noweb yes
<<sicp>>

(define (cons x y)
  (define (dispatch m)
    (cond
      [(= m 0) x]
      [(= m 1) y]
      [else (error "Argument not 0 or 1: CONS" m)]))
  dispatch)

(define (car z)
  (z 0))
(define (cdr z)
  (z 1))

(car (cons 0 1))
#+END_SRC

#+RESULTS:
: 0

Note that ~cons~ returns the procedure ~dispatch~.

It could work this way despite primitives are implemented.

Procedural representation of data; /message passing/

***** DONE Exercise 2.4
:PROPERTIES:
:CUSTOM_ID: exercise-2.4
:END:

Here is an alternative procedural representation of pairs.  For this representation, verify that ~(car (cons x y))~ yields ~x~ for any objects ~x~ and ~y~.

#+BEGIN_SRC scheme
(define (cons x y)
  (lambda (m) (m x y)))

(define (car z)
  (z (lambda (p q) p)))
#+END_SRC

What is the corresponding definition of ~cdr~?  (Hint: To verify that this works, make use of the substitution model of section [[#section-1.1.5][1.1.5]].)

#+BEGIN_SRC racket :noweb yes
<<sicp>>

(define (cons x y)
  (lambda (m) (m x y)))

(define (car z)
  (z (lambda (p q) p)))

(define (cdr z)
  (z (lambda (p q) q)))

(car (cons 0 1))

(cdr (cons 0 1))
#+END_SRC

#+RESULTS:
: 0
: 1

Substitution process:

#+begin_example
(car (cons 0 1))
(car (lambda (m) (m 0 1)))
((lambda (m) (m 0 1)) (lambda (p q) p))
((lambda (p q) p) 0 1)
0
#+end_example

***** DONE Exercise 2.5
:PROPERTIES:
:CUSTOM_ID: exercise-2.5
:END:

Show that we can represent pairs of nonnegative integers using only numbers and arithmetic operations if we represent the pair a and b as the integer that is the product 2^a 3^b.  Give the corresponding definitions of the procedures ~cons~, ~car~, and ~cdr~.

#+BEGIN_SRC racket :noweb yes
<<sicp>>
(#%require racket/math)

(define (cons a b)
  (* (expt 2 a) (expt 3 b)))

(define (car z)
  (if (= 0 (remainder z 3))
      (car (/ z 3))
      (exact-round (log z 2))))

(define (cdr z)
  (if (even? z)
      (cdr (/ z 2))
      (exact-round (log z 3))))

(cons 42 7)

(car (cons 42 7))

(cdr (cons 42 7))
#+END_SRC

#+RESULTS:
: 9618527719784448
: 42
: 7

***** DONE Exercise 2.6
:PROPERTIES:
:CUSTOM_ID: exercise-2.6
:END:

In case representing pairs as procedures wasn't mind-boggling enough, consider that, in a language that can manipulate procedures, we can get by without numbers (at least insofar as nonnegative integers are concerned) by implementing 0 and the operation of adding 1 as

#+BEGIN_SRC scheme
(define zero (lambda (f) (lambda (x) x)))

(define (add-1 n)
  (lambda (f) (lambda (x) (f ((n f) x)))))
#+END_SRC

This representation is known as <<i58>> Church numerals, after its inventor, Alonzo Church, the logician who invented the [lambda] calculus.

Define ~one~ and ~two~ directly (not in terms of ~zero~ and ~add-1~).  (Hint: Use substitution to evaluate ~(add-1 zero)~).  Give a direct definition of the addition procedure ~+~ (not in terms of repeated application of ~add-1~).

#+BEGIN_SRC racket :noweb yes
<<sicp>>

(define zero (lambda (f) (lambda (x) x)))

(define (add-1 n)
  (lambda (f) (lambda (x) (f ((n f) x)))))

((zero inc) 0)
(((add-1 zero) inc) 0)
#+END_SRC

#+RESULTS:
: 0
: 1

#+begin_example
(add-1 zero)
;; zero is a function that returns a function that takes one argument and returns the identity function
(lambda (f) (lambda (x) (f ((zero f) x))))
;; ((zero f) x) just returns x
(lambda (f) (lambda (x) (f x)))
#+end_example

So ~one~ is ~(lambda (f) (lambda (x) (f x)))~, a function that takes one argument ~f~ and returns a function that takes one argument ~x~ to do ~(f x)~

#+begin_example
(add-1 one)
(lambda (f) (lambda (x) (f (((lambda (f) (lambda (x) (f x))) f) x))))
;; (((lambda (f) (lambda (x) (f x))) f) x) returns (f x)
(lambda (f) (lambda (x) (f (f x))))
#+end_example

So ~two~ is ~(lambda (f) (lambda (x)  (f (f x))))~

Now by induction (or maybe not, just applying the pattern we have here), we want to repeated apply ~f~.

So how do we write ~+~. Well I guess baby steps. Firstly Church numerals are functions that return functions (the nested lambda form here; both of which take a single argument). So the ad procedure should also return a nested lambda that takes a single argument.

Continuing with how we played with the Church numerals above, I suppose we would want ~(((+ a b) inc) 0)~ to apply ~inc~ (on 0) a + b times. Actually, more generally for ~(((+ a b) f) x)~, we want ~f~ to be applied a + b times, with x as the initial input.

Moreover, actually sit back a bit and think again about that both ~a~ and ~b~ are Church numerals. This means going back to how we played with them, ~((a f) x)~ will apply ~f~ a times with ~x~ as the initial input. We are running in circles because this is exactly how ~two~ worked. But maybe the idea is going to be to put two and two together

#+BEGIN_SRC racket :noweb yes
<<sicp>>

(define (+ a b)
  (lambda (f) (lambda (x) ((a f) ((b f) x)))))
#+END_SRC

So this just applies ~f~ for ~b~ times on ~x~, then applies ~f~ for ~a~ times on the whole thing.

#+BEGIN_SRC racket :noweb yes
<<sicp>>

(define zero (lambda (f) (lambda (x) x)))

(define one (lambda (f) (lambda (x) (f x))))

(define two (lambda (f) (lambda (x) (f (f x)))))

(define (+ a b)
  (lambda (f) (lambda (x) ((a f) ((b f) x)))))

(((+ one two) inc) 0)
#+END_SRC

#+RESULTS:
: 3

**** DONE 2.1.4 Extended Exercise: Interval Arithmetic
***** DONE Exercise 2.7
:PROPERTIES:
:CUSTOM_ID: exercise-2.7
:END:

Alyssa's program is incomplete because she has not specified the implementation of the interval abstraction.  Here is a definition of the interval constructor:

#+BEGIN_SRC scheme
(define (make-interval a b) (cons a b))
#+END_SRC

Define selectors ~upper-bound~ and ~lower-bound~ to complete the implementation.

#+BEGIN_SRC racket :noweb yes
<<sicp>>

(define (make-interval a b)
  (cons a b))

(define (add-interval x y)
  (make-interval (+ (lower-bound x) (lower-bound y)) (+ (upper-bound x) (upper-bound y))))

(define (mul-interval x y)
  (let ([p1 (* (lower-bound x) (lower-bound y))]
        [p2 (* (lower-bound x) (upper-bound y))]
        [p3 (* (upper-bound x) (lower-bound y))]
        [p4 (* (upper-bound x) (upper-bound y))])
    (make-interval (min p1 p2 p3 p4) (max p1 p2 p3 p4))))

(define (div-interval x y)
  (mul-interval x (make-interval (/ 1.0 (upper-bound y)) (/ 1.0 (lower-bound y)))))

(define (lower-bound interval)
  (car interval))

(define (upper-bound interval)
  (cdr interval))

(lower-bound (mul-interval (make-interval 0.9 1.1) (make-interval 2.4 3.2)))
(upper-bound (mul-interval (make-interval 0.9 1.1) (make-interval 2.4 3.2)))
#+END_SRC

#+RESULTS:
: 2.16
: 3.5200000000000005

***** DONE Exercise 2.8
:PROPERTIES:
:CUSTOM_ID: exercise-2.8
:END:

Using reasoning analogous to Alyssa's, describe how the difference of two intervals may be computed.  Define a corresponding subtraction procedure, called ~sub-interval~.

#+BEGIN_SRC racket :noweb yes
<<sicp>>

(define (make-interval a b)
  (cons a b))

(define (add-interval x y)
  (make-interval (+ (lower-bound x) (lower-bound y)) (+ (upper-bound x) (upper-bound y))))

(define (sub-interval x y)
  (make-interval (- (lower-bound x) (upper-bound y)) (- (upper-bound x) (lower-bound y))))

(define (mul-interval x y)
  (let ([p1 (* (lower-bound x) (lower-bound y))]
        [p2 (* (lower-bound x) (upper-bound y))]
        [p3 (* (upper-bound x) (lower-bound y))]
        [p4 (* (upper-bound x) (upper-bound y))])
    (make-interval (min p1 p2 p3 p4) (max p1 p2 p3 p4))))

(define (div-interval x y)
  (mul-interval x (make-interval (/ 1.0 (upper-bound y)) (/ 1.0 (lower-bound y)))))

(define (lower-bound interval)
  (min (car interval) (cdr interval)))

(define (upper-bound interval)
  (max (car interval) (cdr interval)))


(sub-interval (make-interval 7 9) (make-interval 2 3))

(mul-interval (make-interval -1 5) (make-interval -1 5))
#+END_SRC

#+RESULTS:
: (4 . 7)
: (-5 . 25)

***** DONE Exercise 2.9
:PROPERTIES:
:CUSTOM_ID: exercise-2.9
:END:

The <<i423>> width of an interval is half of the difference between its upper and lower bounds.  The width is a measure of the uncertainty of the number specified by the interval.  For some arithmetic operations the width of the result of combining two intervals is a function only of the widths of the argument intervals, whereas for others the width of the combination is not a function of the widths of the argument intervals.  Show that the width of the sum (or difference) of two intervals is a function only of the widths of the intervals being added (or subtracted).  Give examples to show that this is not true for multiplication or division.

So let intervals \(x, y\) be \((l_x, u_x), (l_y, u_y)\). Their respective widths \(w_x, w_y\) are \(\frac{u_x - l_x}{2}\) and \(\frac{u_y - l_y}{2}\). For addition, \(x + y = (l_x + l_y, u_x + u_y)\), whose width is \(\frac{u_x + u_y - l_x - l_y}{2} = w_x + w_y\). As the prompt hinted at, subtraction can also be defined as \(x - y = x + (- u_y, - l_y)\) and thus the property also applies.

Multiplication (and division that is defined in terms of it) seems like it's going to be different because ~mul-interval~ does a permutation of multiples of upper and lower bounds of x and y and selects the maxes and mins. To prove that the result is not a /function of the width of the two arguments/, we aim to show that certain properties of functions do not hold. Let's try that same input always yields same output:

Let's just make two intervals, and actually have one that spans 0 just because I think it can mess with things. Let \(m_1, n_1\) be (4, 10), (-2, 4), such that they both have width 3. Multiplying m_1 and n_1 results in (-20, 40) and the width is 30.

Let m_2, n_2 both be (0, 6) so the widths are both still 3. Multiplying them and wouldn't you have guessed, the result is (0, 36) and the width is only 18. There is no function.

***** DONE Exercise 2.10
:PROPERTIES:
:CUSTOM_ID: exercise-2.10
:END:

Ben Bitdiddle, an expert systems programmer, looks over Alyssa's shoulder and comments that it is not clear what it means to divide by an interval that spans zero.  Modify Alyssa's code to check for this condition and to signal an error if it occurs.

#+BEGIN_SRC racket :noweb yes
<<sicp>>

(define (make-interval a b)
  (cons a b))

(define (add-interval x y)
  (make-interval (+ (lower-bound x) (lower-bound y)) (+ (upper-bound x) (upper-bound y))))

(define (sub-interval x y)
  (make-interval (- (lower-bound x) (upper-bound y)) (- (upper-bound x) (lower-bound y))))

(define (mul-interval x y)
  (let ([p1 (* (lower-bound x) (lower-bound y))]
        [p2 (* (lower-bound x) (upper-bound y))]
        [p3 (* (upper-bound x) (lower-bound y))]
        [p4 (* (upper-bound x) (upper-bound y))])
    (make-interval (min p1 p2 p3 p4) (max p1 p2 p3 p4))))

(define (div-interval x y)
  (if (< 0 (* (lower-bound y) (upper-bound y)))
      (error "Error: division by interval spanning zero\n")
      (mul-interval x (make-interval (/ 1.0 (upper-bound y)) (/ 1.0 (lower-bound y))))))

(define (lower-bound interval)
  (min (car interval) (cdr interval))
  )

(define (upper-bound interval)
  (max (car interval) (cdr interval)))

(div-interval (make-interval 2 4) (make-interval 2 2))
#+END_SRC

#+RESULTS:
: Error: Division by interval spanning zero
: 
:   context...:
:    body of "/var/folders/31/xkn6lwrs7_382lqhy5f9wzbc0000gn/T/ob-racket-PYVulF/ob-racket1EH0tX.rkt"

***** DONE Exercise 2.11
:PROPERTIES:
:CUSTOM_ID: exercise-2.11
:END:

In passing, Ben also cryptically comments: "By testing the signs of the endpoints of the intervals, it is possible to break ~mul-interval~ into nine cases, only one of which requires more than two multiplications."  Rewrite this procedure using Ben's suggestion.

Answer:

So let's think about this. The signs for each of the endpoints of each interval can be either positive or negative. So there are 2^4 possibilities in that sense.

#+begin_example
(pos, pos), (pos, pos)
(pos, pos), (pos, neg)
(pos, pos), (neg, pos)
(pos, pos), (neg, neg)
(pos, neg), (pos, pos)
(pos, neg), (pos, neg)
(pos, neg), (neg, pos)
(pos, neg), (neg, neg)
(neg, pos), (pos, pos)
(neg, pos), (pos, neg)
(neg, pos), (neg, pos)
(neg, pos), (neg, neg)
(neg, neg), (pos, pos)
(neg, neg), (pos, neg)
(neg, neg), (neg, pos)
(neg, neg), (neg, neg)
#+end_example

Let's define the second entry as the upper-bound (essentially remove duplicates) and we are down to 9 cases:

#+begin_example
(pos, pos), (pos, pos)
(pos, pos), (neg, pos)
(pos, pos), (neg, neg)
(neg, pos), (pos, pos)
(neg, pos), (neg, pos)
(neg, pos), (neg, neg)
(neg, neg), (pos, pos)
(neg, neg), (neg, pos)
(neg, neg), (neg, neg)
#+end_example

For each case, let's see if it's possible to determine the smallest and largest multiples without the need to actually calculate.

#+begin_example
(pos, pos), (pos, pos)
yes
xl * yl, xu * yu
(pos, pos), (neg, pos)
yes
xu * yl, xu * yu
(pos, pos), (neg, neg)
yes
xu * yl, xl * yu
(neg, pos), (pos, pos)
yes
xl * yu, xu * yu
(neg, pos), (neg, pos)
no
(neg, pos), (neg, neg)
yes
xu * yl, xl * yl
(neg, neg), (pos, pos)
yes
xl * yu, xu * yl
(neg, neg), (neg, pos)
yes
xl * yu, xl * yl
(neg, neg), (neg, neg)
yes
xu * yu, xl * yl
#+end_example

so we are able to contruct the most negative and most positive multiples. Except for the case of ~(neg, pos), (neg, pos)~, where you don't know if the multiples of the two negative values or of the two positive values is larger, thus you need 3 multiplications.

Now actually, the endpoints can also be 0. This case turns out to not be a huge problem, as remember the 2nd entry of an interval (upper-bound) >= 1st entry (lower-bound). If 0 is the upper bound, the lower bound must be 0 or negative; if 0 is the lower bound, the upper bound must be 0 or positive; turns out it is safe to treat 0 as positive.

I guess we can just hard code this in. Maybe a table is better, but we aren't there yet:

#+BEGIN_SRC racket :noweb yes
<<sicp>>

(define (make-interval a b)
  (cons a b))

(define (add-interval x y)
  (make-interval (+ (lower-bound x) (lower-bound y)) (+ (upper-bound x) (upper-bound y))))

(define (sub-interval x y)
  (make-interval (- (lower-bound x) (upper-bound y)) (- (upper-bound x) (lower-bound y))))

(define (mul-interval x y)
  (let ([xl (lower-bound x)]
        [xu (upper-bound x)]
        [yl (lower-bound y)]
        [yu (upper-bound y)]
        [pos? (lambda (x) (>= x 0))]
        [neg? (lambda (x) (< x 0))])
    (cond
      [(and (pos? xl) (pos? xu) (pos? yl) (pos? yu)) (make-interval (* xl yl) (* xu yu))]
      [(and (pos? xl) (pos? xu) (neg? yl) (pos? yu)) (make-interval (* xu yl) (* xu yu))]
      [(and (pos? xl) (pos? xu) (neg? yl) (neg? yu)) (make-interval (* xu yl) (* xl yu))]
      [(and (neg? xl) (pos? xu) (pos? yl) (pos? yu)) (make-interval (* xl yu) (* xu yu))]
      [(and (neg? xl) (pos? xu) (neg? yl) (neg? yu)) (make-interval (* xu yl) (* xl yl))]
      [(and (neg? xl) (neg? xu) (pos? yl) (pos? yu)) (make-interval (* xl yu) (* xu yl))]
      [(and (neg? xl) (neg? xu) (neg? yl) (pos? yu)) (make-interval (* xl yu) (* xl yl))]
      [(and (neg? xl) (neg? xu) (neg? yl) (neg? yu)) (make-interval (* xu yu) (* xl yl))]
      [(and (neg? xl) (pos? xu) (neg? yl) (pos? yu))
       (make-interval (* xl yu) (* (max (* xl yl) (* xu yu))))])))

(define (div-interval x y)
  (if (< 0 (* (lower-bound y) (upper-bound y)))
      (error "Error: division by interval spanning zero\n")
      (mul-interval x (make-interval (/ 1.0 (upper-bound y)) (/ 1.0 (lower-bound y))))))

(define (lower-bound interval)
  (min (car interval) (cdr interval)))

(define (upper-bound interval)
  (max (car interval) (cdr interval)))

(mul-interval (make-interval -1 5) (make-interval -1 5))
#+END_SRC

#+RESULTS:
: (-5 . 25)

There you have it. Optimized but hard to read or debug. Tbh I want to stick with the original version.

After debugging her program, Alyssa shows it to a potential user, who complains that her program solves the wrong problem.  He wants a program that can deal with numbers represented as a center value and an additive tolerance; for example, he wants to work with intervals such as 3.5 +/- 0.15 rather than [3.35, 3.65].  Alyssa returns to her desk and fixes this problem by supplying an alternate constructor and alternate selectors:

#+BEGIN_SRC scheme
(define (make-center-width c w)
  (make-interval (- c w) (+ c w)))

(define (center i)
  (/ (+ (lower-bound i) (upper-bound i)) 2))

(define (width i)
  (/ (- (upper-bound i) (lower-bound i)) 2))
#+END_SRC

Unfortunately, most of Alyssa's users are engineers.  Real engineering situations usually involve measurements with only a small uncertainty, measured as the ratio of the width of the interval to the midpoint of the interval.  Engineers usually specify percentage tolerances on the parameters of devices, as in the resistor specifications given earlier.

***** DONE Exercise 2.12
:PROPERTIES:
:CUSTOM_ID: exercise-2.12
:END:

Define a constructor ~make-center-percent~ that takes a center and a percentage tolerance and produces the desired interval.  You must also define a selector ~percent~ that produces the percentage tolerance for a given interval.  The ~center~ selector is the same as the one shown above.

#+BEGIN_SRC racket :noweb yes
<<sicp>>

(define (make-interval a b)
  (cons a b))

(define (add-interval x y)
  (make-interval (+ (lower-bound x) (lower-bound y)) (+ (upper-bound x) (upper-bound y))))

(define (sub-interval x y)
  (make-interval (- (lower-bound x) (upper-bound y)) (- (upper-bound x) (lower-bound y))))

(define (mul-interval x y)
  (let ([p1 (* (lower-bound x) (lower-bound y))]
        [p2 (* (lower-bound x) (upper-bound y))]
        [p3 (* (upper-bound x) (lower-bound y))]
        [p4 (* (upper-bound x) (upper-bound y))])
    (make-interval (min p1 p2 p3 p4) (max p1 p2 p3 p4))))

(define (div-interval x y)
  (if (< 0 (* (lower-bound y) (upper-bound y)))
      (error "Error: division by interval spanning zero\n")
      (mul-interval x (make-interval (/ 1.0 (upper-bound y)) (/ 1.0 (lower-bound y))))))

(define (lower-bound interval)
  (min (car interval) (cdr interval)))

(define (upper-bound interval)
  (max (car interval) (cdr interval)))

(define (make-center-width c w)
  (make-interval (- c w) (+ c w)))

(define (make-center-percent c p)
  (make-interval (* c (- 1 (/ p 2))) (* c (+ 1 (/ p 2)))))

(define (center i)
  (/ (+ (lower-bound i) (upper-bound i)) 2))

(define (width i)
  (/ (- (upper-bound i) (lower-bound i)) 2))

(define (percent i)
  (/ (- (upper-bound i) (lower-bound i)) (center i)))

(define x (make-center-percent 3.5 0.15))
x
(center x)
(percent x)
(width x)
#+END_SRC

#+RESULTS:
: (3.2375000000000003 . 3.7624999999999997)
: 3.5
: 0.14999999999999986
: 0.26249999999999973

***** DONE Exercise 2.13
:PROPERTIES:
:CUSTOM_ID: exercise-2.13
:END:

Show that under the assumption of small percentage tolerances there is a simple formula for the approximate percentage tolerance of the product of two intervals in terms of the tolerances of the factors.  You may simplify the problem by assuming that all numbers are positive.

Answer:

So let's indeed assume that there are two intervals x and y where are numbers are positive. Suppose the centers are respectively C_x and C_y, and the tolerances T_x and T_y. The two intervals are:

\((C_x \cdot (1 - \frac{T_x}{2}), C_x \cdot (1 + \frac{T_x}{2}))\)
\((C_y \cdot (1 - \frac{T_y}{2}), C_y \cdot (1 + \frac{T_y}{2}))\)

after multiplying them, you get

\((C_x C_y \cdot (1 - \frac{T_x}{2} - \frac{T_y}{2} + \frac{T_x T_y}{4})), (C_x C_y \cdot (1 + \frac{T_x}{2} + \frac{T_y}{2} + \frac{T_x T_y}{4}))\)

as the intervals are small, we can discard the term \(\frac{T_x T_y}{4}\) and consider the tolerance of the product to be approximately the sum of the tolerance of the factors.

After considerable work, Alyssa P. Hacker delivers her finished system.  Several years later, after she has forgotten all about it, she gets a frenzied call from an irate user, Lem E. Tweakit.  It seems that Lem has noticed that the formula for parallel resistors can be written in two algebraically equivalent ways:

#+BEGIN_EXAMPLE
  R_1 R_2
 ---------
 R_1 + R_2
#+END_EXAMPLE

and

#+BEGIN_EXAMPLE
       1
 -------------
 1/R_1 + 1/R_2
#+END_EXAMPLE

He has written the following two programs, each of which computes the parallel-resistors formula differently:

#+BEGIN_SRC scheme
(define (par1 r1 r2)
  (div-interval (mul-interval r1 r2)
                (add-interval r1 r2)))

(define (par2 r1 r2)
  (let ((one (make-interval 1 1)))
    (div-interval one
                  (add-interval (div-interval one r1)
                                (div-interval one r2)))))
#+END_SRC

Lem complains that Alyssa's program gives different answers for the two ways of computing.  This is a serious complaint.

***** DONE Exercise 2.14
:PROPERTIES:
:CUSTOM_ID: exercise-2.14
:END:

Demonstrate that Lem is right.  Investigate the behavior of the system on a variety of arithmetic expressions.  Make some intervals A and B, and use them in computing the expressions A/A and A/B. You will get the most insight by using intervals whose width is a small percentage of the center value.  Examine the results of the computation in center-percent form (see [[#exercise-2.12][Exercise 2.12]]).

#+BEGIN_SRC racket :noweb yes
<<sicp>>

(define (make-interval a b)
  (cons a b))

(define (add-interval x y)
  (make-interval (+ (lower-bound x) (lower-bound y)) (+ (upper-bound x) (upper-bound y))))

(define (sub-interval x y)
  (make-interval (- (lower-bound x) (upper-bound y)) (- (upper-bound x) (lower-bound y))))

(define (mul-interval x y)
  (let ([p1 (* (lower-bound x) (lower-bound y))]
        [p2 (* (lower-bound x) (upper-bound y))]
        [p3 (* (upper-bound x) (lower-bound y))]
        [p4 (* (upper-bound x) (upper-bound y))])
    (make-interval (min p1 p2 p3 p4) (max p1 p2 p3 p4))))

(define (div-interval x y)
  (if (and (< 0 (lower-bound y)) (>= 0 (upper-bound y)))
      (error "Error: division by interval spanning zero" y)
      (mul-interval x (make-interval (/ 1.0 (upper-bound y)) (/ 1.0 (lower-bound y))))))

(define (lower-bound interval)
  (min (car interval) (cdr interval)))

(define (upper-bound interval)
  (max (car interval) (cdr interval)))

(define (make-center-width c w)
  (make-interval (- c w) (+ c w)))

(define (make-center-percent c p)
  (make-interval (* c (- 1 (/ p 2))) (* c (+ 1 (/ p 2)))))

(define (center i)
  (/ (+ (lower-bound i) (upper-bound i)) 2))

(define (width i)
  (/ (- (upper-bound i) (lower-bound i)) 2))

(define (percent i)
  (/ (- (upper-bound i) (lower-bound i)) (center i)))

(define (par1 r1 r2)
  (div-interval (mul-interval r1 r2) (add-interval r1 r2)))

(define (par2 r1 r2)
  (let ([one (make-interval 1 1)])
    (div-interval one (add-interval (div-interval one r1) (div-interval one r2)))))

(define (print-center-percent i)
  (display (center i))
  (display "±")
  (display (percent i))
  (newline))

(define a (make-center-percent 100 0.1))
(define b (make-center-percent 50 0.05))

(print-center-percent (par1 a b))
(print-center-percent (par2 a b))

(define one (make-interval 1 1))

;; (newline)
;; (mul-interval a b)
;; (add-interval a b)
;; (div-interval (mul-interval a b) (add-interval a b))
;; (newline)
;; (div-interval one a)
;; (div-interval one b)
;; (div-interval one (add-interval (div-interval one a) (div-interval one b)))
;; (newline)
(print-center-percent a)
(print-center-percent (div-interval a a))
(print-center-percent (div-interval a b))
(print-center-percent (div-interval b a))
(print-center-percent (div-interval b b))
(newline)
(print-center-percent b)
(print-center-percent (div-interval (mul-interval a b) a))
#+END_SRC

#+RESULTS:
#+begin_example
33.53739130434782±0.23242065961418784
33.32869565217391±0.06668753913587964
100.0±0.1
1.0050125313283207±0.1995012468827928
2.00375234521576±0.1498127340823968
0.5018796992481203±0.1498127340823968
1.0012507817385865±0.09993753903810083

50.0±0.04999999999999986
50.37593984962406±0.2488805970149251
#+end_example

So first of all, we notice the problem that dividing an interval by itself returns an uncertain interval centered around 1 instead of just (1, 1). This becomes a problem because it introduces unexpected uncertainty into the algebraic operations (as [[https://stackoverflow.com/questions/14130878/sicp-2-16-interval-arithmetic-scheme/14131196#14131196][this StackOverflow answer]] puts it, interval arithmetic is not a field).

***** DONE Exercise 2.15
:PROPERTIES:
:CUSTOM_ID: exercise-2.15
:END:

Eva Lu Ator, another user, has also noticed the different intervals computed by different but algebraically equivalent expressions.  She says that a formula to compute with intervals using Alyssa's system will produce tighter error bounds if it can be written in such a form that no variable that represents an uncertain number is repeated.  Thus, she says, ~par2~ is a "better" program for parallel resistances than ~par1~.  Is she right?  Why?

I mean, maybe I should try to produce a better explanation, but yes, as mentioned in the previous exercise, ~par2~ avoids repeating R_1 and R_2 which introduces additional uncertainty.

***** DONE Exercise 2.16
:PROPERTIES:
:CUSTOM_ID: exercise-2.16
:END:

Explain, in general, why equivalent algebraic expressions may lead to different answers.  Can you devise an interval-arithmetic package that does not have this shortcoming, or is this task impossible?  (Warning: This problem is very difficult.)

Turns out this is known as the dependency problem that is indeed very difficult. I suppose it might be possible for each interval to be uniquely identified: suppose R_1 and R_2 are both 1K resistors with 5 percent tolerance, but in the calculations it is important to distinguish each of them & not introduce uncertainty that do not have any physical basis when the same value is repeated. Perhaps some advanced CAS system can rewrite the algebraic expressions, group the terms with the same intervals together, and calculate them first this way? Tbh I think this is probably one of the problems...

*** DONE 2.2 Hierarchical Data and the Closure Property
**** DONE 2.2.1 Representing Sequences

Good linked lists made with ~cons~. Remember Lisp is for LISt Processor.

#+BEGIN_SRC racket :noweb yes
#lang sicp
(define one-through-four (list 1 2 3 4))
one-through-four
(car one-through-four)
(cdr one-through-four)
(car (cdr one-through-four))
(cadr one-through-four)
(cons 10 one-through-four)
(cons 5 one-through-four)
(cdr (cdr (cdr one-through-four)))
(cdr (cdr (cdr (cdr one-through-four))))

(define five-through-eight (list 5 6 7 8))
(cons one-through-four five-through-eight)
(cons 1 five-through-eight)
#+END_SRC

#+RESULTS:
#+begin_example
(1 2 3 4)
1
(2 3 4)
2
2
(10 1 2 3 4)
(5 1 2 3 4)
(4)
()
((1 2 3 4) 5 6 7 8)
(1 5 6 7 8)
#+end_example

Note that ~(1 2 3 4)~ is the evluated result of the expression ~(list 1 2 3 4)~. You can't evaluate ~(1 2 3 4)~ again.

Seems like the empty list is ~'()~ in Racket too as the SICP author wants (quotes if you are not using the SICP package).

#+BEGIN_SRC racket :noweb yes
#lang sicp

(define (list-ref items n)
  (if (= n 0) (car items) (list-ref (cdr items) (- n 1))))

(define squares (list 1 4 9 16 25))

(list-ref squares 3)
;; (list-ref squares 5)
;; error!
#+END_SRC

#+RESULTS:
: 16
: 25

#+BEGIN_SRC racket :noweb yes
#lang sicp

(define (length items)
  (if (null? items) 0 (+ 1 (length (cdr items)))))

(define odds (list 1 3 5 7))

(length odds)
#+END_SRC

#+RESULTS:
: 4

#+BEGIN_SRC racket :noweb yes
#lang sicp

(define (length items)
  (define (iter a count)
    (if (null? a) count (iter (cdr a) (+ 1 count))))
  (iter items 0))

(define odds (list 1 3 5 7))

(length odds)
#+END_SRC

#+RESULTS:
: 4

#+BEGIN_SRC racket :noweb yes
#lang sicp

(define (append list1 list2)
  (if (null? list1) list2 (cons (car list1) (append (cdr list1) list2))))

(append (list 1 3 5 7) (list 1 4 9 16 25))
#+END_SRC

#+RESULTS:
: (1 3 5 7 1 4 9 16 25)

***** DONE Exercise 2.17
:PROPERTIES:
:CUSTOM_ID: exercise-2.17
:END:

Define a procedure ~last-pair~ that returns the list that contains only the last element of a given (nonempty) list:

#+BEGIN_SRC scheme
(last-pair (list 23 72 149 34))
(34)
#+END_SRC

#+BEGIN_SRC racket :noweb yes
#lang sicp

(define (last-pair list)
  (if (null? (cdr list)) (car list) (last-pair (cdr list))))

(last-pair (list 23 72 149 34))
#+END_SRC

#+RESULTS:
: 34

***** DONE Exercise 2.18
:PROPERTIES:
:CUSTOM_ID: exercise-2.18
:END:

Define a procedure ~reverse~ that takes a list as argument and returns a list of the same elements in reverse order:

#+BEGIN_SRC scheme
(reverse (list 1 4 9 16 25))
(25 16 9 4 1)
#+END_SRC

#+BEGIN_SRC racket :noweb yes
#lang sicp

(define (reverse list)
  (if (null? (cdr list)) (car list) (cons (reverse (cdr list)) (car list))))

(reverse (list 1 4 9 16 25))
#+END_SRC

#+RESULTS:
: ((((25 . 16) . 9) . 4) . 1)

Nice try, but this doesn't work because the links are in the wrong direction.

#+BEGIN_SRC racket :noweb yes
#lang sicp

(define (append list1 list2)
  (if (null? list1) list2 (cons (car list1) (append (cdr list1) list2))))

(define (reverse list)
  (if (null? (cdr list)) list (append (reverse (cdr list)) (cons (car list) nil))))

(reverse (list 1 4 9 16 25))
#+END_SRC

#+RESULTS:
: (25 16 9 4 1)

This works.

But maybe we can not use append? I am revisiting this problem a few sections later. The ~append~ I copied and pasted after this may use the above form.

We can just keep adding the ~car~ to the beginning of another list instead of trying to do everything in place. The key realization is that adding to the front of the linked list is easy because you can just make a ~cons~ of ~(<new item>, <first cons of linked list>)~.

#+BEGIN_SRC racket :noweb yes
#lang sicp

(define (reverse list)
  (define (iter in out)
    (if (null? in) out (iter (cdr in) (cons (car in) out))))
  (iter list nil))

(reverse (list 1 4 9 16 25))
#+END_SRC

#+RESULTS:
: (25 16 9 4 1)

***** DONE Exercise 2.19
:PROPERTIES:
:CUSTOM_ID: exercise-2.19
:END:

Consider the change-counting program of section [[#section-1.2.2][1.2.2]].  It would be nice to be able to easily change the currency used by the program, so that we could compute the number of ways to change a British pound, for example.  As the program is written, the knowledge of the currency is distributed partly into the procedure ~first-denomination~ and partly into the procedure ~count-change~ (which knows that there are five kinds of U.S. coins).  It would be nicer to be able to supply a list of coins to be used for making change.

We want to rewrite the procedure ~cc~ so that its second argument is a list of the values of the coins to use rather than an integer specifying which coins to use.  We could then have lists that defined each kind of currency:

#+BEGIN_SRC scheme
(define us-coins (list 50 25 10 5 1))

(define uk-coins (list 100 50 20 10 5 2 1 0.5))
#+END_SRC

We could then call ~cc~ as follows:

#+BEGIN_SRC scheme
(cc 100 us-coins)
292
#+END_SRC

To do this will require changing the program ~cc~ somewhat.  It will still have the same form, but it will access its second argument differently, as follows:

#+BEGIN_SRC scheme
(define (cc amount coin-values)
  (cond ((= amount 0) 1)
        ((or (< amount 0) (no-more? coin-values)) 0)
        (else
         (+ (cc amount
                (except-first-denomination coin-values))
            (cc (- amount
                   (first-denomination coin-values))
                coin-values)))))
#+END_SRC

Define the procedures ~first-denomination~, ~except-first-denomination~, and ~no-more?~ in terms of primitive operations on list structures.  Does the order of the list ~coin-values~ affect the answer produced by ~cc~?  Why or why not?

#+BEGIN_SRC racket :noweb yes
#lang sicp

(define (max-in list)
  (define (iter items n)
    (if (null? items) n (iter (cdr items) (max n (car items)))))
  (iter list 0))

(define (first-denomination values)
  (max-in values))
(define (except-first-denomination values)
  (define (iter n old new)
    (if (null? old)
        new
        (iter n (cdr old) (if (not (= n (car old))) (append new (cons (car old) nil)) new))))
  (iter (max-in values) values nil))
(define (no-more? values)
  (null? values))

(define (cc amount coin-values)
  (cond
    [(= amount 0) 1]
    [(or (< amount 0) (no-more? coin-values)) 0]
    [else
     (+ (cc amount (except-first-denomination coin-values))
        (cc (- amount (first-denomination coin-values)) coin-values))]))

(define us-coins (list 50 25 10 5 1))
(define uk-coins (list 100 50 20 10 5 2 1 0.5))
(define test-coins (list 1))

;; (except-first-denomination test-coins)
;; (no-more? (except-first-denomination test-coins))

(cc 100 us-coins)
(cc 100 uk-coins)
#+END_SRC

#+RESULTS:
: 1
: 50
: 292
: 104561

Obviously, for this implementation the order of ~coin-values~ doesn't matter because we work hard to ensure the largest denominations get used in order.

The enlightenment comes when you notice that you can not care about any of it & have ~coin-values~ in the wrong order and the algorithm still works:

#+BEGIN_SRC racket :noweb yes
#lang sicp

(define (first-denomination values)
  (car values))
(define (except-first-denomination values)
  (cdr values))
(define (no-more? values)
  (null? values))

(define (cc amount coin-values)
  (cond
    [(= amount 0) 1]
    [(or (< amount 0) (no-more? coin-values)) 0]
    [else
     (+ (cc amount (except-first-denomination coin-values))
        (cc (- amount (first-denomination coin-values)) coin-values))]))

(define us-coins (list 25 50 10 5 1))
(define uk-coins (list 50 20 10 100 5 2 1 0.5))
(define test-coins (list 50 100))

(cc 100 us-coins)
(cc 100 uk-coins)
(cc 150 test-coins)
#+END_SRC

#+RESULTS:
: 292
: 104561
: 2

Why? Well, the algorithm always tests every possible combination. No combination is missed or recounted. Imagine you have the denominations in the order of ~(50, 100)~ and a total of ~150~ to match:

~(cc 150) [50, 100]~
~(cc 150) [100], (cc 100) [50, 100]~
~(cc 150) [], (cc 50) [100], (cc 100) [100], (cc 50) [50, 100]~
                            ~(cc 100) [], (cc 0) [100], (cc 50) [100], (cc 0) [50, 100]~

There are only two solutions, ~(50, 100)~ and ~(50, 50, 50)~. Note that ~(100, 50)~ isn't counted again (as may be the concern for when ~coin-values~ is ordered) because by the time ~100~ can be used ~50~ is already dropped from the denomination list (more precisely, dropped after ~50~ was used, which is how ~(50, 100)~ is generated).

***** DONE Exercise 2.20
:PROPERTIES:
:CUSTOM_ID: exercise-2.20
:END:

The procedures ~+~, ~*~, and ~list~ take arbitrary numbers of arguments.  One way to define such procedures is to use ~define~ with <<i116>> dotted-tail notation.  In a procedure definition, a parameter list that has a dot before the last parameter name indicates that, when the procedure is called, the initial parameters (if any) will have as values the initial arguments, as usual, but the final parameter's value will be a <<i211>> list of any remaining arguments.  For instance, given the definition

#+BEGIN_SRC scheme
(define (f x y . z) <BODY>)
#+END_SRC

the procedure ~f~ can be called with two or more arguments.  If we evaluate

#+BEGIN_SRC scheme
(f 1 2 3 4 5 6)
#+END_SRC

then in the body of ~f~, ~x~ will be 1, ~y~ will be 2, and ~z~ will be the list ~(3 4 5 6)~.  Given the definition

#+BEGIN_SRC scheme
(define (g . w) <BODY>)
#+END_SRC

the procedure ~g~ can be called with zero or more arguments.  If we evaluate

#+BEGIN_SRC scheme
(g 1 2 3 4 5 6)
#+END_SRC

then in the body of ~g~, ~w~ will be the list ~(1 2 3 4 5 6)~.[fn:77]

Use this notation to write a procedure ~same-parity~ that takes one or more integers and returns a list of all the arguments that have the same even-odd parity as the first argument.  For example,

#+BEGIN_SRC scheme
(same-parity 1 2 3 4 5 6 7)
(1 3 5 7)

(same-parity 2 3 4 5 6 7)
(2 4 6)
#+END_SRC

#+BEGIN_SRC racket :noweb yes
#lang sicp

(define (append list1 list2)
  (if (null? list1) list2 (cons (car list1) (append (cdr list1) list2))))

(define (same-parity x . z)
  (define (iter new old)
    (if (null? old)
        new
        (iter (if (even? (+ x (car old))) (append new (cons (car old) nil)) new) (cdr old))))
  (iter (cons x nil) z))

(same-parity 1 2 3 4 5 6 7)
(same-parity 2 3 4 5 6 7)
#+END_SRC

#+RESULTS:
: (1 3 5 7)
: (2 4 6)

***** Mapping over lists

#+BEGIN_SRC racket :noweb yes
#lang sicp

(define (scale-list items factor)
  (if (null? items) nil (cons (* (car items) factor) (scale-list (cdr items) factor))))

(scale-list (list 1 2 3 4 5) 10)
#+END_SRC

#+RESULTS:
: (10 20 30 40 50)

#+BEGIN_SRC racket :noweb yes
#lang sicp

(define (map proc items)
  (if (null? items) nil (cons (proc (car items)) (map proc (cdr items)))))

(map abs (list -10 2.5 -11.6 17))

(map (lambda (x) (* x x)) (list 1 2 3 4))

(define (scale-list items factor)
  (map (lambda (x) (* x factor)) items))

(scale-list (list 1 2 3 4 5) 10)
#+END_SRC

#+RESULTS:
: (10 2.5 11.6 17)
: (1 4 9 16)
: (10 20 30 40 50)

***** DONE Exercise 2.21
:PROPERTIES:
:CUSTOM_ID: exercise-2.21
:END:

The procedure ~square-list~ takes a list of numbers as argument and returns a list of the squares of those numbers.

#+BEGIN_SRC scheme
(square-list (list 1 2 3 4))
(1 4 9 16)
#+END_SRC

Here are two different definitions of ~square-list~.  Complete both of them by filling in the missing expressions:

#+BEGIN_SRC scheme
(define (square-list items)
  (if (null? items)
      nil
      (cons <??> <??>)))

(define (square-list items)
  (map <??> <??>))
#+END_SRC

#+BEGIN_SRC racket :noweb yes
<<sicp>>

(define (square-list-1 items)
  (if (null? items) nil (cons (square (car items)) (square-list-1 (cdr items)))))

(define (square-list-2 items)
  (map square items))

(square-list-1 (list 1 2 3 4))
(square-list-2 (list 1 2 3 4))
#+END_SRC

#+RESULTS:
: (1 4 9 16)
: (1 4 9 16)

***** DONE Exercise 2.22
:PROPERTIES:
:CUSTOM_ID: exercise-2.22
:END:

Louis Reasoner tries to rewrite the first ~square-list~ procedure of [[#exercise-2.21][Exercise 2.21]] so that it evolves an iterative process:

#+BEGIN_SRC scheme
(define (square-list items)
  (define (iter things answer)
    (if (null? things)
        answer
        (iter (cdr things)
              (cons (square (car things))
                    answer))))
  (iter items nil))
#+END_SRC

Unfortunately, defining ~square-list~ this way produces the answer list in the reverse order of the one desired.  Why?

Answer:

Let's first try to run it:

#+BEGIN_SRC racket :noweb yes
<<sicp>>

(define (square-list items)
  (define (iter things answer)
    (if (null? things) answer (iter (cdr things) (cons (square (car things)) answer))))
  (iter items nil))

(square-list (list 1 2 3 4))
#+END_SRC

#+RESULTS:
: (16 9 4 1)

Indeed the list of squares is in reverse order. The reason is quite simply that the list is being built in ~answer~ backward; at the beginning ~answer~ is nil, and then it's ~(1 . nil)~, then ~(4 . (1 . nil))~, etc.

Louis then tries to fix his bug by interchanging the arguments to ~cons~:

#+BEGIN_SRC racket :noweb yes
<<sicp>>

(define (square-list items)
  (define (iter things answer)
    (if (null? things) answer (iter (cdr things) (cons answer (square (car things))))))
  (iter items nil))

(square-list (list 1 2 3 4))
#+END_SRC

#+RESULTS:
: ((((() . 1) . 4) . 9) . 16)

This doesn't work either.  Explain.

Lol this is the happy "linked list in the wrong direction" thing again. More precisely in this case, the list is not grown properly because the second argument of ~cons~ is not a valid list, but a number.

You can use ~append~:

#+BEGIN_SRC racket :noweb yes
<<sicp>>

(define (append list1 list2)
  (if (null? list1) list2 (cons (car list1) (append (cdr list1) list2))))

(define (square-list items)
  (define (iter things answer)
    (if (null? things) answer (iter (cdr things) (append answer (cons (square (car things)) nil)))))
  (iter items nil))

(square-list (list 1 2 3 4))
#+END_SRC

#+RESULTS:
: (1 4 9 16)

***** DONE Exercise 2.23
:PROPERTIES:
:CUSTOM_ID: exercise-2.23
:END:

The procedure ~for-each~ is similar to ~map~.  It takes as arguments a procedure and a list of elements.  However, rather than forming a list of the results, ~for-each~ just applies the procedure to each of the elements in turn, from left to right.  The values returned by applying the procedure to the elements are not used at all--~for-each~ is used with procedures that perform an action, such as printing.  For example,

#+BEGIN_SRC scheme
(for-each (lambda (x) (newline) (display x))
          (list 57 321 88))
57
321
88
#+END_SRC

The value returned by the call to ~for-each~ (not illustrated above) can be something arbitrary, such as true.  Give an implementation of ~for-each~.

Well my first reaction was to reach for ~progn~ (~begin~ in Racket):

#+BEGIN_SRC racket :noweb yes
#lang sicp

(define (for-each f l)
  (if (null? l)
      (newline)
      (begin
        (f (car l))
        (for-each f (cdr l)))))

(for-each (lambda (x)
            (newline)
            (display x))
          (list 57 321 88))
#+END_SRC

#+RESULTS:
: 
: 57
: 321
: 88

but there are ways to avoid using it too, namely calling the function during a call to ~iter~ but not using the return value in the parameter:


#+BEGIN_SRC racket :noweb yes
#lang sicp

(define (for-each f l)
  (define (iter elems call)
    (if (null? elems) (newline) (iter (cdr elems) (f (car elems)))))
  (iter l nil))

(for-each (lambda (x)
            (newline)
            (display x))
          (list 57 321 88))
#+END_SRC

#+RESULTS:
: 
: 57
: 321
: 88

I feel like this might be closer to what the exercise is expecting, but feels a bit weird too (getting the side effect this way).

**** DONE 2.2.2 Hierarchical Structures

#+BEGIN_SRC racket :noweb yes
#lang sicp

(cons (list 1 2) (list 3 4))
(cons 1 (list 2 3 4))
#+END_SRC

#+RESULTS:
: ((1 2) 3 4)
: (1 2 3 4)

#+BEGIN_SRC racket :noweb yes
#lang sicp

(define (count-leaves x)
  (cond
    [(null? x) 0]
    [(not (pair? x)) 1]
    [else (+ (count-leaves (car x)) (count-leaves (cdr x)))]))

(define x (cons (list 1 2) (list 3 4)))
(list x x)
(count-leaves (list x x))
#+END_SRC

#+RESULTS:
: (((1 2) 3 4) ((1 2) 3 4))
: 8

Note that you need to check for ~nil~ before checking for leaf.

***** DONE Exercise 2.24
:PROPERTIES:
:CUSTOM_ID: exercise-2.24
:END:

Suppose we evaluate the expression ~(list 1 (list 2 (list 3 4)))~.  Give the result printed by the interpreter, the corresponding box-and-pointer structure, and the interpretation of this as a tree.

#+BEGIN_SRC racket :noweb yes
#lang sicp

(list 1 (list 2 (list 3 4)))
#+END_SRC

#+RESULTS:
: (1 (2 (3 4)))

Box and pointer (from SchemeWiki):

#+begin_example
                                         
   +---+---+  +---+---+
   | * | *-+->| * | / |
   +-+-+---+  +-+-+---+
     |          |   
     V          V      
   +---+      +---+---+  +---+---+
   | 1 |      | * | *-+->| * | / |
   +---+      +-+-+---+  +---+---+
                |          |
                V          V
              +---+      +---+---+  +---+---+
              | 2 |      | * | *-+->| * | / |
              +---+      +-+-+---+  +-+-+---+
                           |          |
                           V          V
                         +---+      +---+
                         | 3 |      | 4 |
                         +---+      +---+
#+end_example

Tree:

#+begin_example
      (1 (2 (3 4)))
      ^
    /   \
   1     ^ (2 (3 4))
       /   \
      2     ^ (3 4)
          /   \
         3     4
#+end_example

***** DONE Exercise 2.25
:PROPERTIES:
:CUSTOM_ID: exercise-2.25
:END:

Give combinations of 'car's and 'cdr's that will pick 7 from each of the following lists:

#+BEGIN_SRC scheme
(1 3 (5 7) 9)

((7))

(1 (2 (3 (4 (5 (6 7))))))
#+END_SRC


#+BEGIN_SRC racket :noweb yes
#lang sicp

(define x (list 1 3 (list 5 7) 9))

(car (cdr (car (cdr (cdr x)))))

(define y (list (list 7)))

(car (car y))

(define z (list 1 (list 2 (list 3 (list 4 (list 5 (list 6 7)))))))

(car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr z))))))))))))
;; alternatively cadr is a thing
(cadr (cadr (cadr (cadr (cadr (cadr z))))))
#+END_SRC

#+RESULTS:
: 7
: 7
: 7
: 7

A reminder again that you need to build it inside out, and that if you have ~(list ... (list ...))~, to extract the second list you need to do ~(car (cdr))~, as the second list is in a cons cell that is like ~(list . nil)~.

***** DONE Exercise 2.26
:PROPERTIES:
:CUSTOM_ID: exercise-2.26
:END:

Suppose we define ~x~ and ~y~ to be two lists:

#+BEGIN_SRC scheme
(define x (list 1 2 3))

(define y (list 4 5 6))
#+END_SRC

What result is printed by the interpreter in response to evaluating each of the following expressions:

#+BEGIN_SRC scheme
(append x y)

(cons x y)

(list x y)
#+END_SRC

#+BEGIN_SRC racket :noweb yes
#lang sicp

(define (append list1 list2)
  (if (null? list1) list2 (cons (car list1) (append (cdr list1) list2))))

(define x (list 1 2 3))
(define y (list 4 5 6))

(append x y)
;; (1 2 3 4 5 6)
(cons x y)
;; ((1 2 3) 4 5 6)
(list x y)
;; ((1 2 3) (4 5 6))
(cons x (cons y nil))
#+END_SRC

#+RESULTS:
: (1 2 3 4 5 6)
: ((1 2 3) 4 5 6)
: ((1 2 3) (4 5 6))
: ((1 2 3) (4 5 6))

This exercise might be a good place to recap:

If you put a list into the ~cdr~ of a ~cons~, you are extending the linked list that the ~cons~ is a part of.

Meanwhile, ~(list x y)~ is the same as ~(cons x (cons y nil))~, as remember that more generally:

#+BEGIN_SRC scheme
(list <A_1> <A_2> ... <A_N>)
#+END_SRC

is equivalent to

#+BEGIN_SRC scheme
(cons <A_1>
      (cons <A_2>
            (cons ...
                  (cons <A_N>
                        nil)
                  ...)))
#+END_SRC

The interpreter just doesn't print out nil:

#+BEGIN_SRC racket :noweb yes
#lang sicp

(cons 1 nil)
(cons (list 1 2 3) nil)
#+END_SRC

#+RESULTS:
: (1)
: ((1 2 3))

***** DONE Exercise 2.27
:PROPERTIES:
:CUSTOM_ID: exercise-2.27
:END:

Modify your ~reverse~ procedure of [[#exercise-2.18][Exercise 2.18]] to produce a ~deep-reverse~ procedure that takes a list as argument and returns as its value the list with its elements reversed and with all sublists deep-reversed as well.  For example,

#+BEGIN_SRC scheme
(define x (list (list 1 2) (list 3 4)))

x
((1 2) (3 4))

(reverse x)
((3 4) (1 2))

(deep-reverse x)
((4 3) (2 1))
#+END_SRC

#+BEGIN_SRC racket :noweb yes
#lang sicp

(define (reverse l)
  (if (null? (cdr l)) l (append (reverse (cdr l)) (cons (car l) nil))))

(define (deep-reverse l)
  (if (null? l)
      l
      (append (deep-reverse (cdr l))
              (cons (if (list? (car l)) (reverse (car l)) (car l)) nil))))

(define x (list (list 1 2) (list 3 4)))
(deep-reverse x)

(deep-reverse (list 0 (list 1 2 3 4 (list 5 6 7 8)) 1 (list 9 8 7 6) 2 (list 3 4 5 6) 3))
#+END_SRC

#+RESULTS:
: ((4 3) (2 1))
: (3 (6 5 4 3) 2 (6 7 8 9) 1 ((5 6 7 8) 4 3 2 1) 0)

(added later: from the idea of another reverse implementation)

#+BEGIN_SRC racket :noweb yes
#lang sicp

(define (reverse l)
  (define (iter in out)
    (if (null? in) out (iter (cdr in) (cons (car in) out))))
  (iter l nil))

(define (deep-reverse l)
  (define (iter in out)
    (if (null? in)
        out
        (iter (cdr in) (cons (if (list? (car in)) (deep-reverse (car in)) (car in)) out))))
  (iter l nil))

(define x (list (list 1 2) (list 3 4)))
(deep-reverse x)

(deep-reverse (list 0 (list 1 2 3 4 (list 5 6 7 8)) 1 (list 9 8 7 6) 2 (list 3 4 5 6) 3))
#+END_SRC

#+RESULTS:
: ((4 3) (2 1))
: (3 (6 5 4 3) 2 (6 7 8 9) 1 ((8 7 6 5) 4 3 2 1) 0)

This starts off modifying ~reverse~ as the prompt intended and works much the same way. But let's see if there are any more elegant ways. We sure are using ~reverse~ a lot; in fact we want to run ~reverse~ over every element in the list that is a list; otherwise we just return the element.

#+BEGIN_SRC racket :noweb yes
#lang sicp

(define (deep-reverse l)
  (if (list? l) (reverse (map deep-reverse l)) l))

(deep-reverse (list 0 (list 1 2 3 4) 1 (list 9 8 7 6) 2 (list 3 4 5 6)))
#+END_SRC

#+RESULTS:
: ((6 5 4 3) 2 (6 7 8 9) 1 (4 3 2 1) 0)

Beautiful.

***** DONE Exercise 2.28
:PROPERTIES:
:CUSTOM_ID: exercise-2.28
:END:

Write a procedure ~fringe~ that takes as argument a tree (represented as a list) and returns a list whose elements are all the leaves of the tree arranged in left-to-right order.  For example,

#+BEGIN_SRC scheme
(define x (list (list 1 2) (list 3 4)))

(fringe x)
(1 2 3 4)

(fringe (list x x))
(1 2 3 4 1 2 3 4)
#+END_SRC

I first thought maybe we could use ~map~ again, but remember it always returns a list so you can't flatten nested lists with it:

#+BEGIN_SRC racket :noweb yes
#lang sicp

(define (fringe l)
  (if (list? l) (map fringe l) l))

(define x (list (list 1 2) (list 3 4)))
(fringe x)
(fringe (list x x))
#+END_SRC

#+RESULTS:
: ((1 2) (3 4))
: (((1 2) (3 4)) ((1 2) (3 4)))
: (1 2)

Some quick and dirty way might be just to use ~append~; after all we know how to traverse the tree:

#+BEGIN_SRC racket :noweb yes
#lang sicp

(define (fringe l)
  (cond
    [(null? l) nil]
    [(pair? l) (append (fringe (car l)) (fringe (cdr l)))]
    [else (cons l nil)]))

(define x (list (list 1 2) (list 3 4)))
(fringe x)
(fringe (list x x))
#+END_SRC

#+RESULTS:
: (1 2 3 4)
: (1 2 3 4 1 2 3 4)

Note that you can also do ~(list l)~ in the final case; it's just important to return something appendable.

Note that something like this may look itertive:

#+BEGIN_SRC racket :noweb yes
#lang sicp

(define (fringe l)
  (define (not-iter in out)
    (cond
      [(null? in) out]
      [(pair? in)
       (not-iter (car in)
       (not-iter (cdr in) out))]
      [else (cons in out)]))
  (not-iter l nil))

(define x (list (list 1 2) (list 3 4)))
(fringe x)
(fringe (list x x))
#+END_SRC

#+RESULTS:
: (1 2 3 4)
: (1 2 3 4 1 2 3 4)

but ~not-iter~ calls itself ~(not-iter (car in) (not-iter (cdr in) out))~; as the arguments need to be evaluated first in applicative order, stack space needs to be reserved until the inner call returns (I recall from chapter 1 but obviously I don't know Scheme interpreter/compiler internals so). In fact I think this is exponential.

Now using ~append~ comes with its own problems. But I'm sure we can make something that grows the fringe list the other way (as we have learned that's easy)? Then we already have a ~reverse~ that is nicely iterative.

So let's think again about what makes this problem hard. You need to get to all the leaves and put them in a list in order. Recursion is obviously a good way to keep breaking down the tree into two branches; perhaps in an iterative solution we can just manually keep the left and right branches (inspired by the next exercise)?

Let's think more carefully about how this will work. We keep the left branch, right branch, and the results. At the start the left branch is empty, the right branch is the whole list, and the results is also empty.

As we start, the first major thing to consider is the cases when the first element of the list is a sublist. If it's not, we can just add it to results. If it is, lol we can just take the first element in it, cons the cdr of the list with the rest of the list, and we are back to the base case having accomplished something! When both the left and right branches are nil we can just return the results and reverse it.

Note that it has to be when both are nil. Consider when the last thing in the right is a list. You move it to the left and right becomes nil. Left needs to give the cdr of it back again!

#+BEGIN_SRC racket :noweb yes
#lang sicp

(define (fringe l)
  (define (iter left right result)
    (cond
      [(and (null? left) (null? right)) result]
      [(null? left) (iter (car right) (cdr right) result)]
      [(pair? left) (iter (car left) (cons (cdr left) right) result)]
      [else (iter nil right (cons left result))]))
  (reverse (iter nil l nil)))

(define x (list (list 1 2) (list 3 4)))
(fringe x)
(fringe (list x x))
#+END_SRC

#+RESULTS:
: (1 2 3 4)
: (1 2 3 4 1 2 3 4)

Turns out much nicer than I expected. Now looking at it I didn't really think about when left is nil. It is the base case and we need to be able to handle it.

***** DONE Exercise 2.29
:PROPERTIES:
:CUSTOM_ID: exercise-2.29
:END:

A binary mobile consists of two branches, a left branch and a right branch.  Each branch is a rod of a certain length, from which hangs either a weight or another binary mobile.  We can represent a binary mobile using compound data by constructing it from two branches (for example, using ~list~):

#+BEGIN_SRC scheme
(define (make-mobile left right)
  (list left right))
#+END_SRC

A branch is constructed from a ~length~ (which must be a number) together with a ~structure~, which may be either a number (representing a simple weight) or another mobile:

#+BEGIN_SRC scheme
(define (make-branch length structure)
  (list length structure))
#+END_SRC

Oh lol a multipart question.

a. Write the corresponding selectors ~left-branch~ and ~right-branch~, which return the branches of a mobile, and ~branch-length~ and ~branch-structure~, which return the components of a branch.

#+BEGIN_SRC racket :noweb yes
#lang sicp

(define (make-mobile left right)
  (list left right))

(define (make-branch length structure)
  (list length structure))

(define (left-branch mobile)
  (car mobile))

(define (right-branch mobile)
  (cadr mobile))

(define (branch-length branch)
  (car branch))

(define (branch-structure branch)
  (cadr branch))
#+END_SRC

Note that you want to use ~cadr~ because...I don't know why we are not using cons? (oh actually see part 4) Anyways:

#+BEGIN_SRC racket :noweb yes
#lang sicp

(cdr (list 1 2))
(cadr (list 1 2))
(pair? (list 1 2))
#+END_SRC

#+RESULTS:
: (2)
: 2
: #t


b. Using your selectors, define a procedure ~total-weight~ that returns the total weight of a mobile.

#+BEGIN_SRC racket :noweb yes
#lang sicp

(define (make-mobile left right)
  (list left right))

(define (make-branch length structure)
  (list length structure))

(define (left-branch mobile)
  (car mobile))

(define (right-branch mobile)
  (cadr mobile))

(define (branch-length branch)
  (car branch))

(define (branch-structure branch)
  (cadr branch))

(define (weight? structure)
  (not (pair? structure)))

(define (total-weight mobile)
  (cond
    [(weight? mobile) mobile]
    [else
     (+ (total-weight (branch-structure (left-branch mobile)))
        (total-weight (branch-structure (right-branch mobile))))]))

;;          4  |  5
;;        +----+-----+
;;        6        3 |     9
;;               +---+---------+
;;               7             8
;; from SchemeWiki
(define m1
  (make-mobile (make-branch 4 6) (make-branch 5 (make-mobile (make-branch 3 7) (make-branch 9 8)))))

(total-weight m1)
#+END_SRC

#+RESULTS:
: 21

c. A mobile is said to be <<i32>> balanced if the torque applied by its top-left branch is equal to that applied by its top-right branch (that is, if the length of the left rod multiplied by the weight hanging from that rod is equal to the corresponding product for the right side) and if each of the submobiles hanging off its branches is balanced.  Design a predicate that tests whether a binary mobile is balanced.

#+BEGIN_SRC racket :noweb yes
#lang sicp

(define (make-mobile left right)
  (list left right))

(define (make-branch length structure)
  (list length structure))

(define (left-branch mobile)
  (car mobile))

(define (right-branch mobile)
  (cadr mobile))

(define (branch-length branch)
  (car branch))

(define (branch-structure branch)
  (cadr branch))

(define (weight? structure)
  (not (pair? structure)))

(define (total-weight mobile)
  (cond
    [(weight? mobile) mobile]
    [else
     (+ (total-weight (branch-structure (left-branch mobile)))
        (total-weight (branch-structure (right-branch mobile))))]))

(define (balanced? mobile)
  (define (torque branch)
    (* (branch-length branch) (total-weight (branch-structure branch))))
  (cond
    [(weight? mobile) true]
    [else
     (let ([left (left-branch mobile)] [right (right-branch mobile)])
       (and (= (torque left) (torque right))
            (balanced? (branch-structure left))
            (balanced? (branch-structure right))))]))

;;          4  |  5
;;        +----+-----+
;;        6        3 |     9
;;               +---+---------+
;;               7             8
;; from SchemeWiki
(define m1
  (make-mobile (make-branch 4 6) (make-branch 5 (make-mobile (make-branch 3 7) (make-branch 9 8)))))
;;          4  | 2
;;        +----+--+
;;        6    5  |    10
;;          +-----+----------+
;;          8                4
(define m2
  (make-mobile (make-branch 4 6) (make-branch 2 (make-mobile (make-branch 5 8) (make-branch 10 4)))))

(balanced? m1)
(balanced? m2)
#+END_SRC

#+RESULTS:
: #f
: #t

d. Suppose we change the representation of mobiles so that the constructors are

#+BEGIN_SRC scheme
(define (make-mobile left right)
  (cons left right))

(define (make-branch length structure)
  (cons length structure))
#+END_SRC

How much do you need to change your programs to convert to the new representation?

#+BEGIN_SRC racket :noweb yes
#lang sicp

;; (define (make-mobile left right)
;;   (list left right))

;; (define (make-branch length structure)
;;   (list length structure))

(define (make-mobile left right)
  (cons left right))

(define (make-branch length structure)
  (cons length structure))

(define (left-branch mobile)
  (car mobile))

(define (right-branch mobile)
  (cdr mobile))

(define (branch-length branch)
  (car branch))

(define (branch-structure branch)
  (cdr branch))

(define (weight? structure)
  (not (pair? structure)))

(define (total-weight mobile)
  (cond
    [(weight? mobile) mobile]
    [else
     (+ (total-weight (branch-structure (left-branch mobile)))
        (total-weight (branch-structure (right-branch mobile))))]))

(define (balanced? mobile)
  (define (torque branch)
    (* (branch-length branch) (total-weight (branch-structure branch))))
  (cond
    [(weight? mobile) true]
    [else
     (let ([left (left-branch mobile)] [right (right-branch mobile)])
       (and (= (torque left) (torque right))
            (balanced? (branch-structure left))
            (balanced? (branch-structure right))))]))

;;          4  |  5
;;        +----+-----+
;;        6        3 |     9
;;               +---+---------+
;;               7             8
;; from SchemeWiki
(define m1
  (make-mobile (make-branch 4 6) (make-branch 5 (make-mobile (make-branch 3 7) (make-branch 9 8)))))
;;          4  | 2
;;        +----+--+
;;        6    5  |    10
;;          +-----+----------+
;;          8                4
(define m2
  (make-mobile (make-branch 4 6) (make-branch 2 (make-mobile (make-branch 5 8) (make-branch 10 4)))))

(total-weight m1)
(total-weight m2)
(balanced? m1)
(balanced? m2)
#+END_SRC

#+RESULTS:
: 21
: 18
: #f
: #t

I only needed to change the selectors. However, I think it is important to have the ~weight?~ predicate that I don't see other answers using. Otherwise distinguishing between weights and submobiles based on assumptions about the implementation detail (~pair?~) could be bad.

***** Mapping over trees

#+BEGIN_SRC racket :noweb yes
#lang sicp

(define (scale-tree tree factor)
  (cond
    [(null? tree) nil]
    [(not (pair? tree)) (* tree factor)]
    [else (cons (scale-tree (car tree) factor) (scale-tree (cdr tree) factor))]))

(scale-tree (list 1 (list 2 (list 3 4) 5) (list 6 7)) 10)
#+END_SRC

#+RESULTS:
: (10 (20 (30 40) 50) (60 70))

#+BEGIN_SRC racket :noweb yes
#lang sicp

(define (scale-tree tree factor)
  (map (lambda (sub-tree) (if (pair? sub-tree) (scale-tree sub-tree factor) (* sub-tree factor)))
       tree))

(scale-tree (list 1 (list 2 (list 3 4) 5) (list 6 7)) 10)
#+END_SRC

#+RESULTS:
: (10 (20 (30 40) 50) (60 70))

***** DONE Exercise 2.30
:PROPERTIES:
:CUSTOM_ID: exercise-2.30
:END:

Define a procedure ~square-tree~ analogous to the ~square-list~ procedure of [[#exercise-2.21][Exercise 2.21]].  That is, ~square-list~ should behave as follows:

#+BEGIN_SRC scheme
(square-tree
 (list 1
       (list 2 (list 3 4) 5)
       (list 6 7)))
(1 (4 (9 16) 25) (36 49))
#+END_SRC

Define ~square-tree~ both directly (i.e., without using any higher-order procedures) and also by using ~map~ and recursion.

#+BEGIN_SRC racket :noweb yes
#lang sicp

(define (square-tree tree)
  (map (lambda (tree) (if (pair? tree) (square-tree tree) (* tree tree))) tree))

(square-tree (list 1 (list 2 (list 3 4) 5) (list 6 7)))
#+END_SRC

#+RESULTS:
: (1 (4 (9 16) 25) (36 49))

***** DONE Exercise 2.31
:PROPERTIES:
:CUSTOM_ID: exercise-2.31
:END:

Abstract your answer to [[#exercise-2.30][Exercise 2.30]] to produce a procedure ~tree-map~ with the property that ~square-tree~ could be defined as

#+BEGIN_SRC scheme
(define (square-tree tree) (tree-map square tree))
#+END_SRC

#+BEGIN_SRC racket :noweb yes
<<sicp>>

(define (tree-map proc tree)
  (map (lambda (tree) (if (pair? tree) (tree-map proc tree) (proc tree))) tree))

(define (square-tree tree)
  (tree-map square tree))

(square-tree (list 1 (list 2 (list 3 4) 5) (list 6 7)))
#+END_SRC

#+RESULTS:
: (1 (4 (9 16) 25) (36 49))

***** DONE Exercise 2.32
:PROPERTIES:
:CUSTOM_ID: exercise-2.32
:END:

We can represent a set as a list of distinct elements, and we can represent the set of all subsets of the set as a list of lists.  For example, if the set is ~(1 2 3)~, then the set of all subsets is ~(() (3) (2) (2 3) (1) (1 3) (1 2) (1 2 3))~.  Complete the following definition of a procedure that generates the set of subsets of a set and give a clear explanation of why it works:

#+BEGIN_SRC scheme
(define (subsets s)
  (if (null? s)
      (list nil)
      (let ((rest (subsets (cdr s))))
        (append rest (map <??> rest)))))
#+END_SRC

We are trying to generate the power set of the set we are given. Recall that if the set has cardinality n, then the power set has cardinality 2^n. This is because each element of the set can either be in or be not in a subset, so there are in total 2^n subsets you can make.

Taking this idea, here we are appending together:

- all the subsets that do not include ~(car s)~
- all the subsets that do include ~(car s)~ (we actually just add it in with ~cons~)

#+BEGIN_SRC racket
#lang sicp

(define (subsets s)
  (if (null? s)
      (list nil)
      (let ([rest (subsets (cdr s))]) (append rest (map (lambda (x) (cons (car s) x)) rest)))))

(subsets (list 1 2 3))
#+END_SRC

#+RESULTS:
: (() (3) (2) (2 3) (1) (1 3) (1 2) (1 2 3))

Recursive brain upgrade.

**** DONE 2.2.3 Sequences as Conventional Interfaces

#+BEGIN_SRC racket :noweb yes
<<sicp>>

(define (sum-odd-squares tree)
  (cond
    [(null? tree) 0]
    [(not (pair? tree)) (if (odd? tree) (square tree) 0)]
    [else (+ (sum-odd-squares (car tree)) (sum-odd-squares (cdr tree)))]))

(sum-odd-squares (list 1 (list 2 (list 3 4)) 5))
#+END_SRC

#+RESULTS:
: 35

#+BEGIN_SRC racket :noweb yes
#lang sicp

(define (fib n)
  (define (iter a b count)
    (if (= count 0) b (iter (+ a b) a (- count 1))))
  (iter 1 0 n))

(define (even-fibs n)
  (define (next k)
    (if (> k n) nil (let ([f (fib k)]) (if (even? f) (cons f (next (+ k 1))) (next (+ k 1))))))
  (next 0))

(even-fibs 100)
#+END_SRC

#+RESULTS:
: (0 2 8 34 144 610 2584 10946 46368 196418 832040 3524578 14930352 63245986 267914296 1134903170 4807526976 20365011074 86267571272 365435296162 1548008755920 6557470319842 27777890035288 117669030460994 498454011879264 2111485077978050 8944394323791464 37889062373143906 160500643816367088 679891637638612258 2880067194370816120 12200160415121876738 51680708854858323072 218922995834555169026)

Cool signal processing analogy the book uses.

#+BEGIN_SRC racket :noweb yes
#lang sicp

(define (filter predicate sequence)
  (cond
    [(null? sequence) nil]
    [(predicate (car sequence)) (cons (car sequence) (filter predicate (cdr sequence)))]
    [else (filter predicate (cdr sequence))]))

(filter odd? (list 1 2 3 4 5))
#+END_SRC

#+RESULTS:
: (1 3 5)

#+BEGIN_SRC racket :noweb yes
#lang sicp

(define (accumulate op initial sequence)
  (if (null? sequence) initial (op (car sequence) (accumulate op initial (cdr sequence)))))

(accumulate + 0 (list 1 2 3 4 5))

(accumulate * 1 (list 1 2 3 4 5))

(accumulate cons nil (list 1 2 3 4 5))
#+END_SRC

#+RESULTS:
: 15
: 120
: (1 2 3 4 5)

Note how initial is actually applied to ~op~ at the end. Let's trace ~(accumulate + 0 (list 1 2 3))~:

#+begin_example
(accumulate + 0 (list 1 2 3))
(+ 1 (accumulate + 0 (2 3)))
(+ 1 (+ 2 (accumulate + 0 (3))))
(+ 1 (+ 2 (+ 3 (accumulate + 0 nil))))
(+ 1 (+ 2 (+ 3 0)))
#+end_example

More generally the expansion is ~(op (car seq) (op (car (cdr seq)) initial))~.

#+BEGIN_SRC racket :noweb yes
#lang sicp

(define (enumerate-interval low high)
  (if (> low high) nil (cons low (enumerate-interval (+ low 1) high))))

(enumerate-interval 2 7)
#+END_SRC

#+RESULTS:
: (2 3 4 5 6 7)

#+BEGIN_SRC racket :noweb yes
#lang sicp

(define (enumerate-tree tree)
  (cond
    [(null? tree) nil]
    [(not (pair? tree)) (list tree)]
    [else (append (enumerate-tree (car tree)) (enumerate-tree (cdr tree)))]))

(enumerate-tree (list 1 (list 2 (list 3 4)) 5))
#+END_SRC

#+RESULTS:
: (1 2 3 4 5)

Isn't this just ~fringe~? Returning ~(list tree)~ is very clever, I have to say (oh actually it says so in footnote 14).

#+BEGIN_SRC racket :noweb yes
<<sicp>>

(define (sum-odd-squares tree)
  (accumulate + 0 (map square (filter odd? (enumerate-tree tree)))))

(sum-odd-squares (list 1 (list 2 (list 3 4)) 5))

(define (even-fibs n)
  (accumulate cons nil (filter even? (map fib (enumerate-interval 0 n)))))

(even-fibs 50)
#+END_SRC

#+RESULTS:
: 35
: (0 2 8 34 144 610 2584 10946 46368 196418 832040 3524578 14930352 63245986 267914296 1134903170 4807526976)

I mean, I guess this is cool, but enumerating Fibs this way is certainly not very efficient. I guess you can always optimize later.

#+BEGIN_SRC racket :noweb yes
<<sicp>>

(define (list-fib-squares n)
  (accumulate cons nil (map square (map fib (enumerate-interval 0 n)))))

(list-fib-squares 10)
#+END_SRC

#+RESULTS:
: (0 1 1 4 9 25 64 169 441 1156 3025)

#+BEGIN_SRC racket :noweb yes
<<sicp>>

(define (product-of-squares-of-odd-elements sequence)
  (accumulate * 1 (map square (filter odd? sequence))))

(product-of-squares-of-odd-elements (list 1 2 3 4 5))
#+END_SRC

#+RESULTS:
: 225

#+begin_example
(define (salary-of-highest-paid-programmer records)
  (accumulate max 0 (map salary (filter programmer? records))))
#+end_example

"Uniformly represent structures as sequences"; I miss when I was first learning Python list comprehension.

***** DONE Exercise 2.33
:PROPERTIES:
:CUSTOM_ID: exercise-2.33
:END:

Fill in the missing expressions to complete the following definitions of some basic list-manipulation operations as accumulations:

#+BEGIN_SRC scheme
(define (map p sequence)
  (accumulate (lambda (x y) <??>) nil sequence))

(define (append seq1 seq2)
  (accumulate cons <??> <??>))

(define (length sequence)
  (accumulate <??> 0 sequence))
#+END_SRC

#+BEGIN_SRC racket :noweb yes
#lang sicp

(define (accumulate op initial sequence)
  (if (null? sequence) initial (op (car sequence) (accumulate op initial (cdr sequence)))))

(define (map p sequence)
  (accumulate (lambda (x y) (cons (p x) y)) nil sequence))

(map (lambda (x) (* x x)) (list 1 2 3 4 5))

(define (append seq1 seq2)
  (accumulate cons seq2 seq1))

(append (list 1 2 3) (list 4 5 6))

(define (length sequence)
  (accumulate (lambda (x y) (+ 1 y))
              0
              sequence))

(length (list 1 2 3 4 5))
#+END_SRC

#+RESULTS:
: (1 4 9 16 25)
: (1 2 3 4 5 6)
: 5

***** DONE Exercise 2.34
:PROPERTIES:
:CUSTOM_ID: exercise-2.34
:END:

Evaluating a polynomial in x at a given value of x can be formulated as an accumulation.  We evaluate the polynomial

#+BEGIN_EXAMPLE
 a_n r^n | a_(n-1) r^(n-1) + ... + a_1 r + a_0
#+END_EXAMPLE

using a well-known algorithm called <<i178>> Horner's rule, which structures the computation as

#+BEGIN_EXAMPLE
 (... (a_n r + a_(n-1)) r + ... + a_1) r + a_0
#+END_EXAMPLE

In other words, we start with a_n, multiply by x, add a_(n-1), multiply by x, and so on, until we reach a_0.[fn:82]

Fill in the following template to produce a procedure that evaluates a polynomial using Horner's rule.  Assume that the coefficients of the polynomial are arranged in a sequence, from a_0 through a_n.

#+BEGIN_SRC scheme
(define (horner-eval x coefficient-sequence)
  (accumulate (lambda (this-coeff higher-terms) <??>)
              0
              coefficient-sequence))
#+END_SRC

For example, to compute 1 + 3x + 5x^3 + x^(5) at x = 2 you would evaluate

#+BEGIN_SRC scheme
(horner-eval 2 (list 1 3 0 5 0 1))
#+END_SRC

#+BEGIN_SRC racket :noweb yes
<<sicp>>

(define (horner-eval x coefficient-sequence)
  (accumulate (lambda (this-coeff higher-terms) (+ this-coeff (* x higher-terms))) 0 coefficient-sequence))

(horner-eval 2 (list 1 3 0 5 0 1))
#+END_SRC

#+RESULTS:
: 79

This came to me more easily once I thought carefully about the algebra, but I think I still need more practice.

Once again, the key here really is that the second argument to ~op~ (thus pay especial attention when you are defining a lambda here; use descriptive names) is where the rest of accumulation goes into: ~(accumulate op initial (cdr sequence))~. You want to take advantage of the recursiveness here.

***** DONE Exercise 2.35
:PROPERTIES:
:CUSTOM_ID: exercise-2.35
:END:

Redefine ~count-leaves~ from section [[#section-2.2.2][2.2.2]] as an accumulation:

#+BEGIN_SRC scheme
(define (count-leaves t)
  (accumulate <??> <??> (map <??> <??>)))
#+END_SRC

A reminder that it used to be:

#+BEGIN_SRC racket :noweb yes
#lang sicp

(define (count-leaves x)
  (cond
    [(null? x) 0]
    [(not (pair? x)) 1]
    [else (+ (count-leaves (car x)) (count-leaves (cdr x)))]))

(define x (cons (list 1 2) (list 3 4)))
(list x x)
(count-leaves (list x x))
#+END_SRC

#+RESULTS:
: (((1 2) 3 4) ((1 2) 3 4))
: 8

I mean, I guess you can just ~fringe~ and ~length~, but that's missing the point. Or maybe we are on to something...

#+BEGIN_SRC racket :noweb yes
<<sicp>>

(define (count-leaves t)
  (accumulate + 0 (map (lambda (x) 1) (enumerate-tree t))))

(define x (cons (list 1 2) (list 3 4)))
(list x x)
(count-leaves (list x x))
#+END_SRC

#+RESULTS:
: (((1 2) 3 4) ((1 2) 3 4))
: 8

Note that if you compare the implementation of ~length~ using accumulation:

#+BEGIN_SRC racket :noweb yes
(define (length sequence)
  (accumulate (lambda (x y) (+ 1 y)) 0 sequence))
#+END_SRC

You can see that what we did is basically ~fringe~ then ~length~, except that instead of adding 1 for each element, we changed all the elements to 1 using ~map~ (because the prompt has that) and then added them together.

***** DONE Exercise 2.36
:PROPERTIES:
:CUSTOM_ID: exercise-2.36
:END:

The procedure ~accumulate-n~ is similar to ~accumulate~ except that it takes as its third argument a sequence of sequences, which are all assumed to have the same number of elements.  It applies the designated accumulation procedure to combine all the first elements of the sequences, all the second elements of the sequences, and so on, and returns a sequence of the results.  For instance, if ~s~ is a sequence containing four sequences, ~((1 2 3) (4 5 6) (7 8 9) (10 11 12)),~ then the value of ~(accumulate-n + 0 s)~ should be the sequence ~(22 26 30)~.  Fill in the missing expressions in the following definition of ~accumulate-n~:

#+BEGIN_SRC scheme
(define (accumulate-n op init seqs)
  (if (null? (car seqs))
      nil
      (cons (accumulate op init <??>)
            (accumulate-n op init <??>))))
#+END_SRC

#+BEGIN_SRC racket :noweb yes
<<sicp>>

(define (accumulate-n op init seqs)
  (if (null? (car seqs))
      nil
      (cons (accumulate op init (map car seqs)) (accumulate-n op init (map cdr seqs)))))

(define s (list (list 1 2 3) (list 4 5 6) (list 7 8 9) (list 10 11 12)))
(accumulate-n + 0 s)
#+END_SRC

#+RESULTS:
: (22 26 30)

Lol this one is easy.

***** DONE Exercise 2.37
:PROPERTIES:
:CUSTOM_ID: exercise-2.37
:END:

Suppose we represent vectors v = (v_i) as sequences of numbers, and matrices m = (m_(ij)) as sequences of vectors (the rows of the matrix).  For example, the matrix

#+BEGIN_EXAMPLE
 +-         -+
 |  1 2 3 4  |
 |  4 5 6 6  |
 |  6 7 8 9  |
 +-         -+
#+END_EXAMPLE

is represented as the sequence ~((1 2 3 4) (4 5 6 6) (6 7 8 9))~.  With this representation, we can use sequence operations to concisely express the basic matrix and vector operations.  These operations (which are described in any book on matrix algebra) are the following:

#+BEGIN_EXAMPLE
                                        __
 (dot-product v w)      returns the sum >_i v_i w_i

 (matrix-*-vector m v)  returns the vector t,
                                    __
                        where t_i = >_j m_(ij) v_j

 (matrix-*-matrix m n)  returns the matrix p,
                                       __
                        where p_(ij) = >_k m_(ik) n_(kj)

 (transpose m)          returns the matrix n,
                        where n_(ij) = m_(ji)
#+END_EXAMPLE

We can define the dot product as[fn:83]

#+BEGIN_SRC scheme
(define (dot-product v w)
  (accumulate + 0 (map * v w)))
#+END_SRC

Fill in the missing expressions in the following procedures for computing the other matrix operations.  (The procedure ~accumulate-n~ is defined in [[#exercise-2.36][Exercise 2.36]].)

#+BEGIN_SRC scheme
(define (matrix-*-vector m v)
  (map <??> m))

(define (transpose mat)
  (accumulate-n <??> <??> mat))

(define (matrix-*-matrix m n)
  (let ((cols (transpose n)))
    (map <??> m)))
#+END_SRC

#+BEGIN_SRC racket :noweb yes
<<sicp>>

(define (dot-product v w)
  (accumulate + 0 (map * v w)))

;; new vector that has the dot product of each row with vector
(define (matrix-*-vector m v)
  (map (lambda (row) (dot-product row v)) m))

;; rows are columns of the original
(define (transpose mat)
  (accumulate-n cons nil mat))

;; dot products of each row with each col
(define (matrix-*-matrix m n)
  (let ([cols (transpose n)]) (map (lambda (row) (matrix-*-vector cols row)) m)))

(define mat (list (list 1 2 3 4) (list 4 5 6 6) (list 6 7 8 9)))
(define vec (list 1 1 1 1))
(matrix-*-vector mat vec)
(transpose mat)

(define m (list (list 1 2 3) (list 4 5 6)))
(define n (list (list 10 11) (list 20 21) (list 30 31)))
(matrix-*-matrix m n)
#+END_SRC

#+RESULTS:
: (10 21 30)
: ((1 4 6) (2 5 7) (3 6 8) (4 6 9))
: ((140 146) (320 335))

This turned out to be easier than I expected, mostly I suppose because you can model on the steps of math operations in a straightforward way.

***** DONE Exercise 2.38
:PROPERTIES:
:CUSTOM_ID: exercise-2.38
:END:

The ~accumulate~ procedure is also known as ~fold-right~, because it combines the first element of the sequence with the result of combining all the elements to the right.  There is also a ~fold-left~, which is similar to ~fold-right~, except that it combines elements working in the opposite direction:

#+BEGIN_SRC scheme
(define (fold-left op initial sequence)
  (define (iter result rest)
    (if (null? rest)
        result
        (iter (op result (car rest))
              (cdr rest))))
  (iter initial sequence))
#+END_SRC

What are the values of

#+BEGIN_SRC scheme
(fold-right / 1 (list 1 2 3))

(fold-left / 1 (list 1 2 3))

(fold-right list nil (list 1 2 3))

(fold-left list nil (list 1 2 3))
#+END_SRC

#+BEGIN_SRC racket :noweb yes
<<sicp>>

(define (fold-right op initial sequence)
  (accumulate op initial sequence))

(define (fold-left op initial sequence)
  (define (iter result rest)
    (if (null? rest) result (iter (op result (car rest)) (cdr rest))))
  (iter initial sequence))

;; 1 / (2 / (3 / 1))
(fold-right / 1 (list 1 2 3))
;; 1 / 1 / 2 / 3
(fold-left / 1 (list 1 2 3))
;; (list 1 (list 2 (list 3 (list nil))))
(fold-right list nil (list 1 2 3))
;; (list (list (list nil 1) 2) 3)
(fold-left list nil (list 1 2 3))
#+END_SRC

#+RESULTS:
: 3/2
: 1/6
: (1 (2 (3 ())))
: (((() 1) 2) 3)
: 3/8
: 2/3

Give a property that ~op~ should satisfy to guarantee that ~fold-right~ and ~fold-left~ will produce the same values for any sequence.

I think an easy answer is that ~op~ needs to be commutative so the order it is applied (i.e., first with ~initial~ and the last element of the list then to the front, or first with ~initial~ and the first element then to the back) does not matter.

Actually, associativity might also be needed because of all the parens involved for right fold vs left fold. Let's see the classic example of a commutative but not associative operation:

#+BEGIN_SRC racket :noweb yes
<<sicp>>

;; (1 * (2 * (3 * 0 + 1) + 1) + 1)
(fold-right (lambda (x y) (+ 1 (* x y))) 0 (list 1 2 3))
;; ((((0 * 1) + 1) * 2 + 1) * 3 + 1)
(fold-left (lambda (x y) (+ 1 (* x y))) 0 (list 1 2 3))
#+END_SRC

#+RESULTS:
: 4
: 10

Yeah...

***** DONE Exercise 2.39
:PROPERTIES:
:CUSTOM_ID: exercise-2.39
:END:

Complete the following definitions of ~reverse~ ([[#exercise-2.18][Exercise 2.18]]) in terms of ~fold-right~ and ~fold-left~ from [[#exercise-2.38][Exercise 2.38]]:

#+BEGIN_SRC scheme
(define (reverse sequence)
  (fold-right (lambda (x y) <??>) nil sequence))

(define (reverse sequence)
  (fold-left (lambda (x y) <??>) nil sequence))
#+END_SRC

#+BEGIN_SRC racket :noweb yes
<<sicp>>

(define (reverse-1 sequence)
  (fold-right (lambda (x y) (append y (list x))) nil sequence))

(define (reverse-2 sequence)
  (fold-left (lambda (x y) (append (cons y x))) nil sequence))

(reverse-1 (list 1 2 3 4 5))
(reverse-2 (list 1 2 3 4 5))
#+END_SRC

#+RESULTS:
: (5 4 3 2 1)
: (5 4 3 2 1)

Note that if you swap what you do, you get:

#+BEGIN_SRC racket :noweb yes
<<sicp>>

(define (reverse-1 sequence)
  (fold-right (lambda (x y) (append (cons y x))) nil sequence))

(define (reverse-2 sequence)
  (fold-left (lambda (x y) (append y (list x))) nil sequence))

(reverse-1 (list 1 2 3 4 5))
(reverse-2 (list 1 2 3 4 5))
#+END_SRC

#+RESULTS:
: mcar: contract violation
:   expected: mpair?
:   given: 1
:   context...:
:    /var/folders/df/yfqln53x483c62qh523nv6gw0000gn/T/ob-racket-zIPdFM/ob-racketMyXIyX.rkt:98:0
:    body of "/var/folders/df/yfqln53x483c62qh523nv6gw0000gn/T/ob-racket-zIPdFM/ob-racketMyXIyX.rkt"
: (((((() . 5) . 4) . 3) . 2) . 1)

because you can think what fold does as ~fold-right~ applying ~initial~ and the last element to ~op~, in this case making ~(nil . 5)~ and then go backward up the stack from there; and ~fold-left~ tries to append to ~1~ leading to error.

Wow you can define ~append~ (essentially) with ~fold-right~ too per SchemeWiki:

#+BEGIN_SRC racket :noweb yes
<<sicp>>

(define (push value sequence) 
   (fold-right cons (list value) sequence))

(define (reverse sequence)
  (fold-right push nil sequence))

;; (push 1 (push 2 (push 3 (push 4 (push 5 nil)))))
(reverse (list 1 2 3 4 5))
#+END_SRC

#+RESULTS:
: (5 4 3 2 1)

***** Nested Mappings

#+BEGIN_SRC racket :noweb yes
<<sicp>>

(define (generate-pairs n)
  (accumulate append
              nil
              (map (lambda (i) (map (lambda (j) (list i j)) (enumerate-interval 1 (- i 1))))
                   (enumerate-interval 1 n))))

(generate-pairs 5)
(newline)
(map (lambda (i) (map (lambda (j) (list i j)) (enumerate-interval 1 (- i 1))))
     (enumerate-interval 1 5))
(newline)
(map (lambda (i) (map (lambda (j) (list i j)) (enumerate-interval 1 i)))
     (enumerate-interval 1 5))
#+END_SRC

#+RESULTS:
: ((2 1) (3 1) (3 2) (4 1) (4 2) (4 3) (5 1) (5 2) (5 3) (5 4))
: 
: (() ((2 1)) ((3 1) (3 2)) ((4 1) (4 2) (4 3)) ((5 1) (5 2) (5 3) (5 4)))
: 
: (((1 1)) ((2 1) (2 2)) ((3 1) (3 2) (3 3)) ((4 1) (4 2) (4 3) (4 4)) ((5 1) (5 2) (5 3) (5 4) (5 5)))

So you can see the heavy lifting is in the nested ~map~.  If we look closely, for each number i in ~(enumerate-interval 1 n)~, the outer map maps it to ~
#+END_SRC

#+RESULTS:
: ((2 1) (3 1) (3 2) (4 1) (4 2) (4 3) (5 1) (5 2) (5 3) (5 4))
: (() ((2 1)) ((3 1) (3 2)) ((4 1) (4 2) (4 3)) ((5 1) (5 2) (5 3) (5 4)))

So you can see the heavy lifting is in the nested ~map~.  If we look closely, for each number i in ~(enumerate-interval 1 n)~, the outer map maps it to ~(enumerate-interval 1 (- i 1))~. For each number j in this inner sequence, the pair ~(list i j)~ is generated. In the pre-flatmapped form you can see clearly each list that corresponds to each i.

Also note that the requirement here is that 1 <= j < i <= n. If you don't decrement in the inner loop the result is also pretty straightforward.

Also let's have ~flatmap~ separately among other things:

#+BEGIN_SRC racket :noweb yes
#lang sicp

(define (accumulate op initial sequence)
  (if (null? sequence) initial (op (car sequence) (accumulate op initial (cdr sequence)))))

(define (flatmap proc seq)
  (accumulate append nil (map proc seq)))

(flatmap identity (list (list 1 2 3 (list 7 8 9 (list 10))) (list 4 5 6)))
#+END_SRC

#+RESULTS:
: (1 2 3 (7 8 9 (10)) 4 5 6)


#+BEGIN_SRC racket :noweb yes
<<sicp>>

(define (prime-sum? pair)
  (prime? (+ (car pair) (cadr pair))))

(define (make-pair-sum pair)
  (list (car pair) (cadr pair) (+ (car pair) (cadr pair))))

(define (prime-sum-pairs n)
  (map make-pair-sum
       (filter prime-sum?
               (flatmap (lambda (i) (map (lambda (j) (list i j)) (enumerate-interval 1 (- i 1))))
                        (enumerate-interval 1 n)))))

(prime-sum-pairs 6)
#+END_SRC

#+RESULTS:
: ((2 1 3) (3 2 5) (4 1 5) (4 3 7) (5 2 7) (6 1 7) (6 5 11))

#+BEGIN_SRC racket :noweb yes
<<sicp>>

(define (remove item sequence)
  (filter (lambda (x) (not (= x item))) sequence))

(define (permutations s)
  (if (null? s)
      (list nil)
      (flatmap (lambda (x) (map (lambda (p) (cons x p)) (permutations (remove x s)))) s)))

(permutations (list 1 2 3))
#+END_SRC

#+RESULTS:
: ((1 2 3) (1 3 2) (2 1 3) (2 3 1) (3 1 2) (3 2 1))

The idea is that for each x in S, you generate the permutations for S - x and then join x to the front. The base case is an empty set where the permutation is an empty list. The inductive step is that ~(cons x (permutations (remove x s)))~ is all the permutations of S that begin with x.

***** DONE Exercise 2.40
:PROPERTIES:
:CUSTOM_ID: exercise-2.40
:END:

Define a procedure ~unique-pairs~ that, given an integer n, generates the sequence of pairs (i,j) with 1 <= j< i <= n.  Use ~unique-pairs~ to simplify the definition of ~prime-sum-pairs~ given above.

#+BEGIN_SRC racket :noweb yes
<<sicp>>

(define (prime-sum? pair)
  (prime? (+ (car pair) (cadr pair))))

(define (make-pair-sum pair)
  (list (car pair) (cadr pair) (+ (car pair) (cadr pair))))

(define (unique-pairs n)
  (flatmap (lambda (i) (map (lambda (j) (list i j)) (enumerate-interval 1 (- i 1))))
           (enumerate-interval 1 n)))

(define (prime-sum-pairs n)
  (map make-pair-sum (filter prime-sum? (unique-pairs n))))

(prime-sum-pairs 6)
#+END_SRC

#+RESULTS:
: ((2 1 3) (3 2 5) (4 1 5) (4 3 7) (5 2 7) (6 1 7) (6 5 11))

Good editor practice for moving an sexp around.

***** DONE Exercise 2.41
:PROPERTIES:
:CUSTOM_ID: exercise-2.41
:END:

Write a procedure to find all ordered triples of distinct positive integers i, j, and k less than or equal to a given integer n that sum to a given integer s.

So it seems like we might just need minor modifications to the previous solution:

#+BEGIN_SRC racket :noweb yes
<<sicp>>

(define (unique-pairs n)
  (flatmap (lambda (i)
             (flatmap (lambda (j) (map (lambda (k) (list i j k)) (enumerate-interval 1 (- i 2))))
                  (enumerate-interval 1 (- i 1))))
           (enumerate-interval 1 n)))

(define (sum-to-triples n s)
  (filter (lambda (triple) (= s (accumulate + 0 triple))) (unique-pairs n)))

(unique-pairs 5)

(sum-to-triples 5 7)
#+END_SRC

#+RESULTS:
: ((3 1 1) (3 2 1) (4 1 1) (4 1 2) (4 2 1) (4 2 2) (4 3 1) (4 3 2) (5 1 1) (5 1 2) (5 1 3) (5 2 1) (5 2 2) (5 2 3) (5 3 1) (5 3 2) (5 3 3) (5 4 1) (5 4 2) (5 4 3))
: ((4 1 2) (4 2 1) (5 1 1))

Does this work? No, because i, j, k need to be distinct. I suppose it gets harder this part...

But wait; instead of mauling the inside of ~unique-pairs~, maybe it can be part of a recursive solution? Obviously it does what it says it does for generating pairs, and if our previous experience generating permutations shines any light on this...actually let's look at ~permutation~ again:

#+BEGIN_SRC racket :noweb yes
<<sicp>>

(define (remove item sequence)
  (filter (lambda (x) (not (= x item))) sequence))

(define (permutations s)
  (if (null? s)
      (list nil)
      (flatmap (lambda (x) (map (lambda (p) (cons x p)) (permutations (remove x s)))) s)))

(permutations (list 1 2 3))
#+END_SRC

If you can generate all permutations of S by, for every x in S, generating all permutations of S - x and adding x to it, perhaps we can generate all the unique n tuples of i, j, k <= n by, for every k <= n, generating all the unique pairs of i, j < k and adding k to it.

Actually, I said not changing ~unique-pairs~ and using it, but it might be better to generalize this like ~permutations~:

#+BEGIN_SRC racket :noweb yes
<<sicp>>

(define (unique-k-tuples n k)
  (cond
    [(= 0 k) (list nil)]
    [else
     (flatmap (lambda (x) (map (lambda (tuples) (cons x tuples)) (unique-k-tuples (- x 1) (- k 1))))
              (enumerate-interval 1 n))]))

(define (sum-to-triples n s)
  (filter (lambda (triple) (= s (accumulate + 0 triple))) (unique-k-tuples n 3)))

(unique-k-tuples 5 3)

(sum-to-triples 5 7)
#+END_SRC

#+RESULTS:
: ((3 2 1) (4 2 1) (4 3 1) (4 3 2) (5 2 1) (5 3 1) (5 3 2) (5 4 1) (5 4 2) (5 4 3))
: ((4 2 1))

Yay! It's ended up being very similar to ~permutations~.

***** DONE Exercise 2.42
:PROPERTIES:
:CUSTOM_ID: exercise-2.42
:END:

The "eight-queens puzzle" asks how to place eight queens on a chessboard so that no queen is in check from any other (i.e., no two queens are in the same row, column, or diagonal).  One possible solution is shown in [[figure-2.8][Figure 2.8]].  One way to solve the puzzle is to work across the board, placing a queen in each column.  Once we have placed k - 1 queens, we must place the kth queen in a position where it does not check any of the queens already on the board.  We can formulate this approach recursively: Assume that we have already generated the sequence of all possible ways to place k - 1 queens in the first k - 1 columns of the board.  For each of these ways, generate an extended set of positions by placing a queen in each row of the kth column.  Now filter these, keeping only the positions for which the queen in the kth column is safe with respect to the other queens.  This produces the sequence of all ways to place k queens in the first k columns.  By continuing this process, we will produce not only one solution, but all solutions to the puzzle.

<<figure-2.8>> A solution to the eight-queens puzzle.

#+BEGIN_EXAMPLE
 +---+---+---+---+---+---+---+---+
 |   |   |   |   |   | Q |   |   |
 +---+---+---+---+---+---+---+---+
 |   |   | Q |   |   |   |   |   |
 +---+---+---+---+---+---+---+---+
 | Q |   |   |   |   |   |   |   |
 +---+---+---+---+---+---+---+---+
 |   |   |   |   |   |   | Q |   |
 +---+---+---+---+---+---+---+---+
 |   |   |   |   | Q |   |   |   |
 +---+---+---+---+---+---+---+---+
 |   |   |   |   |   |   |   | Q |
 +---+---+---+---+---+---+---+---+
 |   | Q |   |   |   |   |   |   |
 +---+---+---+---+---+---+---+---+
 |   |   |   | Q |   |   |   |   |
 +---+---+---+---+---+---+---+---+
#+END_EXAMPLE

We implement this solution as a procedure ~queens~, which returns a sequence of all solutions to the problem of placing n queens on an n*n chessboard.  ~queens~ has an internal procedure ~queen-cols~ that returns the sequence of all ways to place queens in the first k columns of the board.

#+BEGIN_SRC scheme
(define (queens board-size)
  (define (queen-cols k)
    (if (= k 0)
        (list empty-board)
        (filter
         (lambda (positions) (safe? k positions))
         (flatmap
          (lambda (rest-of-queens)
            (map (lambda (new-row)
                   (adjoin-position new-row k rest-of-queens))
                 (enumerate-interval 1 board-size)))
          (queen-cols (- k 1))))))
  (queen-cols board-size))
#+END_SRC

In this procedure ~rest-of-queens~ is a way to place k - 1 queens in the first k - 1 columns, and ~new-row~ is a proposed row in which to place the queen for the kth column.  Complete the program by implementing the representation for sets of board positions, including the procedure ~adjoin-position~, which adjoins a new row-column position to a set of positions, and ~empty-board~, which represents an empty set of positions.  You must also write the procedure ~safe?~, which determines for a set of positions, whether the queen in the kth column is safe with respect to the others.  (Note that we need only check whether the new queen is safe--the other queens are already guaranteed safe with respect to each other.)

I suppose this is a hard problem, so the solution is again partially written for us.

Actually, I wonder if the matrix stuff we did earlier might help here...

#+BEGIN_SRC racket :noweb yes
<<sicp>>

(define empty-board nil)

(define (adjoin-position row col others)
  (cons (cons row col) others))

(define (get-row position)
  (car position))

(define (get-col position)
  (cdr position))

(define (relatively-safe? q1 q2)
  (let ([rq1 (get-row q1)] [cq1 (get-col q1)] [rq2 (get-row q2)] [cq2 (get-col q2)])
    (and (not (= rq1 rq2)) (not (= cq1 cq2)) (not (= (abs (- rq1 rq2)) (abs (- cq1 cq2)))))))

(define (safe? k positions)
  (let ([test (car (filter (lambda (position) (= (get-col position) k)) positions))])
    (let ([others (filter (lambda (position)
                            (not (and (= (get-row position) (get-row test))
                                      (= (get-col position) (get-col test)))))
                          positions)])
      (null? (filter (lambda (other) (not ( relatively-safe? test other))) others)))))

(define (queens board-size)
  (define (queen-cols k)
    (if (= k 0)
        (list empty-board)
        (filter (lambda (positions) (safe? k positions))
                (flatmap (lambda (rest-of-queens)
                           (map (lambda (new-row) (adjoin-position new-row k rest-of-queens))
                                (enumerate-interval 1 board-size)))
                         (queen-cols (- k 1))))))
  (queen-cols board-size))

(queens 0)
(queens 1)
(queens 2)
(queens 3)
(queens 4)
(length (queens 8))
#+END_SRC

#+RESULTS:
: (())
: (((1 . 1)))
: ()
: ()
: (((3 . 4) (1 . 3) (4 . 2) (2 . 1)) ((2 . 4) (4 . 3) (1 . 2) (3 . 1)))
: 92

Very cool! But still I don't think I know how to solve the problem all by myself now. Need to think more carefully about the implementation of ~queens~.

So firstly, ~queen-cols~ does what ~queens~ is supposed to do as ~queens~ just passes the arguments along, with one major difference that it can access the original ~board-size~ passed to ~queens~ during the recursive calls, which allows it to "return the sequence of all ways to place queens in the first /k/ columns of the board".

The base case of ~queen-cols~ is that \(k = 0\), for which there is no valid placement and the empty board is returned. The inductive step is that, if we have placed \(k - 1\) queens safely in the first \(k - 1\) columns, we know how to place the kth queen in the kth column safely, just by checking if it's safe with respect to all previous queens.

Now in ~queen-cols~, this is accomplished by generating the position for each row in the kth column, add this position to the list of the positions of all previous queens, then filter out the the list of positions where the kth queen is safe with respect to all the others.

Note that ~flatmap~ was used because ~queen-cols~ returns a list of lists of valid placements (for \(k - 1\) queens). Each valid list of placements for \(k - 1\) queens is mapped to a list of lists of placements for \(k\) queens, which may or may not be safe. The flatmap removed the nestedness here so we just have a list of placements for \(k\) queens that can be filtered.

To be honest the whole "picking out the queen in the kth column" affair that ~safe?~ needs to do ends up feelin for more sophisticated abstraction.

***** DONE Exercise 2.43
:PROPERTIES:
:CUSTOM_ID: exercise-2.43
:END:

Louis Reasoner is having a terrible time doing [[#exercise-2.42][Exercise 2.42]].  His ~queens~ procedure seems to work, but it runs extremely slowly.  (Louis never does manage to wait long enough for it to solve even the 6*6 case.)  When Louis asks Eva Lu Ator for help, she points out that he has interchanged the order of the nested mappings in the ~flatmap~, writing it as

#+BEGIN_SRC scheme
(flatmap
 (lambda (new-row)
   (map (lambda (rest-of-queens)
          (adjoin-position new-row k rest-of-queens))
        (queen-cols (- k 1))))
 (enumerate-interval 1 board-size))
#+END_SRC

Explain why this interchange makes the program run slowly.  Estimate how long it will take Louis's program to solve the eight-queens puzzle, assuming that the program in [[#exercise-2.42][Exercise 2.42]] solves the puzzle in time T.

Let's first compare it with the original nested mapping order:

#+BEGIN_SRC racket :noweb yes
#lang sicp

(flatmap (lambda (rest-of-queens)
           (map (lambda (new-row) (adjoin-position new-row k rest-of-queens))
                (enumerate-interval 1 board-size)))
         (queen-cols (- k 1)))
#+END_SRC

Now we see the problem. What the interchange does is that for every row of the board at the kth column, it generates all safe placements for \(k - 1\) columns, then adds the new position on the kth column to it. The obvious problem is that while the original only calls ~queen-cols~ the number of columns there are *overall* (and only once each recursive step), this version calls it the number of squares there are, *in each recursive step*.

Now how long ~queen-cols~ takes each time it is called is a more delicate question. But I think it is quite safe to say that this version is exponential while the original is factorial. I feel I can't give a good numerical answer here as I haven't considered it more carefully, but I'd just say this version might take \(8^8 / 8! = 416.102\) T to run.

**** DONE 2.2.4 Example: A Picture Language

Unfortunately it seems like it is better to just use DrRacket here...

#+BEGIN_SRC racket
#lang sicp
(#%require sicp-pict)

;; https://www.reddit.com/r/Racket/comments/ieuk66/how_to_save_image_to_file_with_sicppict/
(define wave
  (segments->painter (list (make-segment (make-vect 0.20 0.00) (make-vect 0.35 0.50))
                           (make-segment (make-vect 0.35 0.50) (make-vect 0.30 0.60))
                           (make-segment (make-vect 0.30 0.60) (make-vect 0.15 0.45))
                           (make-segment (make-vect 0.15 0.45) (make-vect 0.00 0.60))
                           (make-segment (make-vect 0.00 0.80) (make-vect 0.15 0.65))
                           (make-segment (make-vect 0.15 0.65) (make-vect 0.30 0.70))
                           (make-segment (make-vect 0.30 0.70) (make-vect 0.40 0.70))
                           (make-segment (make-vect 0.40 0.70) (make-vect 0.35 0.85))
                           (make-segment (make-vect 0.35 0.85) (make-vect 0.40 1.00))
                           (make-segment (make-vect 0.60 1.00) (make-vect 0.65 0.85))
                           (make-segment (make-vect 0.65 0.85) (make-vect 0.60 0.70))
                           (make-segment (make-vect 0.60 0.70) (make-vect 0.75 0.70))
                           (make-segment (make-vect 0.75 0.70) (make-vect 1.00 0.40))
                           (make-segment (make-vect 1.00 0.20) (make-vect 0.60 0.48))
                           (make-segment (make-vect 0.60 0.48) (make-vect 0.80 0.00))
                           (make-segment (make-vect 0.40 0.00) (make-vect 0.50 0.30))
                           (make-segment (make-vect 0.50 0.30) (make-vect 0.60 0.00)))))

(define wave2 (beside wave (flip-vert wave)))

(define wave4 (below wave2 wave2))

(paint wave)
(paint wave2)
(paint wave4)
#+END_SRC

#+BEGIN_SRC racket :noweb yes
(define (flipped-pairs painter)
  (let ([painter2 (beside painter (flip-vert painter))]) (below painter2 painter2)))

(define wave4 (flipped-pairs wave))
#+END_SRC

#+BEGIN_SRC racket :noweb yes
(define (right-split painter n)
  (if (= n 0)
      painter
      (let ([smaller (right-split painter (- n 1))]) (beside painter (below smaller smaller)))))

(define (corner-split painter n)
  (if (= n 0)
      painter
      (let ([up (up-split painter (- n 1))] [right (right-split painter (- n 1))])
        (let ([top-left (beside up up)]
              [bottom-right (below right right)]
              [corner (corner-split painter (- n 1))])
          (beside (below painter top-left) (below bottom-right corner))))))

(define (square-limit painter n)
  (let ([quarter (corner-split painter n)])
    (let ([half (beside (flip-horiz quarter) quarter)]) (below (flip-vert half) half))))
#+END_SRC

***** DONE Exercise 2.44
:PROPERTIES:
:CUSTOM_ID: exercise-2.44
:END:

Define the procedure ~up-split~ used by ~corner-split~.  It is similar to ~right-split~, except that it switches the roles of ~below~ and ~beside~.

#+BEGIN_SRC racket :noweb yes
(define (up-split painter n)
  (if (= n 0)
      painter
      (let ([smaller (up-split painter (- n 1))]) (below painter (beside smaller smaller)))))
#+END_SRC

***** Higher-order operations

#+BEGIN_SRC racket :noweb yes
(define (square-of-four tl tr bl br)
  (lambda (painter)
    (let ([top (beside (tl painter) (tr painter))] [bottom (beside (bl painter) (br painter))])
      (below bottom top))))

(define (flipped-pairs painter)
  (let ([combine4 (square-of-four identity flip-vert identity flip-vert)]) (combine4 painter)))

(define (square-limit painter n)
  (let ([combine4 (square-of-four flip-horiz identity rotate180 flip-vert)])
    (combine4 (corner-split painter n))))
#+END_SRC

***** DONE Exercise 2.45
:PROPERTIES:
:CUSTOM_ID: exercise-2.45
:END:

~right-split~ and ~up-split~ can be expressed as instances of a general splitting operation.  Define a procedure ~split~ with the property that evaluating

#+BEGIN_SRC scheme
(define right-split (split beside below))
(define up-split (split below beside))
#+END_SRC

produces procedures ~right-split~ and ~up-split~ with the same behaviors as the ones already defined.

#+BEGIN_SRC racket :noweb yes
(define (split layout1 layout2)
  (define (f painter n)
    (if (= n 0)
        painter
        (let ([smaller (f painter (- n 1))]) (layout1 painter (layout2 smaller smaller)))))
  f)

(define right-split (split beside below))
(define up-split (split below beside))
#+END_SRC

***** Frames

This is a good callback to the part in Chapter 1? about describing 2D rectangles.

#+BEGIN_SRC racket :noweb yes

(define (frame-coord-map frame)
  (lambda (v)
    (add-vect (origin-frame frame)
              (add-vect (scale-vect (xcor-vect v) (edge1-frame frame))
                        (scale-vect (ycor-vect v) (edge2-frame frame))))))
#+END_SRC

***** DONE Exercise 2.46
:PROPERTIES:
:CUSTOM_ID: exercise-2.46
:END:

A two-dimensional vector v running from the origin to a point can be represented as a pair consisting of an x-coordinate and a y-coordinate.  Implement a data abstraction for vectors by giving a constructor ~make-vect~ and corresponding selectors ~xcor-vect~ and ~ycor-vect~.  In terms of your selectors and constructor, implement procedures ~add-vect~, ~sub-vect~, and ~scale-vect~ that perform the operations vector addition, vector subtraction, and multiplying a vector by a scalar:

#+BEGIN_EXAMPLE
 (x_1, y_1) + (x_2, y_2) = (x_1 + x_2, y_1 + y_2)
 (x_1, y_1) - (x_2, y_2) = (x_1 - x_2, y_1 - y_2)
              s * (x, y) = (sx, sy)
#+END_EXAMPLE

#+BEGIN_SRC racket :noweb yes
#lang sicp

(define (make-vect x y)
  (cons x y))

(define (xcor-vect v)
  (car v))

(define (ycor-vect v)
  (cdr v))

(define (add-vect v w)
  (make-vect (+ (xcor-vect v) (xcor-vect w)) (+ (ycor-vect v) (ycor-vect w))))

(define (sub-vect v w)
  (make-vect (- (xcor-vect v) (xcor-vect w)) (- (ycor-vect v) (ycor-vect w))))

(define (scale-vect v s)
  (make-vect (* s (xcor-vect v)) (* s (ycor-vect v))))
#+END_SRC

***** DONE Exercise 2.47
:PROPERTIES:
:CUSTOM_ID: exercise-2.47
:END:

Here are two possible constructors for frames:

#+BEGIN_SRC scheme
(define (make-frame origin edge1 edge2)
  (list origin edge1 edge2))

(define (make-frame origin edge1 edge2)
  (cons origin (cons edge1 edge2)))
#+END_SRC

For each constructor supply the appropriate selectors to produce an implementation for frames.

#+BEGIN_SRC racket :noweb yes
#lang sicp

(define (make-frame origin edge1 edge2)
  (list origin edge1 edge2))

(define (origin-frame frame)
  (car frame))

(define (edge1-frame frame)
  (cadr frame))

(define (edge2-frame frame)
  (caddr frame))
#+END_SRC

#+BEGIN_SRC racket :noweb yes
#lang sicp

(define (make-frame origin edge1 edge2)
  (cons origin (cons edge1 edge2)))

(define (origin-frame frame)
  (car frame))

(define (edge1-frame frame)
  (cadr frame))

(define (edge2-frame frame)
  (cddr frame))
#+END_SRC

***** Painters

#+BEGIN_SRC racket :noweb yes
#lang sicp

(define (segments->painter segment-list)
  (lambda (frame)
    (for-each (lambda (segment)
                (draw-line ((frame-coord-map frame) (start-segment segment))
                           ((frame-coord-map frame) (end-segment segment))))
              segment-list)))
#+END_SRC

***** DONE Exercise 2.48
:PROPERTIES:
:CUSTOM_ID: exercise-2.48
:END:

A directed line segment in the plane can be represented as a pair of vectors--the vector running from the origin to the start-point of the segment, and the vector running from the origin to the end-point of the segment.  Use your vector representation from [[#exercise-2.46][Exercise 2.46]] to define a representation for segments with a constructor ~make-segment~ and selectors ~start-segment~ and ~end-segment~.

#+BEGIN_SRC racket :noweb yes
#lang sicp

(define (make-segment start end)
  (cons start end))

(define (start-segment segment)
  (car segment))

(define (end-segment segment)
  (cdr segment))
#+END_SRC

***** DONE Exercise 2.49
:PROPERTIES:
:CUSTOM_ID: exercise-2.49
:END:

Use ~segments->painter~ to define the following primitive painters:

a. The painter that draws the outline of the designated frame.

b. The painter that draws an "X" by connecting opposite corners of the frame.

c. The painter that draws a diamond shape by connecting the midpoints of the sides of the frame.

d. The ~wave~ painter.

This is why I don't like these exercises. It's hard to get the tooling right & it's sequenced in a way that shows high level details first then asks you to implement the simple things, and still you might not have something runnable.

If you are using the SICP package for Racket, unless you want to implement ~drawline~, etc. yourself, you need to use their API and not the things implemented in the previous exercises.

#+BEGIN_SRC racket :noweb yes

(define outline
  (segments->painter (list (segment (vect 0 0) (vect 0 1))
                           (segment (vect 0 0) (vect 1 0))
                           (segment (vect 1 1) (vect 0 1))
                           (segment (vect 1 1) (vect 1 0)))))

(define cross
  (segments->painter (list (segment (vect 0 0) (vect 1 1)) (segment (vect 0 1) (vect 1 0)))))

(define diamond
  (segments->painter (list (segment (vect 0 0.5) (vect 1 0.5))
                           (segment (vect 0.5 0) (vect 0.5 1))
                           (segment (vect 0 0.5) (vect 0.5 1))
                           (segment (vect 0.5 0) (vect 1 0.5))
                           (segment (vect 0 0.5) (vect 0.5 0))
                           (segment (vect 0.5 1) (vect 1 0.5)))))
#+END_SRC

I am really not in the mood of defining ~wave~ by hand so here's one with coordinates I saw on [[https://www.reddit.com/r/Racket/comments/ieuk66/how_to_save_image_to_file_with_sicppict/][Reddit]]:

#+BEGIN_SRC racket :noweb yes
#lang sicp
(#%require sicp-pict)

(define wave
  (segments->painter (list (segment (vect 0.20 0.00) (vect 0.35 0.50))
                           (segment (vect 0.35 0.50) (vect 0.30 0.60))
                           (segment (vect 0.30 0.60) (vect 0.15 0.45))
                           (segment (vect 0.15 0.45) (vect 0.00 0.60))
                           (segment (vect 0.00 0.80) (vect 0.15 0.65))
                           (segment (vect 0.15 0.65) (vect 0.30 0.70))
                           (segment (vect 0.30 0.70) (vect 0.40 0.70))
                           (segment (vect 0.40 0.70) (vect 0.35 0.85))
                           (segment (vect 0.35 0.85) (vect 0.40 1.00))
                           (segment (vect 0.60 1.00) (vect 0.65 0.85))
                           (segment (vect 0.65 0.85) (vect 0.60 0.70))
                           (segment (vect 0.60 0.70) (vect 0.75 0.70))
                           (segment (vect 0.75 0.70) (vect 1.00 0.40))
                           (segment (vect 1.00 0.20) (vect 0.60 0.48))
                           (segment (vect 0.60 0.48) (vect 0.80 0.00))
                           (segment (vect 0.40 0.00) (vect 0.50 0.30))
                           (segment (vect 0.50 0.30) (vect 0.60 0.00)))))
#+END_SRC

***** Transforming and combining painters

#+BEGIN_SRC racket :noweb yes
#lang sicp

(define (transform-painter painter origin corner1 corner2)
  (lambda (frame)
    (let ([m (frame-coord-map frame)])
      (let ([new-origin (m origin)])
        (painter (make-frame new-origin
                             (sub-vect (m corner1) new-origin)
                             (sub-vect (m corner2) new-origin)))))))

(define (flip-vert painter)
  (transform-painter painter (make-vect 0.0 1.0) (make-vect 1.0 1.0) (make-vect 0.0 0.0)))

(define (shrink-to-upper-right painter)
  (transform-painter painter (make-vect 0.0 0.5) (make-vect 1.0 0.5) (make-vect 0.5 1.0)))

(define (rotate90 painter)
  (transform-painter painter (make-vect 1.0 0.0) (make-vect 1.0 1.0) (make-vect 0.0 0.0)))

(define (squash-inwards painter)
  (transform-painter painter (make-vect 0.0 0.0) (make-vect 0.65 0.35) (make-vect 0.35 0.65)))

(define (beside painter1 painter2)
  (let ([split-point (make-vect 0.5 0.0)])
    (let ([paint-left
           (transform-painter painter1 (make-vect 0.0 0.0) split-point (make-vect 0.0 1.0))]
          [paint-right
           (transform-painter painter2 split-point (make-vect 1.0 0.0) (make-vect 0.5 1.0))])
      (lambda (frame)
        (paint-left frame)
        (paint-right frame)))))
#+END_SRC

***** DONE Exercise 2.50
:PROPERTIES:
:CUSTOM_ID: exercise-2.50
:END:

Define the transformation ~flip-horiz~, which flips painters horizontally, and transformations that rotate painters counterclockwise by 180 degrees and 270 degrees.

#+BEGIN_SRC racket :noweb yes
#lang sicp

(define (flip-horiz painter)
  (transform-painter painter (vect 1 0) (vect 0 0) (vect 1 1)))

(define (compose f g)
  (lambda (x) (f (g x))))

(define (repeated f n)
  (if (<= n 1) f (compose f (repeated f (- n 1)))))

(define (rotate90 painter)
  (transform-painter painter (vect 1.0 0.0) (vect 1.0 1.0) (vect 0.0 0.0)))

(define (rotate180 painter)
  ((repeated rotate90 2) painter))

(define (rotate270 painter)
  ((repeated rotate90 3) painter))
#+END_SRC

***** DONE Exercise 2.51
:PROPERTIES:
:CUSTOM_ID: exercise-2.51
:END:

Define the ~below~ operation for painters.  ~below~ takes two painters as arguments.  The resulting painter, given a frame, draws with the first painter in the bottom of the frame and with the second painter in the top.  Define ~below~ in two different ways--first by writing a procedure that is analogous to the ~beside~ procedure given above, and again in terms of ~beside~ and suitable rotation operations (from [[#exercise-2.50][Exercise 2.50]]).

#+BEGIN_SRC racket :noweb yes
(define (below painter1 painter2)
  (let ([split-point (vect 0 0.5)])
    (let ([paint-top (transform-painter painter1 split-point (vect 1 0.5) (vect 0 1))]
          [paint-bottom (transform-painter painter2 (vect 0 0) (vect 1 0) split-point)])
      (lambda (frame)
        (paint-top frame)
        (paint-bottom frame)))))
#+END_SRC

#+BEGIN_SRC racket :noweb yes
#lang sicp

(define (below painter1 painter2)
  (rotate90 (beside (rotate270 painter2) (rotate270 painter1))))
#+END_SRC

Haha the second one is fun.

***** Levels of language for robust design
***** DONE Exercise 2.52
:PROPERTIES:
:CUSTOM_ID: exercise-2.52
:END:

Make changes to the square limit of ~wave~ shown in [[figure-2.9][Figure 2.9]] by working at each of the levels described above.  In particular:

a. Add some segments to the primitive ~wave~ painter of [[#exercise-2.49][Exercise 2.49]] (to add a smile, for example).

b. Change the pattern constructed by ~corner-split~ (for example, by using only one copy of the ~up-split~ and ~right-split~ images instead of two).

c. Modify the version of ~square-limit~ that uses ~square-of-four~ so as to assemble the corners in a different pattern.  (For example, you might make the big Mr.  Rogers look outward from each corner of the square.)

#+BEGIN_SRC racket :noweb yes
(define wave
  (segments->painter (list (segment (vect 0.20 0.00) (vect 0.35 0.50))
                           (segment (vect 0.35 0.50) (vect 0.30 0.60))
                           (segment (vect 0.30 0.60) (vect 0.15 0.45))
                           (segment (vect 0.15 0.45) (vect 0.00 0.60))
                           (segment (vect 0.00 0.80) (vect 0.15 0.65))
                           (segment (vect 0.15 0.65) (vect 0.30 0.70))
                           (segment (vect 0.30 0.70) (vect 0.40 0.70))
                           (segment (vect 0.40 0.70) (vect 0.35 0.85))
                           (segment (vect 0.35 0.85) (vect 0.40 1.00))
                           (segment (vect 0.60 1.00) (vect 0.65 0.85))
                           (segment (vect 0.65 0.85) (vect 0.60 0.70))
                           (segment (vect 0.60 0.70) (vect 0.75 0.70))
                           (segment (vect 0.75 0.70) (vect 1.00 0.40))
                           (segment (vect 1.00 0.20) (vect 0.60 0.48))
                           (segment (vect 0.60 0.48) (vect 0.80 0.00))
                           (segment (vect 0.40 0.00) (vect 0.50 0.30))
                           (segment (vect 0.50 0.30) (vect 0.60 0.00))
                           (segment (vect 0.42 0.75) (vect 0.50 0.70))
                           (segment (vect 0.50 0.70) (vect 0.58 0.75))
                           (segment (vect 0.42 0.90) (vect 0.43 0.85))
                           (segment (vect 0.56 0.90) (vect 0.55 0.85)))))

(define (split layout1 layout2)
  (define (f painter n)
    (if (= n 0)
        painter
        (let ([smaller (f painter (- n 1))]) (layout1 painter (layout2 smaller smaller)))))
  f)

(define right-split (split beside below))
(define up-split (split below beside))

(define (corner-split painter n)
  (if (= n 0)
      painter
      (let ([up (up-split painter (- n 1))]
            [right (right-split painter (- n 1))]
            [corner (corner-split painter (- n 1))])
        (beside (below painter up) (below right corner)))))

(define (square-of-four tl tr bl br)
  (lambda (painter)
    (let ([top (beside (tl painter) (tr painter))] [bottom (beside (bl painter) (br painter))])
      (below bottom top))))

(define (square-limit painter n)
  (let ([combine4 (square-of-four flip-vert rotate180 identity flip-horiz)])
    (combine4 (corner-split painter n))))
#+END_SRC

Have to say I really have not been enjoying this too much. Just a bit too finicky...

*** DONE 2.3 Symbolic Data
**** DONE 2.3.1 Quotation

#+BEGIN_SRC racket :noweb yes
#lang sicp

(define a 1)
(define b 2)

(list a b)

(list 'a 'b)

(list 'a b)

(car '(a b c))
(cdr '(a b c))

'()

(eq? '() nil)
#+END_SRC

#+RESULTS:
: (1 2)
: (a b)
: (a 2)
: a
: (b c)
: ()
: #t

#+BEGIN_SRC racket :noweb yes
#lang sicp

(define (memq item x)
  (cond
    [(null? x) false]
    [(eq? item (car x)) x]
    [else (memq item (cdr x))]))

(memq 'apple '(pear banana pune))

(memq 'apple '(x (apple sauce) y apple pear))
#+END_SRC

#+RESULTS:
: #f
: (apple pear)

***** DONE Exercise 2.53
:PROPERTIES:
:CUSTOM_ID: exercise-2.53
:END:

What would the interpreter print in response to evaluating each of the following expressions?

#+BEGIN_SRC scheme
(list 'a 'b 'c)

(list (list 'george))

(cdr '((x1 x2) (y1 y2)))

(cadr '((x1 x2) (y1 y2)))

(pair? (car '(a short list)))

(memq 'red '((red shoes) (blue socks)))

(memq 'red '(red shoes blue socks))
#+END_SRC

#+BEGIN_SRC racket :noweb yes
#lang sicp

(list 'a 'b 'c)

(list (list 'george))

(car '((x1 x2) (y1 y2)))

(cdr '((x1 x2) (y1 y2)))

(cadr '((x1 x2) (y1 y2)))

(car '(a short list))

(pair? (car '(a short list)))

(memq 'red '((red shoes) (blue socks)))

(memq 'red '(red shoes blue socks))
#+END_SRC

#+RESULTS:
: (a b c)
: ((george))
: (x1 x2)
: ((y1 y2))
: (y1 y2)
: a
: #f
: #f
: (red shoes blue socks)

Later note: note that ~cdr~ on a list always returns a list; ~nil~ (empty list) is a list, but is not a pair!

#+BEGIN_SRC racket :noweb yes
#lang sicp

(cdr (list 1))

(list? (cdr (list 1)))

(list? 'a)

(list? '(a))

(car '(a))

(cdr '(a))

(cdr '(a b))
#+END_SRC

#+RESULTS:
: ()
: #t
: #f
: #t
: a
: ()
: (b)

***** DONE Exercise 2.54
:PROPERTIES:
:CUSTOM_ID: exercise-2.54
:END:

Two lists are said to be ~equal?~ if they contain equal elements arranged in the same order.  For example,

#+BEGIN_SRC scheme
(equal? '(this is a list) '(this is a list))
#+END_SRC

is true, but

#+BEGIN_SRC scheme
(equal? '(this is a list) '(this (is a) list))
#+END_SRC

is false.  To be more precise, we can define ~equal?~ recursively in terms of the basic ~eq?~ equality of symbols by saying that ~a~ and ~b~ are ~equal?~ if they are both symbols and the symbols are ~eq?~, or if they are both lists such that ~(car a)~ is ~equal?~ to ~(car b)~ and ~(cdr a)~ is ~equal?~ to ~(cdr b)~.  Using this idea, implement ~equal?~ as a procedure.[fn:102]

#+BEGIN_SRC racket :noweb yes
#lang sicp

(define (equal? l1 l2)
  (cond
    [(and (null? l1) (null? l2)) #t]
    [(and (not (list? l1)) (not (list? l2))) (eq? l1 l2)]
    [(and (list? l1) (list? l2)) (and (eq? (car l1) (car l2)) (equal? (cdr l1) (cdr l2)))]
    [else #f]))

(equal? '(this is a list) '(this is a list))

(equal? '(this is a list) '(this (is a) list))
#+END_SRC

#+RESULTS:
: #t
: #t
: #f

Turns out:

#+BEGIN_SRC racket :noweb yes
#lang sicp

(list? nil)
#+END_SRC

#+RESULTS:
: #t

which made it somewhat difficult. Let's see if we can reduce the number of checks. Hmm I wonder:

#+BEGIN_SRC racket :noweb yes
#lang sicp

(pair? nil)
#+END_SRC

#+RESULTS:
: #f

Ah, because ~nil~ is the empty list and is a list!

One more thing, what does applying ~eq?~ anyway on two lists look like? A list and a symbol?

#+BEGIN_SRC racket :noweb yes
#lang sicp

(eq? 1 (list 1 2))

(eq? (list 1 2) (list 3 4))

(eq? (list 1 2) (list 1 2))
#+END_SRC

#+RESULTS:
: #f
: #f
: #f

So always false it seems. However:

#+BEGIN_SRC racket :noweb yes
#lang sicp

(eq? nil nil)
#+END_SRC

#+RESULTS:
: #t

as expected?

Let's see if we can leverage the recursiveness (that the prompt described in extreme detail already) better with another set of checks:

#+BEGIN_SRC racket :noweb yes
#lang sicp

(define (equal? l1 l2)
  (or (eq? l1 l2) (and (pair? l1) (pair? l2) (eq? (car l1) (car l2)) (equal? (cdr l1) (cdr l2)))))

(equal? '(this is a list) '(this is a list))

(equal? '(this is a list) '(this (is a) list))
#+END_SRC

#+RESULTS:
: #t
: #f

***** DONE Exercise 2.55
:PROPERTIES:
:CUSTOM_ID: exercise-2.55
:END:

Eva Lu Ator types to the interpreter the expression

#+BEGIN_SRC scheme
(car "abracadabra")
#+END_SRC

To her surprise, the interpreter prints back ~quote~.  Explain.

#+BEGIN_SRC racket :noweb yes
#lang sicp

(car ''abracadabra)
#+END_SRC

#+RESULTS:
: quote

Refer back to footnote 34; this is the same as:

#+BEGIN_SRC racket :noweb yes
#lang sicp

(car (quote (quote abracadabra)))
#+END_SRC

#+RESULTS:
: quote

and naturally you can expect the ~cdr~ of it to be:

#+BEGIN_SRC racket :noweb yes
#lang sicp

(cdr (quote (quote abracadabra)))

(list (quote abracadabra))
#+END_SRC

#+RESULTS:
: (abracadabra)
: (abracadabra)

I think the point that Lisp expressions are data is beginning to shining.

**** DONE 2.3.2 Example: Symbolic Differentiation

#+BEGIN_SRC racket :noweb yes
#lang sicp

;; (variable? e)          Is `e' a variable?
;; (same-variable? v1 v2) Are `v1' and `v2' the same variable?
;; (sum? e)               Is `e' a sum?
;; (addend e)             Addend of the sum `e'.
;; (augend e)             Augend of the sum `e'.
;; (make-sum a1 a2)       Construct the sum of `a1' and `a2'.
;; (product? e)           Is `e' a product?
;; (multiplier e)         Multiplier of the product `e'.
;; (multiplicand e)       Multiplicand of the product `e'.
;; (make-product m1 m2)   Construct the product of `m1' and `m2'.

(define (variable? x)
  (symbol? x))

(define (same-variable? v1 v2)
  (and (variable? v1) (variable? v2) (eq? v1 v2)))

(define (make-sum a1 a2)
  (list '+ a1 a2))

(define (make-product m1 m2)
  (list '* m1 m2))

(define (sum? x)
  (and (pair? x) (eq? (car x) '+)))

(define (addend s)
  (cadr s))

(define (augend s)
  (caddr s))

(define (product? x)
  (and (pair? x) (eq? (car x) '*)))

(define (multiplier p)
  (cadr p))

(define (multiplicand p)
  (caddr p))

(define (deriv exp var)
  (cond
    [(number? exp) 0]
    [(variable? exp) (if (same-variable? exp var) 1 0)]
    [(sum? exp) (make-sum (deriv (addend exp) var) (deriv (augend exp) var))]
    [(product? exp)
     (make-sum (make-product (multiplier exp) (deriv (multiplicand exp) var))
               (make-product (deriv (multiplier exp) var) (multiplicand exp)))]
    [else (error "unknown expression type: DERIV" exp)]))

(deriv '(+ x 3) 'x)

(deriv '(* x y) 'x)

(deriv '(* (* x y) (+ x 3)) 'x)

(deriv '(* (* x x) x) 'x)
#+END_SRC

#+RESULTS:
: (+ 1 0)
: (+ (* x 0) (* 1 y))
: (+ (* (* x y) (+ 1 0)) (* (+ (* x 0) (* 1 y)) (+ x 3)))
: (+ (* (* x x) 1) (* (+ (* x 1) (* 1 x)) x))


#+BEGIN_SRC racket :noweb yes
#lang sicp

;; (variable? e)          Is `e' a variable?
;; (same-variable? v1 v2) Are `v1' and `v2' the same variable?
;; (sum? e)               Is `e' a sum?
;; (addend e)             Addend of the sum `e'.
;; (augend e)             Augend of the sum `e'.
;; (make-sum a1 a2)       Construct the sum of `a1' and `a2'.
;; (product? e)           Is `e' a product?
;; (multiplier e)         Multiplier of the product `e'.
;; (multiplicand e)       Multiplicand of the product `e'.
;; (make-product m1 m2)   Construct the product of `m1' and `m2'.

(define (variable? x)
  (symbol? x))

(define (same-variable? v1 v2)
  (and (variable? v1) (variable? v2) (eq? v1 v2)))

(define (=number? exp num)
  (and (number? exp) (= exp num)))

(define (make-sum a1 a2)
  (cond
    [(=number? a1 0) a2]
    [(=number? a2 0) a1]
    [(and (number? a1) (number? a2)) (+ a1 a2)]
    [else (list '+ a1 a2)]))

(define (make-product m1 m2)
  (cond
    [(or (=number? m1 0) (=number? m2 0)) 0]
    [(=number? m1 1) m2]
    [(=number? m2 1) m1]
    [(and (number? m1) (number? m2)) (* m1 m2)]
    [else (list '* m1 m2)]))

(define (sum? x)
  (and (pair? x) (eq? (car x) '+)))

(define (addend s)
  (cadr s))

(define (augend s)
  (caddr s))

(define (product? x)
  (and (pair? x) (eq? (car x) '*)))

(define (multiplier p)
  (cadr p))

(define (multiplicand p)
  (caddr p))

(define (deriv exp var)
  (cond
    [(number? exp) 0]
    [(variable? exp) (if (same-variable? exp var) 1 0)]
    [(sum? exp) (make-sum (deriv (addend exp) var) (deriv (augend exp) var))]
    [(product? exp)
     (make-sum (make-product (multiplier exp) (deriv (multiplicand exp) var))
               (make-product (deriv (multiplier exp) var) (multiplicand exp)))]
    [else (error "unknown expression type: DERIV" exp)]))

(deriv '(+ x 3) 'x)

(deriv '(* x y) 'x)

(deriv '(* (* x y) (+ x 3)) 'x)

(deriv '(* (* x x) x) 'x)
#+END_SRC

#+RESULTS:
: 1
: y
: (+ (* x y) (* y (+ x 3)))
: (+ (* x x) (* (+ x x) x))

***** DONE Exercise 2.56
:PROPERTIES:
:CUSTOM_ID: exercise-2.56
:END:

Show how to extend the basic differentiator to handle more kinds of expressions.  For instance, implement the differentiation rule

#+BEGIN_EXAMPLE
 d(u^n)             / du \
 ------ = n u^(n-1) | -- |
   dx               \ dx /
#+END_EXAMPLE

by adding a new clause to the ~deriv~ program and defining appropriate procedures ~exponentiation?~, ~base~, ~exponent~, and ~make-exponentiation~.  (You may use the symbol ~**~ to denote exponentiation.)  Build in the rules that anything raised to the power 0 is 1 and anything raised to the power 1 is the thing itself.

#+BEGIN_SRC racket :noweb yes
#lang sicp

(define (variable? x)
  (symbol? x))

(define (same-variable? v1 v2)
  (and (variable? v1) (variable? v2) (eq? v1 v2)))

(define (=number? exp num)
  (and (number? exp) (= exp num)))

(define (make-sum a1 a2)
  (cond
    [(=number? a1 0) a2]
    [(=number? a2 0) a1]
    [(and (number? a1) (number? a2)) (+ a1 a2)]
    [else (list '+ a1 a2)]))

(define (make-product m1 m2)
  (cond
    [(or (=number? m1 0) (=number? m2 0)) 0]
    [(=number? m1 1) m2]
    [(=number? m2 1) m1]
    [(and (number? m1) (number? m2)) (* m1 m2)]
    [else (list '* m1 m2)]))

(define (make-exponentiation base exponent)
  (cond
    [(=number? exponent 0) 1]
    [(=number? exponent 1) base]
    [(and (number? base) (number? exponent) (expt base exponent))]
    [else (list '** base exponent)]))

(define (sum? x)
  (and (pair? x) (eq? (car x) '+)))

(define (addend s)
  (cadr s))

(define (augend s)
  (caddr s))

(define (product? x)
  (and (pair? x) (eq? (car x) '*)))

(define (multiplier p)
  (cadr p))

(define (multiplicand p)
  (caddr p))

(define (exponentiation? x)
  (and (pair? x) (eq? (car x) '**)))

(define (base e)
  (cadr e))

(define (exponent e)
  (caddr e))

(define (deriv exp var)
  (cond
    [(number? exp) 0]
    [(variable? exp) (if (same-variable? exp var) 1 0)]
    [(sum? exp) (make-sum (deriv (addend exp) var) (deriv (augend exp) var))]
    [(product? exp)
     (make-sum (make-product (multiplier exp) (deriv (multiplicand exp) var))
               (make-product (deriv (multiplier exp) var) (multiplicand exp)))]
    [(exponentiation? exp)
     (make-product (make-product (exponent exp) (make-exponentiation (base exp) (- (exponent exp) 1)))
                   (deriv (base exp) var))]
    [else (error "unknown expression type: DERIV" exp)]))

(deriv '(+ x 3) 'x)

(deriv '(* x y) 'x)

(deriv '(* (* x y) (+ x 3)) 'x)

(deriv '(** x 3) 'x)

(deriv '(* (** x 5) (** y 3)) 'x)
#+END_SRC

#+RESULTS:
: 1
: y
: (+ (* x y) (* y (+ x 3)))
: (* 3 (** x 2))
: (* (* 5 (** x 4)) (** y 3))

***** DONE Exercise 2.57
:PROPERTIES:
:CUSTOM_ID: exercise-2.57
:END:

Extend the differentiation program to handle sums and products of arbitrary numbers of (two or more) terms.  Then the last example above could be expressed as

#+BEGIN_SRC scheme
(deriv '(* x y (+ x 3)) 'x)
#+END_SRC

Try to do this by changing only the representation for sums and products, without changing the ~deriv~ procedure at all.  For example, the ~addend~ of a sum would be the first term, and the ~augend~ would be the sum of the rest of the terms.

#+BEGIN_SRC racket :noweb yes
#lang sicp

(cdddr '(+ x 3))

(pair? (cdddr '(+ x 3)))

(caddr '(+ x 3))

(cdddr '(+ x x 3))

(pair? (cdddr '(+ x x 3)))
#+END_SRC

#+RESULTS:
: ()
: #f
: 3
: (3)
: #t

#+BEGIN_SRC racket :noweb yes
#lang sicp

(define (variable? x)
  (symbol? x))

(define (same-variable? v1 v2)
  (and (variable? v1) (variable? v2) (eq? v1 v2)))

(define (=number? exp num)
  (and (number? exp) (= exp num)))

(define (make-sum a1 a2)
  (cond
    [(=number? a1 0) a2]
    [(=number? a2 0) a1]
    [(and (number? a1) (number? a2)) (+ a1 a2)]
    [else (list '+ a1 a2)]))

(define (make-product m1 m2)
  (cond
    [(or (=number? m1 0) (=number? m2 0)) 0]
    [(=number? m1 1) m2]
    [(=number? m2 1) m1]
    [(and (number? m1) (number? m2)) (* m1 m2)]
    [else (list '* m1 m2)]))

(define (make-exponentiation base exponent)
  (cond
    [(=number? exponent 0) 1]
    [(=number? exponent 1) base]
    [(and (number? base) (number? exponent) (expt base exponent))]
    [else (list '** base exponent)]))

(define (sum? x)
  (and (pair? x) (eq? (car x) '+)))

(define (addend s)
  (cadr s))

(define (augend s)
  (if (pair? (cdddr s)) (make-sum (addend (cdr s)) (augend (cdr s))) (caddr s)))

(define (product? x)
  (and (pair? x) (eq? (car x) '*)))

(define (multiplier p)
  (cadr p))

(define (multiplicand p)
  (if (pair? (cdddr p)) (make-product (multiplier (cdr p)) (multiplicand (cdr p))) (caddr p)))

(define (exponentiation? x)
  (and (pair? x) (eq? (car x) '**)))

(define (base e)
  (cadr e))

(define (exponent e)
  (caddr e))

(define (deriv exp var)
  (cond
    [(number? exp) 0]
    [(variable? exp) (if (same-variable? exp var) 1 0)]
    [(sum? exp) (make-sum (deriv (addend exp) var) (deriv (augend exp) var))]
    [(product? exp)
     (make-sum (make-product (multiplier exp) (deriv (multiplicand exp) var))
               (make-product (deriv (multiplier exp) var) (multiplicand exp)))]
    [(exponentiation? exp)
     (make-product (make-product (exponent exp) (make-exponentiation (base exp) (- (exponent exp) 1)))
                   (deriv (base exp) var))]
    [else (error "unknown expression type: DERIV" exp)]))

(deriv '(+ x 3) 'x)

(deriv '(* x y) 'x)

(deriv '(* (* x y) (+ x 3)) 'x)

(deriv '(* x y (+ x 3)) 'x)

(deriv '(* 3 x y z) 'x)

(deriv '(** x 3) 'x)

(deriv '(* (** x 5) (** y 3)) 'x)
#+END_SRC

#+RESULTS:
: 1
: y
: (+ (* x y) (* y (+ x 3)))
: (+ (* x y) (* y (+ x 3)))
: (* 3 (* y z))
: (* 3 (** x 2))
: (* (* 5 (** x 4)) (** y 3))

To be honest, checking for ~(pair? (cdddr p))~ might as well check for whether the length of ~p~ is greater than 2.

This accepts the notation in the example as input but does not display in that manner; well the prompt says to "handle".

***** DONE Exercise 2.58
:PROPERTIES:
:CUSTOM_ID: exercise-2.58
:END:

Suppose we want to modify the differentiation program so that it works with ordinary mathematical notation, in which ~+~ and ~*~ are infix rather than prefix operators.  Since the differentiation program is defined in terms of abstract data, we can modify it to work with different representations of expressions solely by changing the predicates, selectors, and constructors that define the representation of the algebraic expressions on which the differentiator is to operate.

a. Show how to do this in order to differentiate algebraic expressions presented in infix form, such as ~(x + (3 * (x + (y + 2))))~.  To simplify the task, assume that ~+~ and ~*~ always take two arguments and that expressions are fully parenthesized.

#+BEGIN_SRC racket :noweb yes
#lang sicp

(define (variable? x)
  (symbol? x))

(define (same-variable? v1 v2)
  (and (variable? v1) (variable? v2) (eq? v1 v2)))

(define (=number? exp num)
  (and (number? exp) (= exp num)))

(define (make-sum a1 a2)
  (cond
    [(=number? a1 0) a2]
    [(=number? a2 0) a1]
    [(and (number? a1) (number? a2)) (+ a1 a2)]
    [else (list '+ a1 a2)]))

(define (make-product m1 m2)
  (cond
    [(or (=number? m1 0) (=number? m2 0)) 0]
    [(=number? m1 1) m2]
    [(=number? m2 1) m1]
    [(and (number? m1) (number? m2)) (* m1 m2)]
    [else (list '* m1 m2)]))

(define (make-exponentiation base exponent)
  (cond
    [(=number? exponent 0) 1]
    [(=number? exponent 1) base]
    [(and (number? base) (number? exponent) (expt base exponent))]
    [else (list '** base exponent)]))

(define (sum? x)
  (and (pair? x) (eq? (cadr x) '+)))

(define (addend s)
  (car s))

(define (augend s)
  (caddr s))

(define (product? x)
  (and (pair? x) (eq? (cadr x) '*)))

(define (multiplier p)
  (car p))

(define (multiplicand p)
  (caddr p))

(define (exponentiation? x)
  (and (pair? x) (eq? (car x) '**)))

(define (base e)
  (cadr e))

(define (exponent e)
  (caddr e))

(define (deriv exp var)
  (cond
    [(number? exp) 0]
    [(variable? exp) (if (same-variable? exp var) 1 0)]
    [(sum? exp) (make-sum (deriv (addend exp) var) (deriv (augend exp) var))]
    [(product? exp)
     (make-sum (make-product (multiplier exp) (deriv (multiplicand exp) var))
               (make-product (deriv (multiplier exp) var) (multiplicand exp)))]
    [(exponentiation? exp)
     (make-product (make-product (exponent exp) (make-exponentiation (base exp) (- (exponent exp) 1)))
                   (deriv (base exp) var))]
    [else (error "unknown expression type: DERIV" exp)]))

(deriv '(x + (3 * (x + (y + 2)))) 'x)
#+END_SRC

#+RESULTS:
: 4

b. The problem becomes substantially harder if we allow standard algebraic notation, such as ~(x + 3 * (x + y + 2))~, which drops unnecessary parentheses and assumes that multiplication is done before addition.  Can you design appropriate predicates, selectors, and constructors for this notation such that our derivative program still works?

   So I suppose the big hint here is that you still don't need to change ~deriv~.
   
#+BEGIN_SRC racket :noweb yes
#lang sicp

(define (variable? x)
  (symbol? x))

(define (same-variable? v1 v2)
  (and (variable? v1) (variable? v2) (eq? v1 v2)))

(define (=number? exp num)
  (and (number? exp) (= exp num)))

(define (make-sum a1 a2)
  (cond
    [(=number? a1 0) a2]
    [(=number? a2 0) a1]
    [(and (number? a1) (number? a2)) (+ a1 a2)]
    [else (list a1 '+ a2)]))

(define (make-product m1 m2)
  (cond
    [(or (=number? m1 0) (=number? m2 0)) 0]
    [(=number? m1 1) m2]
    [(=number? m2 1) m1]
    [(and (number? m1) (number? m2)) (* m1 m2)]
    [else (list m1 '* m2)]))

(define (make-exponentiation base exponent)
  (cond
    [(=number? exponent 0) 1]
    [(=number? exponent 1) base]
    [(and (number? base) (number? exponent) (expt base exponent))]
    [else (list base '** exponent)]))

(define (make-rh exp)
  (if (sum? exp)
      (make-sum (addend exp) (augend exp))
      (make-product (multiplier exp) (multiplicand exp))))

(define (sum? x)
  (and (pair? x) (eq? (cadr x) '+)))

(define (addend s)
  (car s))

(define (augend s)
  (if (> (length s) 3) (make-rh (cddr s)) (caddr s)))

(define (product? x)
  (and (pair? x) (eq? (cadr x) '*)))

(define (multiplier p)
  (car p))

(define (multiplicand p)
  (if (> (length p) 3) (make-rh (cddr p)) (caddr p)))

(define (exponentiation? x)
  (and (pair? x) (eq? (cadr x) '**)))

(define (base e)
  (cadr e))

(define (exponent e)
  (caddr e))

(define (deriv exp var)
  (cond
    [(number? exp) 0]
    [(variable? exp) (if (same-variable? exp var) 1 0)]
    [(sum? exp) (make-sum (deriv (addend exp) var) (deriv (augend exp) var))]
    [(product? exp)
     (make-sum (make-product (multiplier exp) (deriv (multiplicand exp) var))
               (make-product (deriv (multiplier exp) var) (multiplicand exp)))]
    [(exponentiation? exp)
     (make-product (make-product (exponent exp) (make-exponentiation (base exp) (- (exponent exp) 1)))
                   (deriv (base exp) var))]
    [else (error "unknown expression type: DERIV" exp)]))

(deriv '(x + 3 * (x + y + 2)) 'x)
;; wrong
(deriv '(x + 3 * x ** 4) 'x)
#+END_SRC

#+RESULTS:
: 4
: 13

Hmm, the problem now is that we obviously have not handled precedence at all...

Maybe we can first do a pass to add all the appropriate parentheses; or maybe we can try to do something in the recursive passes (~make-rh~)? I don't really think so...

Wait...maybe we can have ~make-rh~ also take the operation that is going on. Then it can decide if it should add parens to the right hand side.

#+BEGIN_SRC racket :noweb yes
#lang sicp

(define (variable? x)
  (symbol? x))

(define (same-variable? v1 v2)
  (and (variable? v1) (variable? v2) (eq? v1 v2)))

(define (=number? exp num)
  (and (number? exp) (= exp num)))

(define (precedence op)
  (cond
    [(eq? op '+) 0]
    [(eq? op '*) 1]
    [(eq? op '**) 2]))

(define (make-sum a1 a2)
  (cond
    [(=number? a1 0) a2]
    [(=number? a2 0) a1]
    [(and (number? a1) (number? a2)) (+ a1 a2)]
    [else (list a1 '+ a2)]))

(define (make-product m1 m2)
  (cond
    [(or (=number? m1 0) (=number? m2 0)) 0]
    [(=number? m1 1) m2]
    [(=number? m2 1) m1]
    [(and (number? m1) (number? m2)) (* m1 m2)]
    [else (list m1 '* m2)]))

(define (make-exponentiation base exponent)
  (cond
    [(=number? exponent 0) 1]
    [(=number? exponent 1) base]
    [(and (number? base) (number? exponent) (expt base exponent))]
    [else (list base '** exponent)]))

(define (make-rh exp op)
  (if (> (precedence (operator exp)) (precedence op))
      (make-rh exp (operator exp))
      (cond
        [(sum? exp) (make-sum (addend exp) (augend exp))]
        [(product? exp) (make-product (multiplier exp) (multiplicand exp))]
        [(exponentiation? exp) (make-exponentiation (base exp) (exponent exp))])))

(define (operator exp)
  (cadr exp))

(define (sum? x)
  (and (pair? x) (eq? (operator x) '+)))

(define (addend s)
  (car s))

(define (augend s)
  (if (> (length s) 3) (make-rh (cddr s) '+) (caddr s)))

(define (product? x)
  (and (pair? x) (eq? (operator x) '*)))

(define (multiplier p)
  (car p))

(define (multiplicand p)
  (if (> (length p) 3) (make-rh (cddr p) '*) (caddr p)))

(define (exponentiation? x)
  (and (pair? x) (eq? (operator x) '**)))

(define (base e)
  (car e))

(define (exponent e)
  (caddr e))

(define (deriv exp var)
  (cond
    [(number? exp) 0]
    [(variable? exp) (if (same-variable? exp var) 1 0)]
    [(sum? exp) (make-sum (deriv (addend exp) var) (deriv (augend exp) var))]
    [(product? exp)
     (make-sum (make-product (multiplier exp) (deriv (multiplicand exp) var))
               (make-product (deriv (multiplier exp) var) (multiplicand exp)))]
    [(exponentiation? exp)
     (make-product (make-product (exponent exp) (make-exponentiation (base exp) (- (exponent exp) 1)))
                   (deriv (base exp) var))]
    [else (error "unknown expression type: DERIV" exp)]))

(deriv '(x + 3 * (x + y + 2)) 'x)

(deriv '(x + 3 * x ** 4) 'x)

(deriv '(2 * x + x) 'x)
#+END_SRC

#+RESULTS:
: 4
: (1 + (3 * (4 * (x ** 3))))
: 4

actually scrap all of it. It seems that when you have a higher-precedence operation on the left hand side, you can't regard the right hand side as a whole anymore because you are expecting it to return a value first so that you can complete the operation, which can't happen (e.g., ~2 * 3 + 5~). The implementation of ~deriv~ depends on this. Sigh...

actually, infix kind of sucks...for this exercise anyway. Maybe we can do one pass that converts everything to simple prefix in one pass, then we can use all the original code!

I know that there's the shunting yard algorithm that converts infix to postfix--which I suppose is still a bit different from what we are trying to do. I might end up looking that up anyways, but first of all let's think about why prefix doesn't need parentheses and how a conversion might work. Let's look at the example in the prompt:

#+begin_example
(x + 3 * (x + y + 2))
(+ x (* 3 (+ x y 2)))
#+end_example

There are still parens for the sexps, but the point is that they can be removed and the operation is still unambiguous. Note that unlike what we just painfully discovered for infix notation, for prefix notation you can always evaluate the whole thing by recursively evaluate each operand and then apply the operator. In fact it's what the previous parts on recursion were all about.

I think there are approaches of using the shunting yard algorithm to convert from infix to postfix, then do something else for postfix to prefix--but I am trying to avoid this because it seems that the algorithm (and postfix, RPN, however it should be called) is meant for stack-based machines that would be quite unwieldly for me. I guess I can have a stack by ~cons~ onto the front of a list and keep it by tail recursion, but I wonder if there might be a more recursive approach.

Let's think of another example that also has exponentiation and think this through:

#+begin_example
(x + 2 ** 7 + 8 * 4 + 1)
(+ x (** 2 7) (* 8 4) 1)
#+end_example

#+begin_example
(2 ** 7 + x + 8 * 4 + 1)
(+ (2 ** 7) x (* 8 4) 1)
#+end_example

#+begin_example
(2 ** 7 * (x + 3))
(* (2 ** 7) (+ x 3))
#+end_example

So the first important thing we observe is that the operation with the lowest precedence is going to be on the outermost, which is how prefix notation is unambiguous in the first place (and why infix might be easier to reason about if you want to put such operations in the middle with parens). We can start with a function that identifies the lowest precedence operation and thus the operation of the outermost sexp.

#+BEGIN_SRC racket :noweb yes
#lang sicp
<<accumulate>>

(define (precedence op)
  (cond
    [(eq? op '+) 0]
    [(eq? op '*) 1]
    [(eq? op '**) 2]))

(define (operator? x)
  (or (eq? x '+) (eq? x '*) (eq? x '**)))

(define (get-min-operation expr)
  (accumulate (lambda (x y)
                (if (and (operator? x) (or (null? y) (< (precedence x) (precedence y)))) x y))
              nil
              expr))

(get-min-operation '(x + 2 ** 7 + 8 * 4 + 1))
(get-min-operation '(2 ** 7 + x + 8 * 4 + 1))
(get-min-operation '(2 ** 7 * (x + 3)))
#+END_SRC

#+RESULTS:
: +
: +
: *

~accumulate~ is handy for this because we don't need to deal with parens separately.

Now we have this, we need a way to rewrite terms generally such that:

#+begin_example
(rewrite '+ '(x + y ** z + z * y * x))
(+ x y ** z z * y * x)
#+end_example

How can we even accomplish this. Well looking at the tools we have, we did cover ~memq~ before that should be useful:

#+BEGIN_SRC racket :noweb yes
#lang sicp

(memq '+ '(1 * x + y ** z + z * y * x))
#+END_SRC

#+RESULTS:
: (+ y ** z + z * y * x)

but I feel like we need basically another ~memq~ that returns the sublist prior to the first occurrence. Here we go:

#+BEGIN_SRC racket :noweb yes
#lang sicp

(define (memq-before item x)
  (cond
    [(null? x) nil]
    [(eq? item (car x)) nil]
    [else (cons (car x) (memq-before item (cdr x)))]))

(define (before-op op expr)
  (memq-before op expr))

(define (after-op op expr)
  (if (pair? (memq op expr)) (cdr (memq op expr)) nil))

(before-op '+ '(1 * x + y ** z + z * y * x))
(after-op '+ '(1 * x + y ** z + z * y * x))
(before-op '+ (after-op '+ '(1 * x + y ** z + z * y * x)))
(after-op '+ (after-op '+ '(1 * x + y ** z + z * y * x)))
(before-op '+ (after-op '+ (after-op '+ '(1 * x + y ** z + z * y * x))))
(after-op '+ (after-op '+ (after-op '+ '(1 * x + y ** z + z * y * x))))

(before-op '* '((1 + 2) * (3 + 4)))
(list? (car (before-op '* '((1 + 2) * (3 + 4)))))
(after-op '* '((1 + 2) * (3 + 4)))
(list? (car (before-op '+ '(1 * x + y ** z + z * y * x))))
#+END_SRC

#+RESULTS:
#+begin_example
(1 * x)
(y ** z + z * y * x)
(y ** z)
(z * y * x)
(z * y * x)
()
((1 + 2))
#t
((3 + 4))
#f
#+end_example

I suppose we might be able to accomplish ~rewrite~ with this? We can keep appending the results of ~before-op~ until ~after-op~ is nil.

#+BEGIN_SRC racket :noweb yes
#lang sicp

(define (memq-before item x)
  (cond
    [(null? x) nil]
    [(eq? item (car x)) nil]
    [else (cons (car x) (memq-before item (cdr x)))]))

(define (before-op op expr)
  (memq-before op expr))

(define (after-op op expr)
  (if (pair? (memq op expr)) (cdr (memq op expr)) nil))

(define (rewrite op expr)
  (define (helper remaining)
    (if (null? (after-op op remaining))
        (list (before-op op remaining))
        (cons (before-op op remaining) (helper (after-op op remaining)))))
  (cons op (helper expr)))

(rewrite '+ '(1 * x + y ** z + z * y * x))
#+END_SRC

#+RESULTS:
: (+ (1 * x) (y ** z) (z * y * x))

Yes! Some extra parens than what I first imagined, but they are good! Maybe I need to check for single things (e.g., ~(1)~, ~(x)~) later though as this probably breaks ~variable?~ and ~=number?~.

So it seems like I just need to repeatedly ~get-min-operation~ and ~rewrite~ for each term until they are all in prefix notation. Some tinkering I suppose I need to do.

#+BEGIN_SRC racket :noweb yes
<<sicp>>

(define (precedence op)
  (cond
    [(eq? op '+) 0]
    [(eq? op '*) 1]
    [(eq? op '**) 2]))

(define (operator? x)
  (or (eq? x '+) (eq? x '*) (eq? x '**)))

(define (min-operator expr)
  (accumulate (lambda (x y)
                (if (and (operator? x) (or (null? y) (< (precedence x) (precedence y)))) x y))
              nil
              expr))

(define (memq-before item x)
  (cond
    [(null? x) nil]
    [(eq? item (car x)) nil]
    [else (cons (car x) (memq-before item (cdr x)))]))

(define (before-op op expr)
  (memq-before op expr))

(define (after-op op expr)
  (if (pair? (memq op expr)) (cdr (memq op expr)) nil))

(define (rewrite op expr)
  (define (helper remaining)
    (if (null? (after-op op remaining))
        (list (before-op op remaining))
        (cons (before-op op remaining) (helper (after-op op remaining)))))
  (cons op (helper expr)))

(rewrite '+ '(1 * x + y ** z + z * y * x))
(cdr (rewrite '+ '(1 * x + y ** z + z * y * x)))
(min-operator (car (cdr (rewrite '+ '(1 * x + y ** z + z * y * x)))))
(rewrite (min-operator (car (cdr (rewrite '+ '(1 * x + y ** z + z * y * x)))))
         (car (cdr (rewrite '+ '(1 * x + y ** z + z * y * x)))))

(define (to-prefix expr)
  (rewrite (min-operator expr) expr))

(newline)
(to-prefix '(1 * x + y ** z + z * y * x))

(define (unwrap expr)
  (cons (car expr) (flatmap identity (cdr expr))))

(unwrap '(* (1) (x)))

(define (complete? expr)
  (null? (filter (lambda (x) (not (null? (cdr x)))) expr)))

(complete? '((1 * x) (y ** z) (z * y * x)))
(complete? '((1) (x)))

(pair? (car '((1) (x))))
#+END_SRC

#+RESULTS:
#+begin_example
(+ (1 * x) (y ** z) (z * y * x))
((1 * x) (y ** z) (z * y * x))
,*
(* (1) (x))

(+ (1 * x) (y ** z) (z * y * x))
(* 1 x)
#f
#t
#t
#+end_example

So the stop condition is when each term is a single number or variable.

Actually stop right here because we should have better names. Let's have ~to-prefix~ as the topmost level function that transforms something infix to prefix completely (via recursion); ~rewrite~ be a midlevel function that calls ~min-operator~ itself; wait actually let's not change names; just change ~rewrite~ to move what it's currently doing more into the helper.

#+BEGIN_SRC racket :noweb yes
<<sicp>>

(define (precedence op)
  (cond
    [(eq? op '+) 0]
    [(eq? op '*) 1]
    [(eq? op '**) 2]))

(define (operator? x)
  (or (eq? x '+) (eq? x '*) (eq? x '**)))

(define (min-operator expr)
  (accumulate (lambda (x y)
                (if (and (operator? x) (or (null? y) (< (precedence x) (precedence y)))) x y))
              nil
              expr))

(define (memq-before item x)
  (cond
    [(null? x) nil]
    [(eq? item (car x)) nil]
    [else (cons (car x) (memq-before item (cdr x)))]))

;; (define (before-op op expr)
;;   (let ([term (memq-before op expr)]) (if (list? (car term)) (car term) term)))

;; (define (after-op op expr)
;;   (if (pair? (memq op expr))
;;       (let ([term (cdr (memq op expr))]) (if (list? (car term)) (car term) term))
;;       nil))

(define (before-op op expr)
  (unhusk (memq-before op expr)))

(define (after-op op expr)
  (if (pair? (memq op expr)) (unhusk (cdr (memq op expr))) nil))

(define (rewrite expr)
  (let ([unhusked (unhusk expr)])
    (let ([op (min-operator unhusked)])
      (define (helper remaining)
        (if (null? (after-op op remaining))
            (list (before-op op remaining))
            (cons (before-op op remaining) (helper (after-op op remaining)))))
      (cons op (helper unhusked)))))

(define (unwrap expr)
  (if (null? (cdr expr)) (car expr) (cons (car expr) (flatmap identity (cdr expr)))))

(define (complete? expr)
  (or (null? (cdr expr))
      (and (operator? (car expr))
           (pair? (cadr expr))
           (null? (filter (lambda (x) (not (null? (cdr x)))) (cdr expr))))))

(define (unhusk expr)
  (if (and (null? (cdr expr)) (list? (car expr))) (car expr) expr))

(define (to-prefix input)
  (define (helper expr)
    (if (complete? expr) (unwrap expr) (map to-prefix (cdr expr))))
  (helper (rewrite input)))

;; (define (to-prefix input)
;;   (define (helper expr)
;;     (if (complete? expr) (unwrap expr) (map helper (rewrite (cdr expr)))))
;;   (helper (rewrite input)))

;; (define (to-prefix input)
;;   (define (helper expr)
;;     (cond
;;       [(complete? expr) (unwrap expr)]
;;       [else (map to-prefix (cdr expr))]))
;;   (helper (rewrite input)))


(rewrite '(1 * (2 + 3)))
(complete? '(* (1) (2 + 3)))
;; (to-prefix '(1 * (2 + 3)))
;; (newline)
;; (rewrite '(1 * x + y ** z + z * y * x))
;; (complete? '(1 * x))
;; (rewrite '(1 * x))
;; (complete? '(* (1) (x)))
;; (unwrap '(* (1) (x)))
;; (to-prefix '(1 * x + y ** z + z * y * x))
;; (newline)
;; (rewrite '(2 ** (7 + (4 * 5))))
;; (cddr (rewrite '(2 ** (7 + (4 * 5)))))
;; (rewrite (cddr (rewrite '(2 ** (7 + (4 * 5))))))
;; (cddr (rewrite (cddr (rewrite '(2 ** (7 + (4 * 5)))))))
;; (rewrite (cddr (rewrite (cddr (rewrite '(2 ** (7 + (4 * 5))))))))
;; (complete? (rewrite (cddr (rewrite (cddr (rewrite '(2 ** (7 + (4 * 5)))))))))
;; (unwrap (rewrite (cddr (rewrite (cddr (rewrite '(2 ** (7 + (4 * 5)))))))))
;; ;; (to-prefix '(2 ** (7 + (4 * 5))))
#+END_SRC

#+RESULTS:
: (* (1) (2 + 3))
: #f

actually nevermind; I'm starting again below:

#+NAME: to-prefix
#+BEGIN_SRC racket :noweb yes
<<sicp>>

(define (precedence op)
  (cond
    [(eq? op '+) 0]
    [(eq? op '*) 1]
    [(eq? op '**) 2]))

(define (operator? x)
  (or (eq? x '+) (eq? x '*) (eq? x '**)))

(define (min-operator expr)
  (accumulate (lambda (x y)
                (if (and (operator? x) (or (null? y) (< (precedence x) (precedence y)))) x y))
              nil
              expr))

(define (memq-before item x)
  (cond
    [(null? x) nil]
    [(eq? item (car x)) nil]
    [else (cons (car x) (memq-before item (cdr x)))]))

(define (before-op op expr)
  (unhusk (memq-before op expr)))

(define (after-op op expr)
  (if (pair? (memq op expr)) (cdr (memq op expr)) nil))

(define (rewrite expr)
  (let ([op (min-operator expr)])
    (define (helper remaining)
      (if (null? (after-op op remaining))
          (list (before-op op remaining))
          (cons (before-op op remaining) (helper (after-op op remaining)))))
    (cons op (helper expr))))

(define (single? expr)
  (null? (cdr expr)))

(define (unhusk expr)
  (if (and (single? expr) (list? (car expr))) (unhusk (car expr)) expr))

(define (unwrap expr)
  (if (single? expr) (car expr) (cons (car expr) (flatmap identity (cdr expr)))))

(define (rewritten? expr)
  (or (single? expr) (operator? (car expr))))

(define (complete? expr)
  (or (single? expr)
      (and (operator? (car expr))
           (pair? (cadr expr))
           (null? (filter (lambda (x) (not (single? x))) (cdr expr))))))

(define (to-prefix expr)
  (cond
    [(not (rewritten? expr)) (to-prefix (rewrite expr))]
    [(complete? expr) (unwrap expr)]
    [else (cons (car expr) (map to-prefix (cdr expr)))]))

(to-prefix '(1 * x + y ** z + z * y * x))
(to-prefix '(1 * (2 + 3)))
(to-prefix '(2 ** (7 + (4 * 5))))
(to-prefix '(x + 3 * (x + y + 2)))
#+END_SRC
#+RESULTS:
: (+ (* 1 x) (** y z) (* z y x))
: (* 1 (+ 2 3))
: (** 2 (+ 7 (* 4 5)))
: (+ x (* 3 (+ x y 2)))

Oh my god this finally works.

Let's finally make ~deriv~ work. Because we are using variadic forms, we need the code from Exercise 2.57:

#+BEGIN_SRC racket :noweb yes
<<to-prefix>>

(define (variable? x)
  (symbol? x))

(define (same-variable? v1 v2)
  (and (variable? v1) (variable? v2) (eq? v1 v2)))

(define (=number? exp num)
  (and (number? exp) (= exp num)))

(define (make-sum a1 a2)
  (cond
    [(=number? a1 0) a2]
    [(=number? a2 0) a1]
    [(and (number? a1) (number? a2)) (+ a1 a2)]
    [else (list '+ a1 a2)]))

(define (make-product m1 m2)
  (cond
    [(or (=number? m1 0) (=number? m2 0)) 0]
    [(=number? m1 1) m2]
    [(=number? m2 1) m1]
    [(and (number? m1) (number? m2)) (* m1 m2)]
    [else (list '* m1 m2)]))

(define (make-exponentiation base exponent)
  (cond
    [(=number? exponent 0) 1]
    [(=number? exponent 1) base]
    [(and (number? base) (number? exponent) (expt base exponent))]
    [else (list '** base exponent)]))

(define (sum? x)
  (and (pair? x) (eq? (car x) '+)))

(define (addend s)
  (cadr s))

(define (augend s)
  (if (pair? (cdddr s)) (make-sum (addend (cdr s)) (augend (cdr s))) (caddr s)))

(define (product? x)
  (and (pair? x) (eq? (car x) '*)))

(define (multiplier p)
  (cadr p))

(define (multiplicand p)
  (if (pair? (cdddr p)) (make-product (multiplier (cdr p)) (multiplicand (cdr p))) (caddr p)))

(define (exponentiation? x)
  (and (pair? x) (eq? (car x) '**)))

(define (base e)
  (cadr e))

(define (exponent e)
  (caddr e))

(define (deriv exp var)
  (cond
    [(number? exp) 0]
    [(variable? exp) (if (same-variable? exp var) 1 0)]
    [(sum? exp) (make-sum (deriv (addend exp) var) (deriv (augend exp) var))]
    [(product? exp)
     (make-sum (make-product (multiplier exp) (deriv (multiplicand exp) var))
               (make-product (deriv (multiplier exp) var) (multiplicand exp)))]
    [(exponentiation? exp)
     (make-product (make-product (exponent exp) (make-exponentiation (base exp) (- (exponent exp) 1)))
                   (deriv (base exp) var))]
    [else (error "unknown expression type: DERIV" exp)]))

(define (deriv-infix exp var)
  (deriv (to-prefix exp) var))

(deriv '(+ x (* 3 (+ x y 2))) 'x)
(deriv-infix '(x + 3 * (x + y + 2)) 'x)
#+END_SRC

#+RESULTS:
: 4
: 4

**** DONE 2.3.3 Example: Representing Sets

#+BEGIN_SRC racket :noweb yes
#lang sicp

;; O(n)
(define (element-of-set? x set)
  (cond
    [(null? set) #f]
    [(equal? x (car set)) #t]
    [else (element-of-set? x (cdr set))]))
;; O(n)
(define (adjoin-set x set)
  (if (element-of-set? x set) set (cons x set)))
;; O(n^2)
(define (intersection-set set1 set2)
  (cond
    [(or (null? set1) (null? set2)) nil]
    [(element-of-set? (car set1) set2) (cons (car set1) (intersection-set (cdr set1) set2))]
    [else (intersection-set (cdr set1) set2)]))
#+END_SRC

***** DONE Exercise 2.59
:PROPERTIES:
:CUSTOM_ID: exercise-2.59
:END:

Implement the ~union-set~ operation for the unordered-list representation of sets.

#+BEGIN_SRC racket :noweb yes
#lang sicp

(define (element-of-set? x set)
  (cond
    [(null? set) #f]
    [(equal? x (car set)) #t]
    [else (element-of-set? x (cdr set))]))

(define (adjoin-set x set)
  (if (element-of-set? x set) set (cons x set)))

(define (intersection-set set1 set2)
  (cond
    [(or (null? set1) (null? set2)) nil]
    [(element-of-set? (car set1) set2) (cons (car set1) (intersection-set (cdr set1) set2))]
    [else (intersection-set (cdr set1) set2)]))

(define (union-set set1 set2)
  (if (null? set1) set2 (union-set (cdr set1) (adjoin-set (car set1) set2))))

(union-set (list 1 2 3) (list 1 2 3))
(union-set (list 1 2 3) (list 2 3 4))
#+END_SRC

#+RESULTS:
: (1 2 3)
: (1 2 3 4)

***** DONE Exercise 2.60
:PROPERTIES:
:CUSTOM_ID: exercise-2.60
:END:

We specified that a set would be represented as a list with no duplicates.  Now suppose we allow duplicates.  For instance, the set {1,2,3} could be represented as the list ~(2 3 2 1 3 2 2)~.  Design procedures ~element-of-set?~, ~adjoin-set~, ~union-set~, and ~intersection-set~ that operate on this representation.  How does the efficiency of each compare with the corresponding procedure for the non-duplicate representation?  Are there applications for which you would use this representation in preference to the non-duplicate one?

#+BEGIN_SRC racket :noweb yes
#lang sicp
;; O(n)
(define (element-of-set? x set)
  (cond
    [(null? set) #f]
    [(equal? x (car set)) #t]
    [else (element-of-set? x (cdr set))]))
;; O(1)
(define (adjoin-set x set)
  (cons x set))
;; O(n^2)
(define (intersection-set set1 set2)
  (cond
    [(or (null? set1) (null? set2)) nil]
    [(element-of-set? (car set1) set2) (cons (car set1) (intersection-set (cdr set1) set2))]
    [else (intersection-set (cdr set1) set2)]))
;; O(n)
(define (union-set set1 set2)
  (append set1 set2))
#+END_SRC

Note that /n/ for the version that allows duplicates will tend to be much greater. Overall if we mostly add to sets (using ~adjoin-set~), this could be nice. I suppose there can be QoS kind of features that routinely cleans up duplicates when the user is not actively using, otherwise this costs a lot of memory and worse performance (especially for ~intersection-set~) for the other operations.
***** Sets as ordered lists

#+BEGIN_SRC racket :noweb yes
#lang sicp
;; still O(n) but on average n is twice smaller
(define (element-of-set? x set)
  (cond
    [(null? set) #f]
    [(= x (car set)) #t]
    [(< x (car set)) #f]
    [else (element-of-set? x (cdr set))]))
;; O(n) as the number of steps required is at most (+ (length set1) (length set2))
;; we don't need to use element-of-set? here
(define (intersection-set set1 set2)
  (if (or (null? set1) (null? set2))
      nil
      (let ([x1 (car set1)] [x2 (car set2)])
        (cond
          [(= x1 x2) (cons x1 (intersection-set (cdr set1) (cdr set2)))]
          [(< x1 x2) (intersection-set (cdr set1) set2)]
          [(< x2 x1) (intersection-set set1 (cdr set2))]))))
#+END_SRC

***** DONE Exercise 2.61
:PROPERTIES:
:CUSTOM_ID: exercise-2.61
:END:

Give an implementation of ~adjoin-set~ using the ordered representation.  By analogy with ~element-of-set?~ show how to take advantage of the ordering to produce a procedure that requires on the average about half as many steps as with the unordered representation.

#+BEGIN_SRC racket :noweb yes
#lang sicp

(define (adjoin-set x set)
  (cond
    [(null? set) (list 6)]
    [(= x (car set)) set]
    [(< x (car set)) (cons x set)]
    [(and (> x (car set)) (or (null? (cdr set)) (< x (cadr set)))) (cons (car set) (cons x (cdr set)))]
    [else (cons (car set) (adjoin-set x (cdr set)))]))

(adjoin-set 2 (list 0 1 3 4 5))
(adjoin-set 6 (list 0 1 3 4 5))
#+END_SRC

#+RESULTS:
: (0 1 2 3 4 5)
: (0 1 3 4 5 6)

actually we don't need all the conditions:

#+BEGIN_SRC racket :noweb yes
#lang sicp

(define (adjoin-set x set)
  (cond
    [(or (null? set) (< x (car set))) (cons x set)]
    [(= x (car set)) set]
    [else (cons (car set) (adjoin-set x (cdr set)))]))

(adjoin-set 2 (list 0 1 3 4 5))
(adjoin-set 6 (list 0 1 3 4 5))
#+END_SRC

#+RESULTS:
: (0 1 2 3 4 5)
: (0 1 3 4 5 6)

***** DONE Exercise 2.62
:PROPERTIES:
:CUSTOM_ID: exercise-2.62
:END:

Give a \theta(n) implementation of ~union-set~ for sets represented as ordered lists.

#+BEGIN_SRC racket :noweb yes
#lang sicp

(define (union-set set1 set2)
  (cond
    [(null? set1) set2]
    [(null? set2) set1]
    [(= (car set1) (car set2)) (cons (car set1) (union-set (cdr set1) (cdr set2)))]
    [(< (car set1) (car set2)) (cons (car set1) (union-set (cdr set1)  set2))]
    [else (cons (car set2) (union-set set1 (cdr set2)))]))

(union-set (list 1 2 3) (list 1 2 3))
(union-set (list 1 2 3) (list 2 3 4))
(union-set (list 1 4) (list 2 3))
#+END_SRC

#+RESULTS:
: (1 2 3)
: (1 2 3 4)
: (1 2 3 4)

***** Sets as binary trees

#+NAME: set-binary-tree
#+BEGIN_SRC racket :noweb yes
#lang sicp

(define (entry tree)
  (car tree))
(define (left-branch tree)
  (cadr tree))
(define (right-branch tree)
  (caddr tree))
(define (make-tree entry left right)
  (list entry left right))
;; O(log(n))
(define (element-of-set? x set)
  (cond
    [(null? set) #f]
    [(= x (entry set)) #t]
    [(< x (entry set)) (element-of-set? x (left-branch set))]
    [(> x (entry set)) (element-of-set? x (right-branch set))]))
;; O(log(n))
(define (adjoin-set x set)
  (cond
    [(null? set) (make-tree x nil nil)]
    [(= x (entry set)) set]
    [(< x (entry set)) (make-tree (entry set) (adjoin-set x (left-branch set)) (right-branch set))]
    [(> x (entry set)) (make-tree (entry set) (left-branch set) (adjoin-set x (right-branch set)))]))
#+END_SRC

using ~adjoin-set~ can get the tree unbalanced; why we have self-balancing trees (B-trees, red-black trees, etc.)

***** DONE Exercise 2.63
:PROPERTIES:
:CUSTOM_ID: exercise-2.63
:END:

Each of the following two procedures converts a binary tree to a list.

#+BEGIN_SRC scheme
(define (tree->list-1 tree)
  (if (null? tree)
      '()
      (append (tree->list-1 (left-branch tree))
              (cons (entry tree)
                    (tree->list-1 (right-branch tree))))))

(define (tree->list-2 tree)
  (define (copy-to-list tree result-list)
    (if (null? tree)
        result-list
        (copy-to-list (left-branch tree)
                      (cons (entry tree)
                            (copy-to-list (right-branch tree)
                                          result-list)))))
  (copy-to-list tree '()))
#+END_SRC

a. Do the two procedures produce the same result for every tree?  If not, how do the results differ?  What lists do the two procedures produce for the trees in [[figure-2.16][Figure 2.16]]?

   #+BEGIN_SRC racket :noweb yes
   <<set-binary-tree>>

   (define fig2-16-1 '(7 (3 (1 () ()) (5 () ())) (9 () (11 () ()))))
   (define fig2-16-2 '(3 (1 () ()) (7 (5 () ()) (9 () (11 () ())))))
   (define fig2-16-3 '(5 (3 (1 () ()) ()) (9 (7 () ()) (11 () ()))))

   (define (tree->list-1 tree)
     (if (null? tree)
         '()
         (append (tree->list-1 (left-branch tree))
                 (cons (entry tree) (tree->list-1 (right-branch tree))))))

   (define (tree->list-2 tree)
     (define (copy-to-list tree result-list)
       (if (null? tree)
           result-list
           (copy-to-list (left-branch tree)
                         (cons (entry tree) (copy-to-list (right-branch tree) result-list)))))
     (copy-to-list tree '()))

   (tree->list-1 fig2-16-1)
   (tree->list-2 fig2-16-1)
   (tree->list-1 fig2-16-2)
   (tree->list-2 fig2-16-2)
   (tree->list-1 fig2-16-3)
   (tree->list-2 fig2-16-3)
   #+END_SRC

   #+RESULTS:
   : (1 3 5 7 9 11)
   : (1 3 5 7 9 11)
   : (1 3 5 7 9 11)
   : (1 3 5 7 9 11)
   : (1 3 5 7 9 11)
   : (1 3 5 7 9 11)

They both traverse the tree in order and produce the same output. The first implementation recursively appends to the leftmost branch the entry and the branch to its right. The second implementation is iterative; it consumes a tree, then calls ~copy-to-list~, asking it to convert the left branch and adds the node entry to the front of ~copy-to-list~ of the right branch in the result list.

b. Do the two procedures have the same order of growth in the number of steps required to convert a balanced tree with n elements to a list?  If not, which one grows more slowly?

   I don;t see one implementation taking more steps than another, but obviously the first implementation uses ~append~ which is \(O(n)\), so overall it might be an \(O(n^2)\) operation while the second implementation is \(O(n)\).

***** DONE Exercise 2.64
:PROPERTIES:
:CUSTOM_ID: exercise-2.64
:END:

The following procedure ~list->tree~ converts an ordered list to a balanced binary tree.  The helper procedure ~partial-tree~ takes as arguments an integer n and list of at least n elements and constructs a balanced tree containing the first n elements of the list.  The result returned by ~partial-tree~ is a pair (formed with ~cons~) whose ~car~ is the constructed tree and whose ~cdr~ is the list of elements not included in the tree.

#+BEGIN_SRC racket
#lang sicp

(define (list->tree elements)
  (car (partial-tree elements (length elements))))

(define (partial-tree elts n)
  (if (= n 0)
      (cons '() elts)
      (let ([left-size (quotient (- n 1) 2)])
        (let ([left-result (partial-tree elts left-size)])
          (let ([left-tree (car left-result)]
                [non-left-elts (cdr left-result)]
                [right-size (- n (+ left-size 1))])
            (let ([this-entry (car non-left-elts)]
                  [right-result (partial-tree (cdr non-left-elts) right-size)])
              (let ([right-tree (car right-result)] [remaining-elts (cdr right-result)])
                (cons (make-tree this-entry left-tree right-tree) remaining-elts))))))))
#+END_SRC

a. Write a short paragraph explaining as clearly as you can how ~partial-tree~ works.  Draw the tree produced by ~list->tree~ for the list ~(1 3 5 7 9 11)~.

Well again, the implementation is given to us and we are asked to explain it; I guess this is hard. So first, ~elts~ is "elements". The base case is that, when asked to construct a partial tree of the first 0 elements, ~partial-tree~ just returns an empty list and the elements back. Now let's start looking into the recursive case:

So ~left-size~ is half of n - 1 rounded down (i.e., 4 for n = 9 or 10). More interestingly, ~left-result~ is the partial tree of the first ~left-size~ elements (remember that the list is ordered), so we already have recursion here. Now ~left-tree~ and ~non-left-elts~ are generated from ~left-result~. ~right-size~ is potentially interesting. Let's look at 2 cases:

- ~n~ = 9, ~left-size~ = 4, ~right-size~ = 4
- ~n~ = 10, ~left-size~ = 4, ~right-size~ = 5

so there should always be one element left; perhaps we'll get to it later.

Indeed! The extra element is captured by ~this-entry~ and it should be the middle value. Recursion on the right branch occurs here, calling ~partial-tree~ on the ~(cdr non-left-elts)~ (those after the middle value) for a tree with ~right-size~. Likewise ~right-tree~ and ~remaining-elts~ are generated from ~right-result~. The final generated tree is ~(make-tree this-entry left-tree right-tree)~.

Let's also look at the case of ~n~ = 1. Both ~left-size~ and ~right-size~ would be 0, so both the left and right trees are empty lists. When ~n = 2~, ~left-size~ = 0 and ~right-size~ = 1, so we have a tree with empty left branch and a right branch of one node. Very neat recursion.

Let's draw the tree:

#+begin_example
   5
/    \
1     9
 \   / \
  3 7  11
#+end_example
  
b. What is the order of growth in the number of steps required by ~list->tree~ to convert a list of n elements?

Just read up on the *Master Theorem*; here might be a good time to apply it:

Per the theorem, the runtime of a recursive algorithm ~f(n)~ should be:

\[T(n) = aT(\frac{n}{b}) + f(n)\]

where ~n~ is the input size (size of the problem, you can think of it this way),  ~a~ is the number of subproblems it divides into, ~n / b~ is the (input) size of each subproblem.

#+begin_quote
For constants $a(\geq 1))$ and $b(>1)$ with $f$ asymptotically positive, the following statements are true:
- Case 1. If $f(n)=O\left(n^{\log _{b} a-\epsilon}\right)$ for some $\epsilon>0$, then $T(n)=\Theta\left(n^{\log _{b} a}\right)$.
- Case 2. If $f(n)=\Theta\left(n^{\log _{b} a}\right)$, then $T(n)=\Theta\left(n^{\log _{b} a} \log n\right)$.
- Case 3. If $f(n)=\Omega\left(n^{\log _{b} a+\epsilon}\right)$ for some $\epsilon>0$ (and $a f\left(\frac{n}{b}\right) \leq c f(n)$ for some $c<1$ for all $n$ sufficiently large), then $T(n)=\Theta(f(n))$.
#+end_quote

Now we look at ~f(n)~ in our case, which is pretty much just ~(cons (make-tree this-entry left-tree right-tree) remaining-elts)~, so \(O(1)\) it is. We divide into two smaller problems each half as large, so ~a~, ~b~ are both 2. Since \(\log_2(2) = 1\), we have \(\epsilon = 1\) in \(f(n)=O\left(n^{\log _{b} a-\epsilon}\right) = O(n^0) = O(1)\). We have Case 1, and \(T(n)=\Theta\left(n^{\log _{b} a}\right) = \Theta(n)\).

A more intuitive explanation is that each element only went through the algorithm once (if you drew the tree you would see), and O(1) work is done on each of them, so ultimately the complexity is O(n).

***** DONE Exercise 2.65
:PROPERTIES:
:CUSTOM_ID: exercise-2.65
:END:

Use the results of [[#exercise-2.63][Exercise 2.63]] and [[#exercise-2.64][Exercise 2.64]] to give \theta(n) implementations of ~union-set~ and ~intersection-set~ for sets implemented as (balanced) binary trees.[fn:107]

#+BEGIN_SRC racket :noweb yes
#lang sicp

(define (entry tree)
  (car tree))
(define (left-branch tree)
  (cadr tree))
(define (right-branch tree)
  (caddr tree))
(define (make-tree entry left right)
  (list entry left right))
;; O(log(n))
(define (element-of-set? x set)
  (cond
    [(null? set) #f]
    [(= x (entry set)) #t]
    [(< x (entry set)) (element-of-set? x (left-branch set))]
    [(> x (entry set)) (element-of-set? x (right-branch set))]))
;; O(log(n))
(define (adjoin-set x set)
  (cond
    [(null? set) (make-tree x nil nil)]
    [(= x (entry set)) set]
    [(< x (entry set)) (make-tree (entry set) (adjoin-set x (left-branch set)) (right-branch set))]
    [(> x (entry set)) (make-tree (entry set) (left-branch set) (adjoin-set x (right-branch set)))]))
;; O(n)
(define (union-list set1 set2)
  (cond
    [(null? set1) set2]
    [(null? set2) set1]
    [(= (car set1) (car set2)) (cons (car set1) (union-list (cdr set1) (cdr set2)))]
    [(< (car set1) (car set2)) (cons (car set1) (union-list (cdr set1) set2))]
    [else (cons (car set2) (union-list set1 (cdr set2)))]))
;; O(n)
(define (intersection-list set1 set2)
  (if (or (null? set1) (null? set2))
      nil
      (let ([x1 (car set1)] [x2 (car set2)])
        (cond
          [(= x1 x2) (cons x1 (intersection-list (cdr set1) (cdr set2)))]
          [(< x1 x2) (intersection-list (cdr set1) set2)]
          [(< x2 x1) (intersection-list set1 (cdr set2))]))))
;; O(n)
(define (tree->list tree)
  (define (copy-to-list tree result-list)
    (if (null? tree)
        result-list
        (copy-to-list (left-branch tree)
                      (cons (entry tree) (copy-to-list (right-branch tree) result-list)))))
  (copy-to-list tree '()))

(define (list->tree elements)
  (car (partial-tree elements (length elements))))

(define (partial-tree elts n)
  (if (= n 0)
      (cons '() elts)
      (let ([left-size (quotient (- n 1) 2)])
        (let ([left-result (partial-tree elts left-size)])
          (let ([left-tree (car left-result)]
                [non-left-elts (cdr left-result)]
                [right-size (- n (+ left-size 1))])
            (let ([this-entry (car non-left-elts)]
                  [right-result (partial-tree (cdr non-left-elts) right-size)])
              (let ([right-tree (car right-result)] [remaining-elts (cdr right-result)])
                (cons (make-tree this-entry left-tree right-tree) remaining-elts))))))))

(define (union-set set1 set2)
  (list->tree (union-list (tree->list set1) (tree->list set2))))

(define (intersection-set set1 set2)
  (list->tree (intersection-list (tree->list set1) (tree->list set2))))

(tree->list (union-set (list->tree (list 1 3 5 7 9)) (list->tree (list 3 4 5 6))))
(tree->list (intersection-set (list->tree (list 1 3 5 7 9)) (list->tree (list 3 4 5 6))))
#+END_SRC

#+RESULTS:
: (1 3 4 5 6 7 9)
: (3 5)

So turns out the most important results we use are from [[#exercise-2.62][Exercise 2.62]].

***** DONE Exercise 2.66
:PROPERTIES:
:CUSTOM_ID: exercise-2.66
:END:

Implement the ~lookup~ procedure for the case where the set of records is structured as a binary tree, ordered by the numerical values of the keys.

#+BEGIN_SRC racket :noweb yes
#lang sicp

;; O(log(n))
(define (element-of-set? x set)
  (cond
    [(null? set) #f]
    [(= x (entry set)) #t]
    [(< x (entry set)) (element-of-set? x (left-branch set))]
    [(> x (entry set)) (element-of-set? x (right-branch set))]))

(define (lookup given-key set-of-records)
  (let ([key (key (entry set-of-records))])
    (cond
      [(null? set-of-records) #f]
      [(equal? given-key key) (entry set-of-records)]
      [(< given-key key) (lookup given-key (left-branch set-of-records))]
      [(> given-key key) (lookup given-key (right-branch set-of-records))])))
#+END_SRC

**** DONE 2.3.4 Example: Huffman Encoding Trees

#+NAME: huffman
#+BEGIN_SRC racket :noweb yes
#lang sicp

(define (make-leaf symbol weight)
  (list 'leaf symbol weight))

(define (leaf? object)
  (eq? (car object) 'leaf))

(define (symbol-leaf x)
  (cadr x))

(define (weight-leaf x)
  (caddr x))

(define (make-code-tree left right)
  (list left right (append (symbols left) (symbols right)) (+ (weight left) (weight right))))

(define (left-branch tree)
  (car tree))

(define (right-branch tree)
  (cadr tree))

(define (symbols tree)
  (if (leaf? tree) (list (symbol-leaf tree)) (caddr tree)))

(define (weight tree)
  (if (leaf? tree) (weight-leaf tree) (cadddr tree)))

(define (decode bits tree)
  (define (decode-1 bits current-branch)
    (if (null? bits)
        nil
        (let ([next-branch (choose-branch (car bits) current-branch)])
          (if (leaf? next-branch)
              (cons (symbol-leaf next-branch) (decode-1 (cdr bits) tree))
              (decode-1 (cdr bits) next-branch)))))
  (decode-1 bits tree))

(define (choose-branch bit branch)
  (cond
    [(= bit 0) (left-branch branch)]
    [(= bit 1) (right-branch branch)]
    [else (error "bad bit: CHOOSE-BRANCH" bit)]))

(define (adjoin-set x set)
  (cond
    [(null? set) (list x)]
    [(< (weight x) (weight (car set))) (cons x set)]
    [else (cons (car set) (adjoin-set x (cdr set)))]))

(define (make-leaf-set pairs)
  (if (null? pairs)
      nil
      (let ([pair (car pairs)])
        (adjoin-set (make-leaf (car pair) (cadr pair)) (make-leaf-set (cdr pairs))))))
#+END_SRC

***** DONE Exercise 2.67
:PROPERTIES:
:CUSTOM_ID: exercise-2.67
:END:

Define an encoding tree and a sample message:

#+BEGIN_SRC scheme
(define sample-tree
  (make-code-tree (make-leaf 'A 4)
                  (make-code-tree
                   (make-leaf 'B 2)
                   (make-code-tree (make-leaf 'D 1)
                                   (make-leaf 'C 1)))))

(define sample-message '(0 1 1 0 0 1 0 1 0 1 1 1 0))
#+END_SRC

Use the ~decode~ procedure to decode the message, and give the result.

#+BEGIN_SRC racket :noweb yes
<<huffman>>

(define sample-tree
  (make-code-tree (make-leaf 'A 4)
                  (make-code-tree (make-leaf 'B 2)
                                  (make-code-tree (make-leaf 'D 1) (make-leaf 'C 1)))))

(define sample-message '(0 1 1 0 0 1 0 1 0 1 1 1 0))

(decode sample-message sample-tree)
#+END_SRC

#+RESULTS:
: (A D A B B C A)

***** DONE Exercise 2.68
:PROPERTIES:
:CUSTOM_ID: exercise-2.68
:END:

The ~encode~ procedure takes as arguments a message and a tree and produces the list of bits that gives the encoded message.

#+BEGIN_SRC scheme
(define (encode message tree)
  (if (null? message)
      '()
      (append (encode-symbol (car message) tree)
              (encode (cdr message) tree))))
#+END_SRC

~encode-symbol~ is a procedure, which you must write, that returns the list of bits that encodes a given symbol according to a given tree.  You should design ~encode-symbol~ so that it signals an error if the symbol is not in the tree at all.  Test your procedure by encoding the result you obtained in [[#exercise-2.67][Exercise 2.67]] with the sample tree and seeing whether it is the same as the original sample message.

#+BEGIN_SRC racket :noweb yes
<<huffman>>

(define (encode message tree)
  (if (null? message) '() (append (encode-symbol (car message) tree) (encode (cdr message) tree))))

(define (encode-symbol symbol tree)
  (define (helper tree)
    (if (leaf? tree)
        nil
        (if (memq symbol (symbols (left-branch tree)))
            (cons 0 (helper (left-branch tree)))
            (cons 1 (helper (right-branch tree))))))
  (if (memq symbol (symbols tree)) (helper tree) (error "Symbol not in tree:" symbol)))

(define sample-tree
  (make-code-tree (make-leaf 'A 4)
                  (make-code-tree (make-leaf 'B 2)
                                  (make-code-tree (make-leaf 'D 1) (make-leaf 'C 1)))))

(define sample-message '(0 1 1 0 0 1 0 1 0 1 1 1 0))

(encode (decode sample-message sample-tree) sample-tree)
#+END_SRC

#+RESULTS:
: (0 1 1 0 0 1 0 1 0 1 1 1 0)

***** DONE Exercise 2.69
:PROPERTIES:
:CUSTOM_ID: exercise-2.69
:END:

The following procedure takes as its argument a list of symbol-frequency pairs (where no symbol appears in more than one pair) and generates a Huffman encoding tree according to the Huffman algorithm.

#+BEGIN_SRC scheme
(define (generate-huffman-tree pairs)
  (successive-merge (make-leaf-set pairs)))
#+END_SRC

~make-leaf-set~ is the procedure given above that transforms the list of pairs into an ordered set of leaves.  ~successive-merge~ is the procedure you must write, using ~make-code-tree~ to successively merge the smallest-weight elements of the set until there is only one element left, which is the desired Huffman tree.  (This procedure is slightly tricky, but not really complicated.  If you find yourself designing a complex procedure, then you are almost certainly doing something wrong.  You can take significant advantage of the fact that we are using an ordered set representation.)

#+BEGIN_SRC racket :noweb yes
<<huffman>>

(define (generate-huffman-tree pairs)
  (successive-merge (make-leaf-set pairs)))

(define (successive-merge leaves)
  (cond
    [(null? (cdr leaves)) (car leaves)]
    [else (successive-merge (adjoin-set (make-code-tree (car leaves) (cadr leaves)) (cddr leaves)))]))

(generate-huffman-tree (list (list 'A 4) (list 'B 2) (list 'C 1) (list 'D 1)))

;; (define sample-tree
;;   (make-code-tree (make-leaf 'A 4)
;;                   (make-code-tree (make-leaf 'B 2)
;;                                   (make-code-tree (make-leaf 'D 1) (make-leaf 'C 1)))))
;; sample-tree

(define sample-message '(0 1 1 0 0 1 0 1 0 1 1 1 0))

(decode sample-message (generate-huffman-tree (list (list 'A 4) (list 'B 2) (list 'C 1) (list 'D 1))))
#+END_SRC

#+RESULTS:
: ((leaf A 4) ((leaf B 2) ((leaf D 1) (leaf C 1) (D C) 2) (B D C) 4) (A B D C) 8)
: (A D A B B C A)

***** DONE Exercise 2.70
:PROPERTIES:
:CUSTOM_ID: exercise-2.70
:END:

The following eight-symbol alphabet with associated relative frequencies was designed to efficiently encode the lyrics of 1950s rock songs.  (Note that the "symbols" of an "alphabet" need not be individual letters.)

#+BEGIN_EXAMPLE
 A     2 NA   16
 BOOM  1 SHA  3
 GET   2 YIP  9
 JOB   2 WAH  1
#+END_EXAMPLE

Use ~generate-huffman-tree~ ([[#exercise-2.69][Exercise 2.69]]) to generate a corresponding Huffman tree, and use ~encode~ ([[#exercise-2.68][Exercise 2.68]]) to encode the following message:

#+BEGIN_EXAMPLE
 Get a job

 Sha na na na na na na na na

 Get a job

 Sha na na na na na na na na

 Wah yip yip yip yip yip yip yip yip yip

 Sha boom
#+END_EXAMPLE

How many bits are required for the encoding?  What is the smallest number of bits that would be needed to encode this song if we used a fixed-length code for the eight-symbol alphabet?

#+BEGIN_SRC racket :noweb yes
<<huffman>>

(define (encode message tree)
  (if (null? message) '() (append (encode-symbol (car message) tree) (encode (cdr message) tree))))

(define (encode-symbol symbol tree)
  (define (helper tree)
    (if (leaf? tree)
        nil
        (if (memq symbol (symbols (left-branch tree)))
            (cons 0 (helper (left-branch tree)))
            (cons 1 (helper (right-branch tree))))))
  (if (memq symbol (symbols tree)) (helper tree) (error "Symbol not in tree:" symbol)))

(define (generate-huffman-tree pairs)
  (successive-merge (make-leaf-set pairs)))

(define (successive-merge leaves)
  (cond
    [(null? (cdr leaves)) (car leaves)]
    [else (successive-merge (adjoin-set (make-code-tree (car leaves) (cadr leaves)) (cddr leaves)))]))

(define alphabet '((A 2) (BOOM 1) (GET 2) (JOB 2) (NA 16) (SHA 3) (YIP 9) (WAH 1)))

(define lyrics
  '(GET A
        JOB
        SHA
        NA
        NA
        NA
        NA
        NA
        NA
        NA
        NA
        GET
        A
        JOB
        SHA
        NA
        NA
        NA
        NA
        NA
        NA
        NA
        NA
        WAH
        YIP
        YIP
        YIP
        YIP
        YIP
        YIP
        YIP
        YIP
        YIP
        SHA
        BOOM))

(encode lyrics (generate-huffman-tree alphabet))
(length (encode lyrics (generate-huffman-tree alphabet)))

(* (length lyrics) (ceiling (log (length alphabet) 2)))
#+END_SRC

#+RESULTS:
: (1 1 1 1 1 1 1 0 0 1 1 1 1 0 1 1 1 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 0 0 1 1 1 1 0 1 1 1 0 0 0 0 0 0 0 0 0 1 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 1 1 0 1 1 0 1 1)
: 84
: 108.0

***** DONE Exercise 2.71
:PROPERTIES:
:CUSTOM_ID: exercise-2.71
:END:

Suppose we have a Huffman tree for an alphabet of n symbols, and that the relative frequencies of the symbols are 1, 2, 4, ..., 2^(n-1).  Sketch the tree for n=5; for n=10.  In such a tree (for general n) how may bits are required to encode the most frequent symbol?  the least frequent symbol?

#+BEGIN_SRC racket :noweb yes
<<huffman>>

(define (generate-huffman-tree pairs)
  (successive-merge (make-leaf-set pairs)))

(define (successive-merge leaves)
  (cond
    [(null? (cdr leaves)) (car leaves)]
    [else (successive-merge (adjoin-set (make-code-tree (car leaves) (cadr leaves)) (cddr leaves)))]))

;; n = 5
(generate-huffman-tree '((A 1) (B 2) (C 4) (D 8) (E 16)))

;; n = 10
(generate-huffman-tree '((A 1) (B 2) (C 4) (D 8) (E 16) (F 32) (G 64) (H 128) (I 256) (J 512)))
#+END_SRC

#+RESULTS:
: (((((leaf A 1) (leaf B 2) (A B) 3) (leaf C 4) (A B C) 7) (leaf D 8) (A B C D) 15) (leaf E 16) (A B C D E) 31)
: ((((((((((leaf A 1) (leaf B 2) (A B) 3) (leaf C 4) (A B C) 7) (leaf D 8) (A B C D) 15) (leaf E 16) (A B C D E) 31) (leaf F 32) (A B C D E F) 63) (leaf G 64) (A B C D E F G) 127) (leaf H 128) (A B C D E F G H) 255) (leaf I 256) (A B C D E F G H I) 511) (leaf J 512) (A B C D E F G H I J) 1023)

You can see they both lean to the left; here's someone else's ASCII art:

#+begin_example
                     {a b c d e} 31
                     /           \
                {a b c d} 15      e 16
                 /     \
           {a b c} 7    d 8
             /    \
        {a b} 3    c 4
         /   \
      a 1    b 2
#+end_example

Note that since \(2^{n-2}+2^{n-1} = 3 \times 2^{n-2} < 2^n = 4 \times 2^{n-2}\), you can expect the tree to be this way (n - 1 layers that hold n symbols), where  the most frequent symbol uses 1 bit and the least uses n - 1 bits.

***** DONE Exercise 2.72
:PROPERTIES:
:CUSTOM_ID: exercise-2.72
:END:

Consider the encoding procedure that you designed in [[#exercise-2.68][Exercise 2.68]].  What is the order of growth in the number of steps needed to encode a symbol?  Be sure to include the number of steps needed to search the symbol list at each node encountered.  To answer this question in general is difficult.  Consider the special case where the relative frequencies of the n symbols are as described in [[#exercise-2.71][Exercise 2.71]], and give the order of growth (as a function of n) of the number of steps needed to encode the most frequent and least frequent symbols in the alphabet.

Let's look at ~encode~:

#+BEGIN_SRC racket :noweb yes
#lang sicp

(define (encode message tree)
  (if (null? message) '() (append (encode-symbol (car message) tree) (encode (cdr message) tree))))

(define (encode-symbol symbol tree)
  (define (helper tree)
    (if (leaf? tree)
        nil
        (if (memq symbol (symbols (left-branch tree)))
            (cons 0 (helper (left-branch tree)))
            (cons 1 (helper (right-branch tree))))))
  (if (memq symbol (symbols tree)) (helper tree) (error "Symbol not in tree:" symbol)))
#+END_SRC

Generally, we search through the symbols the tree has first, which is O(n). Then we search through a binary tree, which is on average O(log_n); for the most frequent symbol this is O(1), and for the least it is O(n^2). So for the two special cases overall it is O(n) and O(n^2).

*** DONE 2.4 Multiple Representations for Abstract Data
**** DONE 2.4.1 Representations for Complex Numbers

#+BEGIN_SRC racket :noweb yes
#lang sicp

(define (add-complex z1 z2)
  (make-from-real-imag (+ (real-part z1) (real-part z2)) (+ (imag-part z1) (imag-part z2))))

(define (sub-complex z1 z2)
  (make-from-real-imag (- (real-part z1) (real-part z2)) (- (imag-part z1) (imag-part z2))))

(define (mul-complex z1 z2)
  (make-from-mag-ang (* (magnitude z1) (magnitude z2)) (+ (angle z1) (angle z2))))

(define (div-complex z1 z2)
  (make-from-mag-ang (/ (magnitude z1) (magnitude z2)) (- (angle z1) (angle z2))))
#+END_SRC

#+BEGIN_SRC racket :noweb yes
#lang sicp

(define (real-part z)
  (car z))

(define (imag-part z)
  (cdr z))

(define (magnitude z)
  (sqrt (+ (square (real-part z)) (square (imag-part z)))))

(define (angle z)
  (atan (imag-part z) (real-part z)))

(define (make-from-real-imag x y)
  (cons x y))

(define (make-from-mag-ang r a)
  (cons (* r (cos a)) (* r (sin a))))
#+END_SRC

#+BEGIN_SRC racket :noweb yes
#lang sicp

(define (real-part z)
  (* (magnitude z) (cos (angle z))))

(define (imag-part z)
  (* (magnitude z) (sin (angle z))))

(define (magnitude z)
  (car z))

(define (angle z)
  (cdr z))

(define (make-from-real-imag x y)
  (cons (sqrt (+ (square x) (square y))) (atan y x)))

(define (make-from-mag-ang r a)
  (cons r a))
#+END_SRC

**** DONE 2.4.2 Tagged data

#+BEGIN_SRC racket :noweb yes
#lang sicp

(define (attach-tag type-tag contents)
  (cons type-tag contents))

(define (type-tag datum)
  (if (pair? datum) (car datum) (error "Bad tagged datum: TYPE-TAG" datum)))

(define (contents datum)
  (if (pair? datum) (cdr datum) (error "Bad tagged datum: CONTENTS" datum)))

(define (rectangular? z)
  (eq? (type-tag z) 'rectangular))

(define (polar? z)
  (eq? (type-tag z) 'polar))
#+END_SRC

#+BEGIN_SRC racket :noweb yes
#lang sicp

(define (real-part-rectangular z)
  (car z))

(define (imag-part-rectangular z)
  (cdr z))

(define (magnitude-rectangular z)
  (sqrt (+ (square (real-part-rectangular z)) (square (imag-part-rectangular z)))))

(define (angle-rectangular z)
  (atan (imag-part-rectangular z) (real-part-rectangular z)))

(define (make-from-real-imag-rectangular x y)
  (attach-tag 'rectangular (cons x y)))

(define (make-from-mag-ang-rectangular r a)
  (attach-tag 'rectangular (cons (* r (cos a)) (* r (sin a)))))
#+END_SRC

#+BEGIN_SRC racket :noweb yes
#lang sicp

(define (real-part-polar z)
  (* (magnitude-polar z) (cos (angle-polar z))))

(define (imag-part-polar z)
  (* (magnitude-polar z) (sin (angle-polar z))))

(define (magnitude-polar z)
  (car z))

(define (angle-polar z)
  (cdr z))

(define (make-from-real-imag-polar x y)
  (attach-tag 'polar (cons (sqrt (+ (square x) (square y))) (atan y x))))

(define (make-from-mag-ang-polar r a)
  (attach-tag 'polar (cons r a)))
#+END_SRC

#+BEGIN_SRC racket :noweb yes
#lang sicp

(define (real-part z)
  (cons [(rectangular? z) (real-part-rectangular (contents z))]
        [(polar? z) (real-part-polar (contents z))]
        [else (error "Unknown type: REAL-PART" z)]))

(define (imag-part z)
  (cons [(rectangular? z) (imag-part-rectangular (contents z))]
        [(polar? z) (imag-part-polar (contents z))]
        [else (error "Unknown type: IMAG-PART" z)]))

(define (magnitude z)
  (cond
    [(rectangular? z) (magnitude-rectangular (contents z))]
    [(polar? z) (magnitude-polar (contents z))]
    [else (error "Unknown type: MAGNITUDE" z)]))

(define (angle z)
  (cond
    [(rectangular? z) (angle-rectangular (contents z))]
    [(polar? z) (angle-polar (contents z))]
    [else (error "Unknown type: ANGLE" z)]))

(define (make-from-real-imag x y)
  (make-from-real-imag-rectangular x y))

(define (make-from-mag-ang r a)
  (make-from-mag-ang-polar r a))
#+END_SRC

Note how the constructors of each representation add tags, and how the generic selectors remove tags before passing them to the implementation.

**** DONE 2.4.3 Data-Directed Programming and Additivity

#+begin_quote
The key idea of data-directed programming is to handle generic operations in programs by dealing explicitly with operation-and-type tables
#+end_quote

#+NAME: rectangular-package
#+BEGIN_SRC racket :noweb yes
(define (install-rectangular-package)
  ;; internal procedures
  (define (real-part z)
    (car z))
  (define (imag-part z)
    (cdr z))
  (define (make-from-real-imag x y)
    (cons x y))
  (define (magnitude z)
    (sqrt (+ (square (real-part z)) (square (imag-part z)))))
  (define (angle z)
    (atan (imag-part z) (real-part z)))
  (define (make-from-mag-ang r a)
    (cons (* r (cos a)) (* r (sin a))))
  ;; public interfaces
  (define (tag x)
    (attach-tag 'rectangular x))
  (put 'real-part '(rectangular) real-part)
  (put 'imag-part '(rectangular) imag-part)
  (put 'magnitude '(rectangular) magnitude)
  (put 'angle '(rectangular) angle)
  (put 'make-from-real-imag 'rectangular (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'rectangular (lambda (r a) (tag (make-from-mag-ang r a))))
  'done)
#+END_SRC

#+NAME: polar-package
#+BEGIN_SRC racket :noweb yes
(define (install-polar-package)
  ;; internal procedures
  (define (magnitude z)
    (car z))
  (define (angle z)
    (cdr z))
  (define (make-from-mag-ang r a)
    (cons r a))
  (define (real-part z)
    (* (magnitude z) (cos (angle z))))
  (define (imag-part z)
    (* (magnitude z) (sin (angle z))))
  (define (make-from-real-imag x y)
    (cons (sqrt (+ (square x) (square y))) (atan y x)))

  ;; interface to the rest of the system
  (define (tag x)
    (attach-tag 'polar x))
  (put 'real-part '(polar) real-part)
  (put 'imag-part '(polar) imag-part)
  (put 'magnitude '(polar) magnitude)
  (put 'angle '(polar) angle)
  (put 'make-from-real-imag 'polar (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'polar (lambda (r a) (tag (make-from-mag-ang r a))))
  'done)
#+END_SRC

As to why some types are in parentheses and some are not, per footnote 45 and 46:

#+begin_quote
We use the list (rectangular) rather than the symbol rectangular to allow for the possibility of operations with multiple arguments, not all of the same type.

The type the constructors are installed under needn’t be a list because a constructor is always used to make an object of one particular type.
#+end_quote

This certainly is a way to have namespaces. But kind of way too abstract at this point given that we will not be implementing ~put~ and ~get~ until Chapter 3.

#+BEGIN_SRC racket :noweb yes
#lang sicp

(apply + (list 1 2 3 4))
#+END_SRC

#+RESULTS:
: 10

#+BEGIN_SRC racket :noweb yes
#lang sicp

(define (apply-generic op . args)
  (let ([type-tags (map type-tag args)])
    (let ([proc (get op type-tags)])
      (if proc
          (apply proc (map contents args))
          (error "No method for these types: APPLY-GENERIC" (list op type-tags))))))
#+END_SRC

#+NAME: complex-selectors-constructor
#+BEGIN_SRC racket :noweb yes
(define (real-part z)
  (apply-generic 'real-part z))

(define (imag-part z)
  (apply-generic 'imag-part z))

(define (magnitude z)
  (apply-generic 'magnitude z))

(define (angle z)
  (apply-generic 'angle z))

(define (make-from-real-imag x y)
  ((get 'make-from-real-imag 'rectangular) x y))

(define (make-from-mag-ang r a)
  ((get 'make-from-mag-ang 'polar) r a))
#+END_SRC


Note the dotted-tail syntax here (~args~ becomes a list).

***** DONE Exercise 2.73
:PROPERTIES:
:CUSTOM_ID: exercise-2.73
:END:

Section [[#section-2.3.2][2.3.2]] described a program that performs symbolic differentiation:

#+BEGIN_SRC scheme
(define (deriv exp var)
  (cond ((number? exp) 0)
        ((variable? exp) (if (same-variable? exp var) 1 0))
        ((sum? exp)
         (make-sum (deriv (addend exp) var)
                   (deriv (augend exp) var)))
        ((product? exp)
         (make-sum
          (make-product (multiplier exp)
                        (deriv (multiplicand exp) var))
          (make-product (deriv (multiplier exp) var)
                        (multiplicand exp))))
        <MORE RULES CAN BE ADDED HERE>
        (else (error "unknown expression type - DERIV" exp))))
#+END_SRC

We can regard this program as performing a dispatch on the type of the expression to be differentiated.  In this situation the "type tag" of the datum is the algebraic operator symbol (such as ~+~) and the operation being performed is ~deriv~.  We can transform this program into data-directed style by rewriting the basic derivative procedure as

#+BEGIN_SRC scheme
(define (deriv exp var)
  (cond ((number? exp) 0)
        ((variable? exp) (if (same-variable? exp var) 1 0))
        (else ((get 'deriv (operator exp)) (operands exp)
               var))))

(define (operator exp) (car exp))

(define (operands exp) (cdr exp))
#+END_SRC

a. Explain what was done above.  Why can't we assimilate the predicates ~number?~ and ~same-variable?~ into the data-directed dispatch?

   Ugh since the data-directed table is not provided, explaining it gets somewhat too abstract for me; the two predicates remain because ~operator~ and ~operands~ do not return meaningfully for them (although I suppose you can still do it if you want to).

b. Write the procedures for derivatives of sums and products, and the auxiliary code required to install them in the table used by the program above.

c. Choose any additional differentiation rule that you like, such as the one for exponents ([[#exercise-2.56][Exercise 2.56]]), and install it in this data-directed system.

To have the table and ~get~, ~put~, from http://jots-jottings.blogspot.com/2011/12/sicp-exercise-273-data-directed.html:

   #+BEGIN_SRC racket :noweb yes
#lang racket

(require rnrs/base-6)
(require rnrs/mutable-pairs-6)

(define (assoc key records)
  (cond
    [(null? records) false]
    [(equal? key (caar records)) (car records)]
    [else (assoc key (cdr records))]))

(define (make-table)
  (let ([local-table (list '*table*)])
    (define (lookup key-1 key-2)
      (let ([subtable (assoc key-1 (cdr local-table))])
        (if subtable
            (let ([record (assoc key-2 (cdr subtable))]) (if record (cdr record) false))
            false)))
    (define (insert! key-1 key-2 value)
      (let ([subtable (assoc key-1 (cdr local-table))])
        (if subtable
            (let ([record (assoc key-2 (cdr subtable))])
              (if record
                  (set-cdr! record value)
                  (set-cdr! subtable (cons (cons key-2 value) (cdr subtable)))))
            (set-cdr! local-table (cons (list key-1 (cons key-2 value)) (cdr local-table)))))
      'insertion_complete)
    (define (dispatch m)
      (cond
        [(eq? m 'lookup-proc) lookup]
        [(eq? m 'insert-proc!) insert!]
        [else (error "Unknown operation -- TABLE" m)]))
    dispatch))

(define operation-table (make-table))
(define get (operation-table 'lookup-proc))
(define put (operation-table 'insert-proc!))
   #+END_SRC

#+NAME: deriv-math
#+BEGIN_SRC racket :noweb yes
(define (variable? x)
  (symbol? x))

(define (same-variable? v1 v2)
  (and (variable? v1) (variable? v2) (eq? v1 v2)))

(define (=number? exp num)
  (and (number? exp) (= exp num)))

(define (make-sum a1 a2)
  (cond
    [(=number? a1 0) a2]
    [(=number? a2 0) a1]
    [(and (number? a1) (number? a2)) (+ a1 a2)]
    [else (list '+ a1 a2)]))

(define (make-product m1 m2)
  (cond
    [(or (=number? m1 0) (=number? m2 0)) 0]
    [(=number? m1 1) m2]
    [(=number? m2 1) m1]
    [(and (number? m1) (number? m2)) (* m1 m2)]
    [else (list '* m1 m2)]))

(define (make-exponentiation base exponent)
  (cond
    [(=number? exponent 0) 1]
    [(=number? exponent 1) base]
    [(and (number? base) (number? exponent) (expt base exponent))]
    [else (list '** base exponent)]))

(define (sum? x)
  (and (pair? x) (eq? (car x) '+)))

(define (addend s)
  (cadr s))

(define (augend s)
  (if (pair? (cdddr s)) (make-sum (addend (cdr s)) (augend (cdr s))) (caddr s)))

(define (product? x)
  (and (pair? x) (eq? (car x) '*)))

(define (multiplier p)
  (cadr p))

(define (multiplicand p)
  (if (pair? (cdddr p)) (make-product (multiplier (cdr p)) (multiplicand (cdr p))) (caddr p)))

(define (exponentiation? x)
  (and (pair? x) (eq? (car x) '**)))

(define (base e)
  (cadr e))

(define (exponent e)
  (caddr e))
#+END_SRC

 
#+BEGIN_SRC racket :noweb yes
<<data-directed-table>>
<<deriv-math>>

(define (deriv exp var)
  (cond
    [(number? exp) 0]
    [(variable? exp) (if (same-variable? exp var) 1 0)]
    [else ((get 'deriv (operator exp)) (operands exp) var)]))

(define (operator exp)
  (car exp))

(define (operands exp)
  (cdr exp))

(define (install-deriv-sum)
  (define (deriv-sum ops var)
    (make-sum (deriv (car ops) var) (deriv (cadr ops) var)))
  (put 'deriv '+ deriv-sum))

(define (install-deriv-product)
  (define (deriv-product ops var)
    (make-sum (make-product (car ops) (deriv (cadr ops) var))
              (make-product (deriv (car ops) var) (cadr ops))))
  (put 'deriv '* deriv-product))

(install-deriv-sum)
(install-deriv-product)

(deriv '(+ x (* 3 (+ x y 2))) 'x)
 #+END_SRC

 #+RESULTS:
 : 'insertion_complete
 : 'insertion_complete
 : 4

d. In this simple algebraic manipulator the type of an expression is the algebraic operator that binds it together.  Suppose, however, we indexed the procedures in the opposite way, so that the dispatch line in ~deriv~ looked like

#+BEGIN_SRC scheme
((get (operator exp) 'deriv) (operands exp) var)
#+END_SRC

What corresponding changes to the derivative system are required?

I suppose you need to change every ~put~ in there.

***** DONE Exercise 2.74
:PROPERTIES:
:CUSTOM_ID: exercise-2.74
:END:

Insatiable Enterprises, Inc., is a highly decentralized conglomerate company consisting of a large number of independent divisions located all over the world.  The company's computer facilities have just been interconnected by means of a clever network-interfacing scheme that makes the entire network appear to any user to be a single computer.  Insatiable's president, in her first attempt to exploit the ability of the network to extract administrative information from division files, is dismayed to discover that, although all the division files have been implemented as data structures in Scheme, the particular data structure used varies from division to division.  A meeting of division managers is hastily called to search for a strategy to integrate the files that will satisfy headquarters' needs while preserving the existing autonomy of the divisions.

Show how such a strategy can be implemented with data-directed programming.  As an example, suppose that each division's personnel records consist of a single file, which contains a set of records keyed on employees' names.  The structure of the set varies from division to division.  Furthermore, each employee's record is itself a set (structured differently from division to division) that contains information keyed under identifiers such as ~address~ and ~salary~.  In particular:

Again I find this exercise too abstract; it's more like writing pseudocode...

a. Implement for headquarters a ~get-record~ procedure that retrieves a specified employee's record from a specified personnel file.  The procedure should be applicable to any division's file.  Explain how the individual divisions' files should be structured.  In particular, what type information must be supplied?

#+BEGIN_SRC racket :noweb yes
(define (attach-division type-tag contents)
  (cons type-tag contents))

(define (division datum)
  (if (pair? datum) (car datum) (error "Bad tagged datum: TYPE-TAG" datum)))

(define (contents datum)
  (if (pair? datum) (cdr datum) (error "Bad tagged datum: CONTENTS" datum)))

(define (get-record employee personnel-file)
  (let ([record ((get 'get-record (division personnel-file)) employee (contents personnel-file))])
    (if record (attach-division (division personnel-file) record) #f)))
   #+END_SRC

b. Implement for headquarters a ~get-salary~ procedure that returns the salary information from a given employee's record from any division's personnel file.  How should the record be structured in order to make this operation work?

#+BEGIN_SRC racket :noweb yes
(define (get-salary record)
  ((get 'get-salary (division record)) (contents record)))
#+END_SRC

c. Implement for headquarters a ~find-employee-record~ procedure.  This should search all the divisions' files for the record of a given employee and return the record.  Assume that this procedure takes as arguments an employee's name and a list of all the divisions' files.

Tail recursion for a loop; this is getting old...

#+BEGIN_SRC racket :noweb yes
#lang sicp

(define (find-employee-record employee personnel-files)
  (if (null? personnel-files)
      #f
      (let ([record (get-record employee (car personnel-files))])
        (if record record (find-employee-record employee (cdr personnel-files))))))
#+END_SRC


d. When Insatiable takes over a new company, what changes must be made in order to incorporate the new personnel information into the central system?

- give the division a tag
- install division-specific procedures into the table
- add the personnel file to the list

There is a complete mockup at http://jots-jottings.blogspot.com/2011/12/sicp-exercise-274-insatiable-insanity.html.

***** Message Passing

Instead of intelligent operations that handle different data types, we have intelligent data objects that handle different operations.

***** DONE Exercise 2.75
:PROPERTIES:
:CUSTOM_ID: exercise-2.75
:END:

Implement the constructor ~make-from-mag-ang~ in message-passing style.  This procedure should be analogous to the ~make-from-real-imag~ procedure given above.

#+BEGIN_SRC racket :noweb yes
#lang sicp
<<square>>

(define (make-from-real-imag x y)
  (define (dispatch op)
    (cond
      [(eq? op 'real-part) x]
      [(eq? op 'imag-part) y]
      [(eq? op 'magnitude) (sqrt (+ (square x) (square y)))]
      [(eq? op 'angle) (atan y x)]
      [else (error "Unknown op: MAKE-FROM-REAL-MAG" op)]))
  dispatch)

(define (make-from-mag-ang mag ang)
  (define (dispatch op)
    (cond
      [(eq? op 'real-part) (* mag (cos ang))]
      [(eq? op 'imag-part) (* mag (sin ang))]
      [(eq? op 'magnitude) mag]
      [(eq? op 'angle) ang]
      [else (error "Unknown op: MAKE-FROM-MAG-ANG" op)]))
  dispatch)

(define (apply-generic op arg)
  (arg op))

(define PI 3.141592653589793)
(define a (make-from-mag-ang 1 (/ PI 4)))
(define b (make-from-real-imag 0.707 0.707))

(apply-generic 'real-part a)
(apply-generic 'imag-part a)

(apply-generic 'magnitude b)
(apply-generic 'angle b)
#+END_SRC

#+RESULTS:
: 0.7071067811865476
: 0.7071067811865475
: 0.9998489885977782
: 0.7853981633974483

***** DONE Exercise 2.76
:PROPERTIES:
:CUSTOM_ID: exercise-2.76
:END:

As a large system with generic operations evolves, new types of data objects or new operations may be needed.  For each of the three strategies--generic operations with explicit dispatch, data-directed style, and message-passing-style--describe the changes that must be made to a system in order to add new types or new operations.  Which organization would be most appropriate for a system in which new types must often be added?  Which would be most appropriate for a system in which new operations must often be added?

- Explicit Dispatch
  - new types: each operation needs to be changed
  - new operations: add the new generic operation and the operations that deal with each type that the generic operation dispatches
- Data-Directed
  - new types: register new operations that handle existing generic operations into the table
  - new operations: add operations that deal with each existing type and the generic operation; add the generic operation to the table
- Message-Passing
  - new types: a new constructor that constructs the "intelligent object" that dispatches procedures on operation names for the new type
  - new operations: update the constructor of each type to handle the message for the new operation, and add any type-specific procedures that will be dispatched
    
*** DROPPED 2.5 Systems with Generic Operations
**** DONE 2.5.1 Generic Arithmetic Operations

#+BEGIN_SRC racket :noweb yes
<<data-directed-table>>
<<tagging>>
<<apply-generic>>
<<rectangular-package>>
<<polar-package>>
<<complex-selectors-constructor>>
<<square>>

(define (add x y)
  (apply-generic 'add x y))
(define (sub x y)
  (apply-generic 'sub x y))
(define (mul x y)
  (apply-generic 'mul x y))
(define (div x y)
  (apply-generic 'div x y))

(define (install-scheme-number-package)
  (define (tag x)
    (attach-tag 'scheme-number x))
  (put 'add '(scheme-number scheme-number) (lambda (x y) (tag (+ x y))))
  (put 'sub '(scheme-number scheme-number) (lambda (x y) (tag (- x y))))
  (put 'mul '(scheme-number scheme-number) (lambda (x y) (tag (* x y))))
  (put 'div '(scheme-number scheme-number) (lambda (x y) (tag (/ x y))))
  (put 'make 'scheme-number (lambda (x) (tag x)))
  'done)

(define (make-scheme-number n)
  ((get 'make 'scheme-number) n))

(define (install-rational-package)
  ;; internal procedures
  (define (numer x)
    (car x))
  (define (denom x)
    (cdr x))
  (define (make-rat n d)
    (let ([g (gcd n d)]) (cons (/ n g) (/ d g))))
  (define (add-rat x y)
    (make-rat (+ (* (numer x) (denom y)) (* (numer y) (denom x))) (* (denom x) (denom y))))
  (define (sub-rat x y)
    (make-rat (- (* (numer x) (denom y)) (* (numer y) (denom x))) (* (denom x) (denom y))))
  (define (mul-rat x y)
    (make-rat (* (numer x) (numer y)) (* (denom x) (denom y))))
  (define (div-rat x y)
    (make-rat (* (numer x) (denom y)) (* (denom x) (numer y))))

  ;; interface to rest of the system
  (define (tag x)
    (attach-tag 'rational x))
  (put 'add '(rational rational) (lambda (x y) (tag (add-rat x y))))
  (put 'sub '(rational rational) (lambda (x y) (tag (sub-rat x y))))
  (put 'mul '(rational rational) (lambda (x y) (tag (mul-rat x y))))
  (put 'div '(rational rational) (lambda (x y) (tag (div-rat x y))))

  (put 'make 'rational (lambda (n d) (tag (make-rat n d))))
  'done)

(define (make-rational n d)
  ((get 'make 'rational) n d))

(define (install-complex-package)
  ;; imported procedures from rectangular and polar packages
  (define (make-from-real-imag x y)
    ((get 'make-from-real-imag 'rectangular) x y))
  (define (make-from-mag-ang r a)
    ((get 'make-from-mag-ang 'polar) r a))

  ;; internal procedures
  (define (add-complex z1 z2)
    (make-from-real-imag (+ (real-part z1) (real-part z2)) (+ (imag-part z1) (imag-part z2))))
  (define (sub-complex z1 z2)
    (make-from-real-imag (- (real-part z1) (real-part z2)) (- (imag-part z1) (imag-part z2))))
  (define (mul-complex z1 z2)
    (make-from-mag-ang (* (magnitude z1) (magnitude z2)) (+ (angle z1) (angle z2))))
  (define (div-complex z1 z2)
    (make-from-mag-ang (/ (magnitude z1) (magnitude z2)) (- (angle z1) (angle z2))))

  ;; interface to rest of the system
  (define (tag z)
    (attach-tag 'complex z))
  (put 'add '(complex complex) (lambda (z1 z2) (tag (add-complex z1 z2))))
  (put 'sub '(complex complex) (lambda (z1 z2) (tag (sub-complex z1 z2))))
  (put 'mul '(complex complex) (lambda (z1 z2) (tag (mul-complex z1 z2))))
  (put 'div '(complex complex) (lambda (z1 z2) (tag (div-complex z1 z2))))
  (put 'make-from-real-imag 'complex (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'complex (lambda (r a) (tag (make-from-mag-ang r a))))
  (put 'real-part '(complex) real-part)
  (put 'imag-part '(complex) imag-part)
  (put 'magnitude '(complex) magnitude)
  (put 'angle '(complex) angle)
  'done)

(define (make-complex-from-real-imag x y)
  ((get 'make-from-real-imag 'complex) x y))

(define (make-complex-from-mag-ang r a)
  ((get 'make-from-mag-ang 'complex) r a))

(install-rectangular-package)
(install-polar-package)
(install-scheme-number-package)
(install-rational-package)
(install-complex-package)
(define z (make-complex-from-real-imag 0.707 0.707))
(magnitude z)
#+END_SRC

#+RESULTS:
: 'done
: 'done
: 'done
: 'done
: 'done
: 0.9998489885977782

Finally got it working. Note that per the book, we indicate operations that take two arguments with their type/key in the table  (~(scheme-number scheme-number)~, ~(rational rational)~, ~(complex, complex)~). But the constructors for ~rational~ and ~complex~ also take two arguments; they are keyed differently because...I don't know...

***** DONE Exercise 2.77
:PROPERTIES:
:CUSTOM_ID: exercise-2.77
:END:

Louis Reasoner tries to evaluate the expression ~(magnitude z)~ where ~z~ is the object shown in [[figure-2.24][Figure 2.24]].  To his surprise, instead of the answer 5 he gets an error message from ~apply-generic~, saying there is no method for the operation ~magnitude~ on the types ~(complex)~.  He shows this interaction to Alyssa P. Hacker, who says "The problem is that the complex-number selectors were never defined for ~complex~ numbers, just for ~polar~ and ~rectangular~ numbers.  All you have to do to make this work is add the following to the ~complex~ package:"

#+BEGIN_SRC scheme
(put 'real-part '(complex) real-part)
(put 'imag-part '(complex) imag-part)
(put 'magnitude '(complex) magnitude)
(put 'angle '(complex) angle)
#+END_SRC

Describe in detail why this works.  As an example, trace through all the procedures called in evaluating the expression ~(magnitude z)~ where ~z~ is the object shown in [[figure-2.24][Figure 2.24]].  In particular, how many times is ~apply-generic~ invoked?  What procedure is dispatched to in each case?

An exceedingly good stack trace from http://jots-jottings.blogspot.com/2012/01/sicp-exercise-277-tracing-magnitude.html below:

#+begin_example
  (magnitude z)
= (apply-generic 'magnitude z)
= (let ((type-tags (map type-tag (z))))
    (let ((proc (get 'magnitude type-tags)))
      (if proc
          (apply proc (map contents (z)))
          (error
            "No method for these types -- APPLY-GENERIC"
            (list 'magnitude type-tags))))))
= (let ((type-tags '(complex)))
    (let ((proc (get 'magnitude type-tags)))
      (if proc
          (apply proc (map contents (z)))
          (error
            "No method for these types -- APPLY-GENERIC"
            (list 'magnitude type-tags))))))
= (let ((proc (get 'magnitude '(complex))))
    (if proc
        (apply proc (map contents (z)))
        (error
          "No method for these types -- APPLY-GENERIC"
          (list 'magnitude '(complex)))))))
= (let ((proc magnitude))
    (if proc
        (apply proc (map contents (z)))
        (error
          "No method for these types -- APPLY-GENERIC"
          (list 'magnitude '(complex)))))))
= (if magnitude
      (apply magnitude (map contents (z)))
      (error
        "No method for these types -- APPLY-GENERIC"
        (list 'magnitude '(complex)))))))
= (apply magnitude (map contents (z)))
= (apply magnitude (('rectangular (3 4))))
≡ (magnitude ('rectangular (3 4)))
= (apply-generic 'magnitude ('rectangular (3 4)))
= (let ((type-tags (map type-tag (('rectangular (3 4))))))
    (let ((proc (get 'magnitude type-tags)))
      (if proc
          (apply proc (map contents (('rectangular (3 4)))))
          (error
            "No method for these types -- APPLY-GENERIC"
            (list 'magnitude type-tags))))))
= (let ((type-tags '(rectangular)))
    (let ((proc (get 'magnitude type-tags)))
      (if proc
          (apply proc (map contents (('rectangular (3 4)))))
          (error
            "No method for these types -- APPLY-GENERIC"
            (list 'magnitude type-tags))))))
= (let ((proc (get 'magnitude '(rectangular))))
    (if proc
        (apply proc (map contents (('rectangular (3 4)))))
        (error
          "No method for these types -- APPLY-GENERIC"
          (list 'magnitude '(rectangular)))))))
= (let ((proc rectangular->magnitude))
    (if proc
        (apply proc (map contents (('rectangular (3 4)))))
        (error
          "No method for these types -- APPLY-GENERIC"
          (list 'magnitude '(rectangular)))))))
= (if rectangular->magnitude
      (apply rectangular->magnitude (map contents (('rectangular (3 4)))))
      (error
        "No method for these types -- APPLY-GENERIC"
        (list 'magnitude '(rectangular)))))))
= (apply rectangular->magnitude (map contents (('rectangular (3 4)))))
= (apply rectangular->magnitude ((3 4)))
≡ (rectangular->magnitude (3 4))
= (sqrt (+ (square (real-part (3 4)))
           (square (imag-part (3 4))))))
= (sqrt (+ (square (car (3 4))) (square (cdr (3 4))))))
= (sqrt (+ (square 3) (square 4)))
= (sqrt (+ (* 3 3) (* 4 4)))
= (sqrt (+ 9 16))
= (sqrt 25)
= 5
#+end_example

***** DONE Exercise 2.78
:PROPERTIES:
:CUSTOM_ID: exercise-2.78
:END:

The internal procedures in the ~scheme-number~ package are essentially nothing more than calls to the primitive procedures +, -, etc.  It was not possible to use the primitives of the language directly because our type-tag system requires that each data object have a type attached to it.  In fact, however, all Lisp implementations do have a type system, which they use internally.  Primitive predicates such as ~symbol?~ and ~number?~ determine whether data objects have particular types.  Modify the definitions of ~type-tag~, ~contents~, and ~attach-tag~ from section [[#section-2.4.2][2.4.2]] so that our generic system takes advantage of Scheme's internal type system.  That is to say, the system should work as before except that ordinary numbers should be represented simply as Scheme numbers rather than as pairs whose ~car~ is the symbol ~scheme-number~.

before:

#+BEGIN_SRC racket :noweb yes
(define (attach-tag type-tag contents)
  (cons type-tag contents))

(define (type-tag datum)
  (if (pair? datum)
      (car datum)
      (error "Bad tagged datum - TYPE-TAG" datum)))

(define (contents datum)
  (if (pair? datum)
      (cdr datum)
      (error "Bad tagged datum - CONTENTS" datum)))
#+END_SRC

after:

#+BEGIN_SRC racket :noweb yes
(define (attach-tag type-tag contents)
  (if (eq? type-tag 'scheme-number) contents (cons type-tag contents)))

(define (type-tag datum)
  (cond
    [(number? datum) 'scheme-number]
    [(pair? datum) (car datum)]
    [else (error "Bad tagged datum - TYPE-TAG" datum)]))

(define (contents datum)
  (cond
    [(number? datum) datum]
    [(pair? datum) (cdr datum)]
    [else (error "Bad tagged datum - CONTENTS" datum)]))

(attach-tag 'scheme-number 42)
(attach-tag 'rational 42)
#+END_SRC

#+RESULTS:
: 42
: '(rational . 42)

***** DONE Exercise 2.79
:PROPERTIES:
:CUSTOM_ID: exercise-2.79
:END:

Define a generic equality predicate ~equ?~ that tests the equality of two numbers, and install it in the generic arithmetic package.  This operation should work for ordinary numbers, rational numbers, and complex numbers.

#+BEGIN_SRC racket :noweb yes
<<data-directed-table>>
<<tagging>>
<<apply-generic>>
<<rectangular-package>>
<<polar-package>>
<<complex-selectors-constructor>>
<<square>>

(define (add x y)
  (apply-generic 'add x y))
(define (sub x y)
  (apply-generic 'sub x y))
(define (mul x y)
  (apply-generic 'mul x y))
(define (div x y)
  (apply-generic 'div x y))
(define (equ? x y)
  (apply-generic 'equ? x y))

(define (install-scheme-number-package)
  (define (tag x)
    (attach-tag 'scheme-number x))
  (put 'add '(scheme-number scheme-number) (lambda (x y) (tag (+ x y))))
  (put 'sub '(scheme-number scheme-number) (lambda (x y) (tag (- x y))))
  (put 'mul '(scheme-number scheme-number) (lambda (x y) (tag (* x y))))
  (put 'div '(scheme-number scheme-number) (lambda (x y) (tag (/ x y))))
  (put 'equ? '(scheme-number scheme-number) (lambda (x y) (= x y)))
  (put 'make 'scheme-number (lambda (x) (tag x)))
  'done)

(define (make-scheme-number n)
  ((get 'make 'scheme-number) n))

(define (install-rational-package)
  ;; internal procedures
  (define (numer x)
    (car x))
  (define (denom x)
    (cdr x))
  (define (make-rat n d)
    (let ([g (gcd n d)]) (cons (/ n g) (/ d g))))
  (define (add-rat x y)
    (make-rat (+ (* (numer x) (denom y)) (* (numer y) (denom x))) (* (denom x) (denom y))))
  (define (sub-rat x y)
    (make-rat (- (* (numer x) (denom y)) (* (numer y) (denom x))) (* (denom x) (denom y))))
  (define (mul-rat x y)
    (make-rat (* (numer x) (numer y)) (* (denom x) (denom y))))
  (define (div-rat x y)
    (make-rat (* (numer x) (denom y)) (* (denom x) (numer y))))
  (define (equ?-rat x y)
    (and (= (numer x) (numer y)) (= (denom x) (denom y))))

  ;; interface to rest of the system
  (define (tag x)
    (attach-tag 'rational x))
  (put 'add '(rational rational) (lambda (x y) (tag (add-rat x y))))
  (put 'sub '(rational rational) (lambda (x y) (tag (sub-rat x y))))
  (put 'mul '(rational rational) (lambda (x y) (tag (mul-rat x y))))
  (put 'div '(rational rational) (lambda (x y) (tag (div-rat x y))))
  (put 'equ? '(rational rational) (lambda (x y) (equ?-rat x y)))

  (put 'make 'rational (lambda (n d) (tag (make-rat n d))))
  'done)

(define (make-rational n d)
  ((get 'make 'rational) n d))

(define (install-complex-package)
  ;; imported procedures from rectangular and polar packages
  (define (make-from-real-imag x y)
    ((get 'make-from-real-imag 'rectangular) x y))
  (define (make-from-mag-ang r a)
    ((get 'make-from-mag-ang 'polar) r a))

  ;; internal procedures
  (define (add-complex z1 z2)
    (make-from-real-imag (+ (real-part z1) (real-part z2)) (+ (imag-part z1) (imag-part z2))))
  (define (sub-complex z1 z2)
    (make-from-real-imag (- (real-part z1) (real-part z2)) (- (imag-part z1) (imag-part z2))))
  (define (mul-complex z1 z2)
    (make-from-mag-ang (* (magnitude z1) (magnitude z2)) (+ (angle z1) (angle z2))))
  (define (div-complex z1 z2)
    (make-from-mag-ang (/ (magnitude z1) (magnitude z2)) (- (angle z1) (angle z2))))
  (define (equ?-complex z1 z2)
    (and (= (real-part z1) (real-part z2)) (= (imag-part z1) (imag-part z2))))

  ;; interface to rest of the system
  (define (tag z)
    (attach-tag 'complex z))
  (put 'add '(complex complex) (lambda (z1 z2) (tag (add-complex z1 z2))))
  (put 'sub '(complex complex) (lambda (z1 z2) (tag (sub-complex z1 z2))))
  (put 'mul '(complex complex) (lambda (z1 z2) (tag (mul-complex z1 z2))))
  (put 'div '(complex complex) (lambda (z1 z2) (tag (div-complex z1 z2))))
  (put 'equ? '(complex complex) (lambda (z1 z2) (equ?-complex z1 z2)))
  (put 'make-from-real-imag 'complex (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'complex (lambda (r a) (tag (make-from-mag-ang r a))))
  (put 'real-part '(complex) real-part)
  (put 'imag-part '(complex) imag-part)
  (put 'magnitude '(complex) magnitude)
  (put 'angle '(complex) angle)
  'done)

(define (make-complex-from-real-imag x y)
  ((get 'make-from-real-imag 'complex) x y))

(define (make-complex-from-mag-ang r a)
  ((get 'make-from-mag-ang 'complex) r a))

(install-rectangular-package)
(install-polar-package)
(install-scheme-number-package)
(install-rational-package)
(install-complex-package)

(equ? (make-scheme-number 5) (make-scheme-number 5))
(equ? (make-rational 1 2) (make-rational 2 4))
(equ? (make-complex-from-real-imag 3 0) (make-complex-from-mag-ang 3 0))
#+END_SRC

#+RESULTS:
: 'done
: 'done
: 'done
: 'done
: 'done
: #t
: #t
: #t

***** DONE Exercise 2.80
:PROPERTIES:
:CUSTOM_ID: exercise-2.80
:END:

Define a generic predicate ~=zero?~ that tests if its argument is zero, and install it in the generic arithmetic package.  This operation should work for ordinary numbers, rational numbers, and complex numbers.


#+BEGIN_SRC racket :noweb yes
<<data-directed-table>>
<<tagging>>
<<apply-generic>>
<<rectangular-package>>
<<polar-package>>
<<complex-selectors-constructor>>
<<square>>

(define (add x y)
  (apply-generic 'add x y))
(define (sub x y)
  (apply-generic 'sub x y))
(define (mul x y)
  (apply-generic 'mul x y))
(define (div x y)
  (apply-generic 'div x y))
(define (equ? x y)
  (apply-generic 'equ? x y))
(define (=zero? x)
  (apply-generic '=zero? x))

(define (install-scheme-number-package)
  (define (tag x)
    (attach-tag 'scheme-number x))
  (put 'add '(scheme-number scheme-number) (lambda (x y) (tag (+ x y))))
  (put 'sub '(scheme-number scheme-number) (lambda (x y) (tag (- x y))))
  (put 'mul '(scheme-number scheme-number) (lambda (x y) (tag (* x y))))
  (put 'div '(scheme-number scheme-number) (lambda (x y) (tag (/ x y))))
  (put 'equ? '(scheme-number scheme-number) (lambda (x y) (= x y)))
  (put '=zero? '(scheme-number) (lambda (x) (= 0 x)))
  (put 'make 'scheme-number (lambda (x) (tag x)))
  'done)

(define (make-scheme-number n)
  ((get 'make 'scheme-number) n))

(define (install-rational-package)
  ;; internal procedures
  (define (numer x)
    (car x))
  (define (denom x)
    (cdr x))
  (define (make-rat n d)
    (let ([g (gcd n d)]) (cons (/ n g) (/ d g))))
  (define (add-rat x y)
    (make-rat (+ (* (numer x) (denom y)) (* (numer y) (denom x))) (* (denom x) (denom y))))
  (define (sub-rat x y)
    (make-rat (- (* (numer x) (denom y)) (* (numer y) (denom x))) (* (denom x) (denom y))))
  (define (mul-rat x y)
    (make-rat (* (numer x) (numer y)) (* (denom x) (denom y))))
  (define (div-rat x y)
    (make-rat (* (numer x) (denom y)) (* (denom x) (numer y))))
  (define (equ?-rat x y)
    (and (= (numer x) (numer y)) (= (denom x) (denom y))))
  (define (=zero?-rat x)
    (= 0 (numer x)))

  ;; interface to rest of the system
  (define (tag x)
    (attach-tag 'rational x))
  (put 'add '(rational rational) (lambda (x y) (tag (add-rat x y))))
  (put 'sub '(rational rational) (lambda (x y) (tag (sub-rat x y))))
  (put 'mul '(rational rational) (lambda (x y) (tag (mul-rat x y))))
  (put 'div '(rational rational) (lambda (x y) (tag (div-rat x y))))
  (put 'equ? '(rational rational) (lambda (x y) (equ?-rat x y)))
  (put '=zero? '(rational) (lambda (x) (=zero?-rat x)))

  (put 'make 'rational (lambda (n d) (tag (make-rat n d))))
  'done)

(define (make-rational n d)
  ((get 'make 'rational) n d))

(define (install-complex-package)
  ;; imported procedures from rectangular and polar packages
  (define (make-from-real-imag x y)
    ((get 'make-from-real-imag 'rectangular) x y))
  (define (make-from-mag-ang r a)
    ((get 'make-from-mag-ang 'polar) r a))

  ;; internal procedures
  (define (add-complex z1 z2)
    (make-from-real-imag (+ (real-part z1) (real-part z2)) (+ (imag-part z1) (imag-part z2))))
  (define (sub-complex z1 z2)
    (make-from-real-imag (- (real-part z1) (real-part z2)) (- (imag-part z1) (imag-part z2))))
  (define (mul-complex z1 z2)
    (make-from-mag-ang (* (magnitude z1) (magnitude z2)) (+ (angle z1) (angle z2))))
  (define (div-complex z1 z2)
    (make-from-mag-ang (/ (magnitude z1) (magnitude z2)) (- (angle z1) (angle z2))))
  (define (equ?-complex z1 z2)
    (and (= (real-part z1) (real-part z2)) (= (imag-part z1) (imag-part z2))))
  (define (=zero?-complex z)
    (= 0 (magnitude z)))

  ;; interface to rest of the system
  (define (tag z)
    (attach-tag 'complex z))
  (put 'add '(complex complex) (lambda (z1 z2) (tag (add-complex z1 z2))))
  (put 'sub '(complex complex) (lambda (z1 z2) (tag (sub-complex z1 z2))))
  (put 'mul '(complex complex) (lambda (z1 z2) (tag (mul-complex z1 z2))))
  (put 'div '(complex complex) (lambda (z1 z2) (tag (div-complex z1 z2))))
  (put 'equ? '(complex complex) (lambda (z1 z2) (equ?-complex z1 z2)))
  (put '=zero? '(complex) (lambda (x) (=zero?-complex x)))
  (put 'make-from-real-imag 'complex (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'complex (lambda (r a) (tag (make-from-mag-ang r a))))
  (put 'real-part '(complex) real-part)
  (put 'imag-part '(complex) imag-part)
  (put 'magnitude '(complex) magnitude)
  (put 'angle '(complex) angle)
  'done)

(define (make-complex-from-real-imag x y)
  ((get 'make-from-real-imag 'complex) x y))

(define (make-complex-from-mag-ang r a)
  ((get 'make-from-mag-ang 'complex) r a))

(install-rectangular-package)
(install-polar-package)
(install-scheme-number-package)
(install-rational-package)
(install-complex-package)

(=zero? (sub (make-scheme-number 3) (make-scheme-number 3)))
(=zero? (add (make-rational 1 2) (make-rational -2 4)))
(=zero? (make-complex-from-mag-ang 0 42))
#+END_SRC

#+RESULTS:
: 'done
: 'done
: 'done
: 'done
: 'done
: #t
: #t
: #t

**** DONE 2.5.2 Combining Data of Different Types
***** Coercion
#+BEGIN_SRC racket :noweb yes
(define (apply-generic op . args)
  (let ([type-tags (map type-tag args)])
    (let ([proc (get op type-tags)])
      (if proc
          (apply proc (map contents args))
          (if (= (length args) 2)
              (let ([type1 (car type-tags)] [type2 (cadr type-tags)] [a1 (car args)] [a2 (cadr args)])
                (let ([t1->t2 (get-coercion type1 type2)] [t2->t1 (get-coercion type2 type1)])
                  (cond
                    [t1->t2 (apply-generic op (t1->t2 a1) a2)]
                    [t2->t1 (apply-generic op a1 (t2->t1 a2))]
                    [else (error "No method for these types" (list op type-tags))]))))
          (error "No method for these types" (list op type-args))))))
#+END_SRC

For cross-type operations, check if we can coerce one type into the other & apply operation for that type.

***** Hierarchies of Types

=complex -> real -> rational -> integer=
somewhat OOPish...and I thought class inheritence is bad

***** DONE Exercise 2.81
:PROPERTIES:
:CUSTOM_ID: exercise-2.81
:END:

Louis Reasoner has noticed that ~apply-generic~ may try to coerce the arguments to each other's type even if they already have the same type.  Therefore, he reasons, we need to put procedures in the coercion table to /coerce/ arguments of each type to their own type.  For example, in addition to the ~scheme-number->complex~ coercion shown above, he would do:

#+BEGIN_SRC scheme
(define (scheme-number->scheme-number n) n)
(define (complex->complex z) z)
(put-coercion 'scheme-number 'scheme-number
              scheme-number->scheme-number)
(put-coercion 'complex 'complex complex->complex)
#+END_SRC

a. With Louis's coercion procedures installed, what happens if ~apply-generic~ is called with two arguments of type ~scheme-number~ or two arguments of type ~complex~ for an operation that is not found in the table for those types?  For example, assume that we've defined a generic exponentiation operation:

#+BEGIN_SRC scheme
(define (exp x y) (apply-generic 'exp x y))
#+END_SRC

and have put a procedure for exponentiation in the Scheme-number package but not in any other package:

#+BEGIN_SRC scheme
;; following added to Scheme-number package
(put 'exp '(scheme-number scheme-number)
     (lambda (x y) (tag (expt x y)))) ; using primitive ~expt~
#+END_SRC

What happens if we call ~exp~ with two complex numbers as arguments?

It will be endless recursion as ~apply-generic~ tries to find the ~exp~ procedure for ~(complex complex)~, fails, then tries ~apply-generic~ again with the first argument coerced to the type of the second argument (so still ~(complex, complex)~) and repeats.

b. Is Louis correct that something had to be done about coercion with arguments of the same type, or does ~apply-generic~ work correctly as is?

If the procedure for the operation with arguments of the same type is defined, ~apply-generic~ will find it and correctly apply it; if it is not defined, both the ~get-coercion~ calls will fail, and ~apply-generic~ will raise an error message as expected.

c. Modify ~apply-generic~ so that it doesn't try coercion if the two arguments have the same type.

   #+BEGIN_SRC racket :noweb yes
   (define (apply-generic op . args)
     (let ([type-tags (map type-tag args)])
       (let ([proc (get op type-tags)])
         (if proc
             (apply proc (map contents args))
             (if (= (length args) 2)
                 (let ([type1 (car type-tags)] [type2 (cadr type-tags)] [a1 (car args)] [a2 (cadr args)])
                   (if (not (eq? type1 type2))
                       (let ([t1->t2 (get-coercion type1 type2)] [t2->t1 (get-coercion type2 type1)])
                         (cond
                           [t1->t2 (apply-generic op (t1->t2 a1) a2)]
                           [t2->t1 (apply-generic op a1 (t2->t1 a2))]
                           [else (error "No method for these types" (list op type-tags))]))
                       (error "No method for these types" (list op type-tags))))
                 (error "No method for these types" (list op type-tags)))))))
#+END_SRC

***** DONE Exercise 2.82
:PROPERTIES:
:CUSTOM_ID: exercise-2.82
:END:

#+begin_quote
Show how to generalize ~apply-generic~ to handle coercion in the general case of multiple arguments.  One strategy is to attempt to coerce all the arguments to the type of the first argument, then to the type of the second argument, and so on.  Give an example of a situation where this strategy (and likewise the two-argument version given above) is not sufficiently general.  (Hint: Consider the case where there are some suitable mixed-type operations present in the table that will not be tried.)
#+end_quote

I spent way too much time thinking about why it would want to successively coerce the arguments, instead of, perhaps, mapping coercion to each of them; then I realized it should be done in ~apply-generic~, which currently does not handle multiple arguments--which is actually the bigger problem in this exercise.

Actually, I still don't think I understand what it wants to do; let's consider if we have 4 arguments of the types =complex -> real -> rational -> integer=; we should indeed be able to convert all of them to ~complex~; then we are done?

On the other hand, if the arguments are in the other order (=integer <- rational <- real <- complex=), the coercions would fail until we try to convert the arguments all to the type of the last argument (~complex~). The idea here, I see, is that when you have a linear "tower" hierarchy of types, you can eventually find the supertype to promote everything to. This however quickly breaks down when you have the more complex type relations as the book just explained.

This implementation would sidestep all mixed-type operations, if I understand the prompt correctly? I suppose it depends on when you "attempt to coerce all arguments to the type of ..."; right now though, ~apply-generic~ tries to apply a procedure and only then attempts to coerce. Maybe that is the point?

So I am confused; I do not see the point of converting *all the arguments* all at once. I suppose that is because so far we have not had procedures that take more than two arguments, so you can always just take two at a time. In fact, what would a mixed-type variadic procedure even look like? The type tags we register in the table are fixed length...

#+BEGIN_SRC racket :noweb yes
(define (coerce object type)
  (let ([coercion (get-coercion (type-tag object) type)]) (if coercion (coercion object) #f)))

(define (coerce-all objects)
  (define (iter remaining)
    (if (null? remaining)
        #f
        (let ([coerced (map (lambda (object) (coerce object (type-tag (car remaining)))) objects)])
          (if (memq #f coerced) (iter (cdr remaining)) coerced))))
  (iter objects))

(define (apply-generic op . args)
  ;; let* makes value available one by one
  (let* ([type-tags (map type-tag args)] [proc (get op type-tags)])
    (if proc
        (apply proc (map contents args))
        (let ([coerced (coerce-all args)])
          (if coerced
              (apply-generic op coerced)
              (error "No method for these types" (list op type-tags)))))))
#+END_SRC

This is what I come up with after sticking to the prompt. Sign I wish it were easier to run code in this section...


#+BEGIN_SRC racket :noweb yes
<<data-directed-table>>
<<tagging>>
<<rectangular-package>>
<<polar-package>>
<<complex-selectors-constructor>>
<<square>>

(define (coerce object type)
  (let ([coercion (get-coercion (type-tag object) type)]) (if coercion (coercion object) #f)))

(define (coerce-all objects)
  (define (iter remaining)
    (if (null? remaining)
        #f
        (let ([coerced (map (lambda (object) (coerce object (type-tag (car remaining)))) objects)])
          (if (memq #f coerced) (iter (cdr remaining)) coerced))))
  (iter objects))

(define (put-coercion source-type target-type proc)
  (put 'coercion (list source-type target-type) proc))

(define (get-coercion source-type target-type)
  (get 'coercion (list source-type target-type)))

(define (scheme-number->complex n)
  (make-complex-from-real-imag (contents n) 0))

(put-coercion 'scheme-number 'complex scheme-number->complex)

(define (apply-generic op . args)
  ;; let* makes value available one by one
  (let* ([type-tags (map type-tag args)] [proc (get op type-tags)])
    (if proc
        (apply proc (map contents args))
        (let ([coerced (coerce-all args)])
          (if coerced
              (apply-generic op coerced)
              (error "No method for these types" (list op type-tags)))))))

(define (add x y)
  (apply-generic 'add x y))
(define (sub x y)
  (apply-generic 'sub x y))
(define (mul x y)
  (apply-generic 'mul x y))
(define (div x y)
  (apply-generic 'div x y))
(define (equ? x y)
  (apply-generic 'equ? x y))
(define (=zero? x)
  (apply-generic '=zero? x))

(define (install-scheme-number-package)
  (define (tag x)
    (attach-tag 'scheme-number x))
  (put 'add '(scheme-number scheme-number) (lambda (x y) (tag (+ x y))))
  (put 'sub '(scheme-number scheme-number) (lambda (x y) (tag (- x y))))
  (put 'mul '(scheme-number scheme-number) (lambda (x y) (tag (* x y))))
  (put 'div '(scheme-number scheme-number) (lambda (x y) (tag (/ x y))))
  (put 'equ? '(scheme-number scheme-number) (lambda (x y) (= x y)))
  (put '=zero? '(scheme-number) (lambda (x) (= 0 x)))
  (put 'make 'scheme-number (lambda (x) (tag x)))
  'done)

(define (make-scheme-number n)
  ((get 'make 'scheme-number) n))

(define (install-rational-package)
  ;; internal procedures
  (define (numer x)
    (car x))
  (define (denom x)
    (cdr x))
  (define (make-rat n d)
    (let ([g (gcd n d)]) (cons (/ n g) (/ d g))))
  (define (add-rat x y)
    (make-rat (+ (* (numer x) (denom y)) (* (numer y) (denom x))) (* (denom x) (denom y))))
  (define (sub-rat x y)
    (make-rat (- (* (numer x) (denom y)) (* (numer y) (denom x))) (* (denom x) (denom y))))
  (define (mul-rat x y)
    (make-rat (* (numer x) (numer y)) (* (denom x) (denom y))))
  (define (div-rat x y)
    (make-rat (* (numer x) (denom y)) (* (denom x) (numer y))))
  (define (equ?-rat x y)
    (and (= (numer x) (numer y)) (= (denom x) (denom y))))
  (define (=zero?-rat x)
    (= 0 (numer x)))

  ;; interface to rest of the system
  (define (tag x)
    (attach-tag 'rational x))
  (put 'add '(rational rational) (lambda (x y) (tag (add-rat x y))))
  (put 'sub '(rational rational) (lambda (x y) (tag (sub-rat x y))))
  (put 'mul '(rational rational) (lambda (x y) (tag (mul-rat x y))))
  (put 'div '(rational rational) (lambda (x y) (tag (div-rat x y))))
  (put 'equ? '(rational rational) (lambda (x y) (equ?-rat x y)))
  (put '=zero? '(rational) (lambda (x) (=zero?-rat x)))

  (put 'make 'rational (lambda (n d) (tag (make-rat n d))))
  'done)

(define (make-rational n d)
  ((get 'make 'rational) n d))

(define (install-complex-package)
  ;; imported procedures from rectangular and polar packages
  (define (make-from-real-imag x y)
    ((get 'make-from-real-imag 'rectangular) x y))
  (define (make-from-mag-ang r a)
    ((get 'make-from-mag-ang 'polar) r a))

  ;; internal procedures
  (define (add-complex z1 z2)
    (make-from-real-imag (+ (real-part z1) (real-part z2)) (+ (imag-part z1) (imag-part z2))))
  (define (sub-complex z1 z2)
    (make-from-real-imag (- (real-part z1) (real-part z2)) (- (imag-part z1) (imag-part z2))))
  (define (mul-complex z1 z2)
    (make-from-mag-ang (* (magnitude z1) (magnitude z2)) (+ (angle z1) (angle z2))))
  (define (div-complex z1 z2)
    (make-from-mag-ang (/ (magnitude z1) (magnitude z2)) (- (angle z1) (angle z2))))
  (define (equ?-complex z1 z2)
    (and (= (real-part z1) (real-part z2)) (= (imag-part z1) (imag-part z2))))
  (define (=zero?-complex z)
    (= 0 (magnitude z)))

  ;; interface to rest of the system
  (define (tag z)
    (attach-tag 'complex z))
  (put 'add '(complex complex) (lambda (z1 z2) (tag (add-complex z1 z2))))
  (put 'sub '(complex complex) (lambda (z1 z2) (tag (sub-complex z1 z2))))
  (put 'mul '(complex complex) (lambda (z1 z2) (tag (mul-complex z1 z2))))
  (put 'div '(complex complex) (lambda (z1 z2) (tag (div-complex z1 z2))))
  (put 'equ? '(complex complex) (lambda (z1 z2) (equ?-complex z1 z2)))
  (put '=zero? '(complex) (lambda (x) (=zero?-complex x)))
  (put 'make-from-real-imag 'complex (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'complex (lambda (r a) (tag (make-from-mag-ang r a))))
  (put 'real-part '(complex) real-part)
  (put 'imag-part '(complex) imag-part)
  (put 'magnitude '(complex) magnitude)
  (put 'angle '(complex) angle)
  'done)

(define (make-complex-from-real-imag x y)
  ((get 'make-from-real-imag 'complex) x y))

(define (make-complex-from-mag-ang r a)
  ((get 'make-from-mag-ang 'complex) r a))

(install-rectangular-package)
(install-polar-package)
(install-scheme-number-package)
(install-rational-package)
(install-complex-package)

(coerce (make-scheme-number 1) 'complex)
(coerce-all (list (make-scheme-number 1) (make-scheme-number 2) (make-scheme-number 3)))
#+END_SRC

#+RESULTS:
#+begin_example
memq: not a proper list
  in: (mcons #f (mcons #f (mcons #f '())))
  context...:
   /var/folders/df/yfqln53x483c62qh523nv6gw0000gn/T/ob-racket-n8fSqo/ob-racketl0Flif.rkt:123:0: coerce-all
   body of "/var/folders/df/yfqln53x483c62qh523nv6gw0000gn/T/ob-racket-n8fSqo/ob-racketl0Flif.rkt"
'insertion_complete
'done
'done
'done
'done
'done
(mcons 'complex (mcons 'rectangular (mcons 1 0)))
#+end_example

Oh lol so this does not actually run because we have mutable ~cons~ here that do not make a proper list either ~memq~ or ~filter~ accepts. Maybe if we actually need to run stuff later I'll figure it out.

***** DONE Exercise 2.83
:PROPERTIES:
:CUSTOM_ID: exercise-2.83
:END:

#+begin_quote
Suppose you are designing a generic arithmetic system for dealing with the tower of types shown in [[figure-2.25][Figure 2.25]]: integer, rational, real, complex.  For each type (except complex), design a procedure that raises objects of that type one level in the tower.  Show how to install a generic ~raise~ operation that will work for each type (except complex).
#+end_quote

#+BEGIN_SRC racket :noweb yes
(define (raise x) (apply-generic 'raise x))

(put 'raise 'scheme-number (lambda (x) (make-rational x 1)))
;; lol we don't actually have a real type
(put 'raise 'rational (lambda (x) (make-real (/ (numer x) (denom x)))))

(put 'raise 'real (lambda (x) (make-complex-from-real-imag x 0)))
#+END_SRC

***** DONE Exercise 2.84
:PROPERTIES:
:CUSTOM_ID: exercise-2.84
:END:

#+begin_quote
Using the ~raise~ operation of [[#exercise-2.83][Exercise 2.83]], modify the ~apply-generic~ procedure so that it coerces its arguments to have the same type by the method of successive raising, as discussed in this section.  You will need to devise a way to test which of two types is higher in the tower.  Do this in a manner that is "compatible" with the rest of the system and will not lead to problems in adding new levels to the tower.
#+end_quote

I am growing increasingly disillusioned about this section, as it is very hard to get code to run. I suppose this would require changing my ~coerce-all~ implementation to instead rely on successive raising of all arguments to the type of the argument with the highest type, which should be trivial.

***** DROPPED Exercise 2.85
:PROPERTIES:
:CUSTOM_ID: exercise-2.85
:END:

#+begin_quote
This section mentioned a method for "simplifying" a data object by lowering it in the tower of types as far as possible.  Design a procedure ~drop~ that accomplishes this for the tower described in [[#exercise-2.83][Exercise 2.83]].  The key is to decide, in some general way, whether an object can be lowered.  For example, the complex number 1.5 + 0i can be lowered as far as ~real~, the complex number 1 + 0i can be lowered as far as ~integer~, and the complex number 2 + 3i cannot be lowered at all.  Here is a plan for determining whether an object can be lowered: Begin by defining a generic operation ~project~ that "pushes" an object down in the tower.  For example, projecting a complex number would involve throwing away the imaginary part.  Then a number can be dropped if, when we ~project~ it and ~raise~ the result back to the type we started with, we end up with something equal to what we started with.  Show how to implement this idea in detail, by writing a ~drop~ procedure that drops an object as far as possible.  You will need to design the various projection operations[fn:119] and install ~project~ as a generic operation in the system.  You will also need to make use of a generic equality predicate, such as described in [[#exercise-2.79][Exercise 2.79]].  Finally, use ~drop~ to rewrite ~apply-generic~ from [[#exercise-2.84][Exercise 2.84]] so that it "simplifies" its answers.
#+end_quote

***** DROPPED Exercise 2.86
:PROPERTIES:
:CUSTOM_ID: exercise-2.86
:END:

#+begin_quote
Suppose we want to handle complex numbers whose real parts, imaginary parts, magnitudes, and angles can be either ordinary numbers, rational numbers, or other numbers we might wish to add to the system.  Describe and implement the changes to the system needed to accommodate this.  You will have to define operations such as ~sine~ and ~cosine~ that are generic over ordinary numbers and rational numbers.
#+end_quote

**** DROPPED 2.5.3 Example: Symbolic Algebra
***** Exercise 2.87
:PROPERTIES:
:CUSTOM_ID: exercise-2.87
:END:

Install ~=zero?~ for polynomials in the generic arithmetic package.  This will allow ~adjoin-term~ to work for polynomials with coefficients that are themselves polynomials.
***** Exercise 2.88
:PROPERTIES:
:CUSTOM_ID: exercise-2.88
:END:

Extend the polynomial system to include subtraction of polynomials.  (Hint: You may find it helpful to define a generic negation operation.)
***** Exercise 2.89
:PROPERTIES:
:CUSTOM_ID: exercise-2.89
:END:

Define procedures that implement the term-list representation described above as appropriate for dense polynomials.
***** Exercise 2.90
:PROPERTIES:
:CUSTOM_ID: exercise-2.90
:END:

Suppose we want to have a polynomial system that is efficient for both sparse and dense polynomials.  One way to do this is to allow both kinds of term-list representations in our system.  The situation is analogous to the complex-number example of section [[#section-2.4][2.4]], where we allowed both rectangular and polar representations.  To do this we must distinguish different types of term lists and make the operations on term lists generic.  Redesign the polynomial system to implement this generalization.  This is a major effort, not a local change.
***** Exercise 2.91
:PROPERTIES:
:CUSTOM_ID: exercise-2.91
:END:

A univariate polynomial can be divided by another one to produce a polynomial quotient and a polynomial remainder.  For example,

#+BEGIN_EXAMPLE
 x^5 - 1
 ------- = x^3 + x, remainder x - 1
 x^2 - 1
#+END_EXAMPLE

Division can be performed via long division.  That is, divide the highest-order term of the dividend by the highest-order term of the divisor.  The result is the first term of the quotient.  Next, multiply the result by the divisor, subtract that from the dividend, and produce the rest of the answer by recursively dividing the difference by the divisor.  Stop when the order of the divisor exceeds the order of the dividend and declare the dividend to be the remainder.  Also, if the dividend ever becomes zero, return zero as both quotient and remainder.

We can design a ~div-poly~ procedure on the model of ~add-poly~ and ~mul-poly~.  The procedure checks to see if the two polys have the same variable.  If so, ~div-poly~ strips off the variable and passes the problem to ~div-terms~, which performs the division operation on term lists.  ~div-poly~ finally reattaches the variable to the result supplied by ~div-terms~.  It is convenient to design ~div-terms~ to compute both the quotient and the remainder of a division.  ~div-terms~ can take two term lists as arguments and return a list of the quotient term list and the remainder term list.

Complete the following definition of ~div-terms~ by filling in the missing expressions.  Use this to implement ~div-poly~, which takes two polys as arguments and returns a list of the quotient and remainder polys.

#+BEGIN_SRC scheme
(define (div-terms L1 L2)
  (if (empty-termlist? L1)
      (list (the-empty-termlist) (the-empty-termlist))
      (let ((t1 (first-term L1))
            (t2 (first-term L2)))
        (if (> (order t2) (order t1))
            (list (the-empty-termlist) L1)
            (let ((new-c (div (coeff t1) (coeff t2)))
                  (new-o (- (order t1) (order t2))))
              (let ((rest-of-result
                     <COMPUTE REST OF RESULT RECURSIVELY>
                     ))
                <FORM COMPLETE RESULT>
                ))))))
#+END_SRC

*Hierarchies of types in symbolic algebra*

Our polynomial system illustrates how objects of one type (polynomials) may in fact be complex objects that have objects of many different types as parts.  This poses no real difficulty in defining generic operations.  We need only install appropriate generic operations for performing the necessary manipulations of the parts of the compound types.  In fact, we saw that polynomials form a kind of "recursive data abstraction," in that parts of a polynomial may themselves be polynomials.  Our generic operations and our data-directed programming style can handle this complication without much trouble.

On the other hand, polynomial algebra is a system for which the data types cannot be naturally arranged in a tower.  For instance, it is possible to have polynomials in x whose coefficients are polynomials in y.  It is also possible to have polynomials in y whose coefficients are polynomials in x.  Neither of these types is "above" the other in any natural way, yet it is often necessary to add together elements from each set.  There are several ways to do this.  One possibility is to convert one polynomial to the type of the other by expanding and rearranging terms so that both polynomials have the same principal variable.  One can impose a towerlike structure on this by ordering the variables and thus always converting any polynomial to a "canonical form" with the highest-priority variable dominant and the lower-priority variables buried in the coefficients.  This strategy works fairly well, except that the conversion may expand a polynomial unnecessarily, making it hard to read and perhaps less efficient to work with.  The tower strategy is certainly not natural for this domain or for any domain where the user can invent new types dynamically using old types in various combining forms, such as trigonometric functions, power series, and integrals.

It should not be surprising that controlling coercion is a serious problem in the design of large-scale algebraic-manipulation systems.  Much of the complexity of such systems is concerned with relationships among diverse types.  Indeed, it is fair to say that we do not yet completely understand coercion.  In fact, we do not yet completely understand the concept of a data type.  Nevertheless, what we know provides us with powerful structuring and modularity principles to support the design of large systems.
***** Exercise 2.92
:PROPERTIES:
:CUSTOM_ID: exercise-2.92
:END:

By imposing an ordering on variables, extend the polynomial package so that addition and multiplication of polynomials works for polynomials in different variables.  (This is not easy!)

*Extended exercise: Rational functions*

We can extend our generic arithmetic system to include <<i317>> rational functions.  These are "fractions" whose numerator and denominator are polynomials, such as

#+BEGIN_EXAMPLE
  x + 1
 -------
 x^3 - 1
#+END_EXAMPLE

The system should be able to add, subtract, multiply, and divide rational functions, and to perform such computations as

#+BEGIN_EXAMPLE
  x + 1       x      x^3 + 2x^2 + 3x + 1
 ------- + ------- = -------------------
 x^3 - 1   x^2 - 1    x^4 + x^3 - x - 1
#+END_EXAMPLE

(Here the sum has been simplified by removing common factors.  Ordinary "cross multiplication" would have produced a fourth-degree polynomial over a fifth-degree polynomial.)

If we modify our rational-arithmetic package so that it uses generic operations, then it will do what we want, except for the problem of reducing fractions to lowest terms.
***** Exercise 2.93
:PROPERTIES:
:CUSTOM_ID: exercise-2.93
:END:

Modify the rational-arithmetic package to use generic operations, but change ~make-rat~ so that it does not attempt to reduce fractions to lowest terms.  Test your system by calling ~make-rational~ on two polynomials to produce a rational function

#+BEGIN_SRC scheme
(define p1 (make-polynomial 'x '((2 1)(0 1))))
(define p2 (make-polynomial 'x '((3 1)(0 1))))
(define rf (make-rational p2 p1))
#+END_SRC

Now add ~rf~ to itself, using ~add~.  You will observe that this addition procedure does not reduce fractions to lowest terms.

We can reduce polynomial fractions to lowest terms using the same idea we used with integers: modifying ~make-rat~ to divide both the numerator and the denominator by their greatest common divisor.  The notion of "greatest common divisor" makes sense for polynomials.  In fact, we can compute the GCD of two polynomials using essentially the same Euclid's Algorithm that works for integers.[fn:126] The integer version is

#+BEGIN_SRC scheme
(define (gcd a b)
  (if (= b 0)
      a
      (gcd b (remainder a b))))
#+END_SRC

Using this, we could make the obvious modification to define a GCD operation that works on term lists:

#+BEGIN_SRC scheme
(define (gcd-terms a b)
  (if (empty-termlist? b)
      a
      (gcd-terms b (remainder-terms a b))))
#+END_SRC

where ~remainder-terms~ picks out the remainder component of the list returned by the term-list division operation ~div-terms~ that was implemented in [[#exercise-2.91][Exercise 2.91]].
***** Exercise 2.94
:PROPERTIES:
:CUSTOM_ID: exercise-2.94
:END:

Using ~div-terms~, implement the procedure ~remainder-terms~ and use this to define ~gcd-terms~ as above.  Now write a procedure ~gcd-poly~ that computes the polynomial GCD of two polys.  (The procedure should signal an error if the two polys are not in the same variable.)  Install in the system a generic operation ~greatest-common-divisor~ that reduces to ~gcd-poly~ for polynomials and to ordinary ~gcd~ for ordinary numbers.  As a test, try

#+BEGIN_SRC scheme
(define p1 (make-polynomial 'x '((4 1) (3 -1) (2 -2) (1 2))))
(define p2 (make-polynomial 'x '((3 1) (1 -1))))
(greatest-common-divisor p1 p2)
#+END_SRC

and check your result by hand.
***** Exercise 2.95
:PROPERTIES:
:CUSTOM_ID: exercise-2.95
:END:

Define P_1, P_2, and P_3 to be the polynomials

#+BEGIN_EXAMPLE
 P_1 : x^2 - 2x + 1

 P_2 : 11x^2 + 7

 P_3 : 13x + 5
#+END_EXAMPLE

Now define Q_1 to be the product of P_1 and P_2 and Q_2 to be the product of P_1 and P_3, and use ~greatest-common-divisor~ ([[#exercise-2.94][Exercise 2.94]]) to compute the GCD of Q_1 and Q_2.  Note that the answer is not the same as P_1.  This example introduces noninteger operations into the computation, causing difficulties with the GCD algorithm.[fn:127] To understand what is happening, try tracing ~gcd-terms~ while computing the GCD or try performing the division by hand.

We can solve the problem exhibited in [[#exercise-2.95][Exercise 2.95]] if we use the following modification of the GCD algorithm (which really works only in the case of polynomials with integer coefficients).  Before performing any polynomial division in the GCD computation, we multiply the dividend by an integer constant factor, chosen to guarantee that no fractions will arise during the division process.  Our answer will thus differ from the actual GCD by an integer constant factor, but this does not matter in the case of reducing rational functions to lowest terms; the GCD will be used to divide both the numerator and denominator, so the integer constant factor will cancel out.

More precisely, if P and Q are polynomials, let O_1 be the order of P (i.e., the order of the largest term of P) and let O_2 be the order of Q. Let c be the leading coefficient of Q. Then it can be shown that, if we multiply P by the <<i190>> integerizing factor c^(1+O_1 -O_2), the resulting polynomial can be divided by Q by using the ~div-terms~ algorithm without introducing any fractions.  The operation of multiplying the dividend by this constant and then dividing is sometimes called the <<i309>> pseudodivision of P by Q.  The remainder of the division is called the <<i310>> pseudoremainder.
***** Exercise 2.96
:PROPERTIES:
:CUSTOM_ID: exercise-2.96
:END:

a. Implement the procedure ~pseudoremainder-terms~, which is just like ~remainder-terms~ except that it multiplies the dividend by the integerizing factor described above before calling ~div-terms~.  Modify ~gcd-terms~ to use ~pseudoremainder-terms~, and verify that ~greatest-common-divisor~ now produces an answer with integer coefficients on the example in [[#exercise-2.95][Exercise 2.95]].

b. The GCD now has integer coefficients, but they are larger than those of P_1.  Modify ~gcd-terms~ so that it removes common factors from the coefficients of the answer by dividing all the coefficients by their (integer) greatest common divisor.

Thus, here is how to reduce a rational function to lowest terms:

1. Compute the GCD of the numerator and denominator, using the version of ~gcd-terms~ from [[#exercise-2.96][Exercise 2.96]].

2. When you obtain the GCD, multiply both numerator and denominator by the same integerizing factor before dividing through by the GCD, so that division by the GCD will not introduce any noninteger coefficients.  As the factor you can use the leading coefficient of the GCD raised to the power 1 + O_1 - O_2, where O_2 is the order of the GCD and O_1 is the maximum of the orders of the numerator and denominator.  This will ensure that dividing the numerator and denominator by the GCD will not introduce any fractions.

3. The result of this operation will be a numerator and denominator with integer coefficients.  The coefficients will normally be very large because of all of the integerizing factors, so the last step is to remove the redundant factors by computing the (integer) greatest common divisor of all the coefficients of the numerator and the denominator and dividing through by this factor.
***** Exercise 2.97
:PROPERTIES:
:CUSTOM_ID: exercise-2.97
:END:

a. Implement this algorithm as a procedure ~reduce-terms~ that takes two term lists ~n~ and ~d~ as arguments and returns a list ~nn~, ~dd~, which are ~n~ and ~d~ reduced to lowest terms via the algorithm given above.  Also write a procedure ~reduce-poly~, analogous to ~add-poly~, that checks to see if the two polys have the same variable.  If so, ~reduce-poly~ strips off the variable and passes the problem to ~reduce-terms~, then reattaches the variable to the two term lists supplied by ~reduce-terms~.

b. Define a procedure analogous to ~reduce-terms~ that does what the original ~make-rat~ did for integers:

#+BEGIN_SRC scheme
(define (reduce-integers n d)
  (let ((g (gcd n d)))
    (list (/ n g) (/ d g))))
#+END_SRC

and define ~reduce~ as a generic operation that calls ~apply-generic~ to dispatch to either ~reduce-poly~ (for ~polynomial~ arguments) or ~reduce-integers~ (for ~scheme-number~ arguments).  You can now easily make the rational-arithmetic package reduce fractions to lowest terms by having ~make-rat~ call ~reduce~ before combining the given numerator and denominator to form a rational number.  The system now handles rational expressions in either integers or polynomials.  To test your program, try the example at the beginning of this extended exercise:

#+BEGIN_SRC scheme
(define p1 (make-polynomial 'x '((1 1)(0 1))))
(define p2 (make-polynomial 'x '((3 1)(0 -1))))
(define p3 (make-polynomial 'x '((1 1))))
(define p4 (make-polynomial 'x '((2 1)(0 -1))))

(define rf1 (make-rational p1 p2))
(define rf2 (make-rational p3 p4))

(add rf1 rf2)
#+END_SRC

See if you get the correct answer, correctly reduced to lowest terms.

The GCD computation is at the heart of any system that does operations on rational functions.  The algorithm used above, although mathematically straightforward, is extremely slow.  The slowness is due partly to the large number of division operations and partly to the enormous size of the intermediate coefficients generated by the pseudodivisions.  One of the active areas in the development of algebraic-manipulation systems is the design of better algorithms for computing polynomial GCDs.[fn:128]

** TODO 3 Modularity, Objects, and State
*** DONE 3.1 Assignment and Local State
**** DONE 3.1.1 Local State Variables

#+BEGIN_SRC racket :noweb yes
#lang sicp

(define balance 100)

(define (withdraw amount)
  (if (>= balance amount)
      (begin
        (set! balance (- balance amount))
        balance)
      "Insufficient funds"))

(withdraw 25)
(withdraw 25)
(withdraw 60)
(withdraw 15)
#+END_SRC

#+RESULTS:
: 75
: 50
: "Insufficient funds"
: 35

#+BEGIN_SRC racket :noweb yes
#lang sicp

(define (withdraw amount)
  (let ([balance 100])
    (lambda (amount)
      (if (>= balance amount)
          (begin
            (set! balance (- balance amount))
            balance)
          "Insufficient funds"))))

(withdraw 25)
(withdraw 25)
(withdraw 60)
(withdraw 15)

(define (make-withdraw balance)
  (lambda (amount)
    (if (>= balance amount)
        (begin
          (set! balance (- balance amount))
          balance)
        "Insufficient funds")))

(define W1 (make-withdraw 100))
(define W2 (make-withdraw 100))

(W1 50)
(W2 70)
(W2 40)
(W1 40)
#+END_SRC

#+RESULTS:
: #<procedure:...ob-racketeCLBEr.rkt:6:4>
: #<procedure:...ob-racketeCLBEr.rkt:6:4>
: #<procedure:...ob-racketeCLBEr.rkt:6:4>
: #<procedure:...ob-racketeCLBEr.rkt:6:4>
: 50
: 30
: "Insufficient funds"
: 10

#+BEGIN_SRC racket :noweb yes
#lang sicp

(define (make-account balance)
  (define (withdraw amount)
    (if (>= balance amount)
        (begin
          (set! balance (- balance amount))
          balance)
        "Insufficient funds"))
  (define (deposit amount)
    (set! balance (+ balance amount))
    balance)
  (define (dispatch m)
    (cond
      [(eq? m 'withdraw) withdraw]
      [(eq? m 'deposit) deposit]
      [else (error "Unknown request: MAKE-ACCOUNT" m)]))
  dispatch)

(define acc (make-account 100))
((acc 'withdraw) 50)
((acc 'withdraw) 60)
((acc 'deposit) 40)
((acc 'withdraw) 60)
#+END_SRC

#+RESULTS:
: 50
: "Insufficient funds"
: 90
: 30

***** DONE Exercise 3.1
:PROPERTIES:
:CUSTOM_ID: exercise-3.1
:ACTIVATED: [2022-07-28]
:END:

#+begin_quote
An /accumulator/ is a procedure that is called repeatedly with a single numeric argument and accumulates its arguments into a sum.  Each time it is called, it returns the currently accumulated sum.  Write a procedure ~make-accumulator~ that generates accumulators, each maintaining an independent sum.  The input to ~make-accumulator~ should specify the initial value of the sum; for example
#+end_quote

#+BEGIN_SRC scheme
(define A (make-accumulator 5))

(A 10)
15

(A 10)
25
#+END_SRC

#+BEGIN_SRC racket :noweb yes
#lang sicp

(define (make-accumulator n)
  (lambda (d)
    (set! n (+ n d))
    n))

(define A (make-accumulator 5))
(A 10)
(A 10)
#+END_SRC

#+RESULTS:
: 15
: 25

***** DONE Exercise 3.2
:PROPERTIES:
:CUSTOM_ID: exercise-3.2
:END:

#+begin_quote
In software-testing applications, it is useful to be able to count the number of times a given procedure is called during the course of a computation.  Write a procedure ~make-monitored~ that takes as input a procedure, ~f~, that itself takes one input.  The result returned by ~make-monitored~ is a third procedure, say ~mf~, that keeps track of the number of times it has been called by maintaining an internal counter.  If the input to ~mf~ is the special symbol ~how-many-calls?~, then ~mf~ returns the value of the counter.  If the input is the special symbol ~reset-count~, then ~mf~ resets the counter to zero.  For any other input, ~mf~ returns the result of calling ~f~ on that input and increments the counter.  For instance, we could make a monitored version of the ~sqrt~ procedure:
#+end_quote

#+BEGIN_SRC scheme
(define s (make-monitored sqrt))

(s 100)
10

(s 'how-many-calls?)
1
#+END_SRC

#+BEGIN_SRC racket :noweb yes
#lang sicp

(define (make-monitored f)
  (let ([n 0])
    (lambda (input)
      (cond
        [(eq? input 'how-many-calls?) n]
        [(eq? input 'reset-count) (set! n 0)]
        [else
         (begin
           (set! n (+ n 1))
           (f input))]))))

(define s (make-monitored sqrt))
(s 100)
(s 2)
(s 'how-many-calls?)
(s 'reset-count)
(s 3)
(s 'how-many-calls?)
#+END_SRC

#+RESULTS:
: 10
: 1.4142135623730951
: 2
: 1.7320508075688772
: 1

***** DONE Exercise 3.3
:PROPERTIES:
:CUSTOM_ID: exercise-3.3
:ACTIVATED: [2022-07-28]
:END:

#+begin_quote
Modify the ~make-account~ procedure so that it creates password-protected accounts.  That is, ~make-account~ should take a symbol as an additional argument, as in
#+end_quote

#+BEGIN_SRC scheme
(define acc (make-account 100 'secret-password))
#+END_SRC

#+begin_quote
The resulting account object should process a request only if it is accompanied by the password with which the account was created, and should otherwise return a complaint:
#+end_quote

#+BEGIN_SRC scheme
((acc 'secret-password 'withdraw) 40)
60

((acc 'some-other-password 'deposit) 50)
"Incorrect password"
#+END_SRC

#+BEGIN_SRC racket :noweb yes
#lang sicp

(define (make-account balance password)
  (define (withdraw amount)
    (if (>= balance amount)
        (begin
          (set! balance (- balance amount))
          balance)
        "Insufficient funds"))
  (define (deposit amount)
    (set! balance (+ balance amount))
    balance)
  (define (dispatch p m)
    (if (eq? p password)
        (cond
         [(eq? m 'withdraw) withdraw]
         [(eq? m 'deposit) deposit]
         [else (error "Unknown request: MAKE-ACCOUNT" m)])
        (lambda (x) "Incorrect password")))
  dispatch)

(define acc (make-account 100 'secret-password))
((acc 'secret-password 'withdraw) 40)
((acc 'secret-password 'withdraw) 40)
((acc 'secret-password 'deposit) 50)
((acc 'some-other-password 'deposit) 50)
#+END_SRC

#+RESULTS:
: 60
: 20
: 70
: "Incorrect password"

***** DONE Exercise 3.4
:PROPERTIES:
:CUSTOM_ID: exercise-3.4
:END:

Modify the ~make-account~ procedure of [[#exercise-3.3][Exercise 3.3]] by adding another local state variable so that, if an account is accessed more than seven consecutive times with an incorrect password, it invokes the procedure ~call-the-cops~.


#+BEGIN_SRC racket :noweb yes
#lang sicp

(define (call-the-cops)
  (display "COPS\n"))

(define (make-account balance password)

  (define n-incorrect 0)

  (define (withdraw amount)
    (if (>= balance amount)
        (begin
          (set! balance (- balance amount))
          balance)
        "Insufficient funds"))
  (define (deposit amount)
    (set! balance (+ balance amount))
    balance)
  (define (dispatch p m)
    (if (eq? p password)
        (cond
          [(eq? m 'withdraw) withdraw]
          [(eq? m 'deposit) deposit]
          [else (error "Unknown request: MAKE-ACCOUNT" m)])
        (begin
          (set! n-incorrect (+ 1 n-incorrect))
          (if (> n-incorrect 7) (lambda (x) (call-the-cops)) (lambda (x) "Incorrect password")))))
  dispatch)

(define acc (make-account 100 'secret-password))
((acc 'secret-password 'withdraw) 40)
((acc 'secret-password 'withdraw) 40)
((acc 'secret-password 'deposit) 50)
((acc 'some-other-password 'deposit) 50)
((acc 'some-other-password 'deposit) 50)
((acc 'some-other-password 'deposit) 50)
((acc 'some-other-password 'deposit) 50)
((acc 'some-other-password 'deposit) 50)
((acc 'some-other-password 'deposit) 50)
((acc 'some-other-password 'deposit) 50)
((acc 'some-other-password 'deposit) 50)
((acc 'some-other-password 'deposit) 50)
#+END_SRC

#+RESULTS:
#+begin_example
60
20
70
"Incorrect password"
"Incorrect password"
"Incorrect password"
"Incorrect password"
"Incorrect password"
"Incorrect password"
"Incorrect password"
COPS
COPS
#+end_example

**** DONE 3.1.2 The Benefits of Introducing Assignment
***** DONE Exercise 3.5
:PROPERTIES:
:CUSTOM_ID: exercise-3.5
:ACTIVATED: [2022-07-28]
:END:

#+begin_quote
/Monte Carlo/ integration is a method of estimating definite integrals by means of Monte Carlo simulation.  Consider computing the area of a region of space described by a predicate P(x, y) that is true for points (x, y) in the region and false for points not in the region.  For example, the region contained within a circle of radius 3 centered at (5, 7) is described by the predicate that tests whether (x - 5)^2 + (y - 7)^2 <= 3^2.  To estimate the area of the region described by such a predicate, begin by choosing a rectangle that contains the region.  For example, a rectangle with diagonally opposite corners at (2, 4) and (8, 10) contains the circle above.  The desired integral is the area of that portion of the rectangle that lies in the region.  We can estimate the integral by picking, at random, points (x,y) that lie in the rectangle, and testing P(x, y) for each point to determine whether the point lies in the region.  If we try this with many points, then the fraction of points that fall in the region should give an estimate of the proportion of the rectangle that lies in the region.  Hence, multiplying this fraction by the area of the entire rectangle should produce an estimate of the integral.

Implement Monte Carlo integration as a procedure ~estimate-integral~ that takes as arguments a predicate ~P~, upper and lower bounds ~x1~, ~x2~, ~y1~, and ~y2~ for the rectangle, and the number of trials to perform in order to produce the estimate.  Your procedure should use the same ~monte-carlo~ procedure that was used above to estimate \pi.  Use your ~estimate-integral~ to produce an estimate of \pi by measuring the area of a unit circle.

You will find it useful to have a procedure that returns a number chosen at random from a given range.  The following ~random-in-range~ procedure implements this in terms of the ~random~ procedure used in section [[#section-1.2.6][1.2.6]], which returns a nonnegative number less than its input.[fn:136]
#+end_quote

#+BEGIN_SRC scheme
(define (random-in-range low high)
  (let ((range (- high low)))
    (+ low (random range))))
#+END_SRC

#+BEGIN_SRC racket :noweb yes
#lang sicp

(define (random-in-range low high)
  (let ([range (- high low)]) (+ low (random range))))

(define (monte-carlo trials experiment)
  (define (iter trials-remaining trials-passed)
    (cond
      [(= trials-remaining 0) (/ trials-passed trials)]
      [else (iter (- trials-remaining 1) (+ trials-passed (if (experiment) 1 0)))]))
  (iter trials 0))

(define (estimate-integral predicate x1 x2 y1 y2 n-trials)
  (define (inside?)
    (predicate (random-in-range x1 x2) (random-in-range y1 y2)))
  (* (monte-carlo n-trials inside?) (* (- x2 x1) (- y2 y1))))

(estimate-integral (lambda (x y) (<= (+ (* x x) (* y y)) 1.0)) -1.0 1.0 -1.0 1.0 1000000)
#+END_SRC

#+RESULTS:
: 3.1415252

***** DONE Exercise 3.6
:PROPERTIES:
:CUSTOM_ID: exercise-3.6
:END:

It is useful to be able to reset a random-number generator to produce a sequence starting from a given value.  Design a new ~rand~ procedure that is called with an argument that is either the symbol ~generate~ or the symbol ~reset~ and behaves as follows: ~(rand 'generate)~ produces a new random number; ~((rand 'reset) <NEW-VALUE>)~ resets the internal state variable to the designated <NEW-VALUE>.  Thus, by resetting the state, one can generate repeatable sequences.  These are very handy to have when testing and debugging programs that use random numbers.

#+BEGIN_SRC racket :noweb yes
#lang sicp

(define (rand op)
  (define x random-init)
  (define (init val)
    (set! x val))
  (define (generate)
    (set! x (random-update x)))
  (define (dispatch op)
    (cond
      [(eq? op 'generate)
       (begin
         (generate)
         x)]
      [(eq? op 'reset)]))
  init)
#+END_SRC

**** DONE 3.1.3 The Costs of Introducing Assignment
***** DONE Exercise 3.7
:PROPERTIES:
:CUSTOM_ID: exercise-3.7
:END:

#+begin_quote
Consider the bank account objects created by ~make-account~, with the password modification described in [[#exercise-3.3][Exercise 3.3]].  Suppose that our banking system requires the ability to make joint accounts.  Define a procedure ~make-joint~ that accomplishes this.  ~make-joint~ should take three arguments.  The first is a password-protected account.  The second argument must match the password with which the account was defined in order for the ~make-joint~ operation to proceed.  The third argument is a new password.  ~make-joint~ is to create an additional access to the original account using the new password.  For example, if ~peter-acc~ is a bank account with password ~open-sesame~, then
#+end_quote

#+BEGIN_SRC scheme
(define paul-acc
  (make-joint peter-acc 'open-sesame 'rosebud))
#+END_SRC

#+begin_quote
will allow one to make transactions on ~peter-acc~ using the name ~paul-acc~ and the password ~rosebud~.  You may wish to modify your solution to [[#exercise-3.3][Exercise 3.3]] to accommodate this new feature
#+end_quote

#+BEGIN_SRC racket :noweb yes
#lang sicp

(define (make-account balance password)
  (define (withdraw amount)
    (if (>= balance amount)
        (begin
          (set! balance (- balance amount))
          balance)
        "Insufficient funds"))
  (define (deposit amount)
    (set! balance (+ balance amount))
    balance)
  (define (dispatch p m)
    (if (eq? p password)
        (cond
          [(eq? m 'withdraw) withdraw]
          [(eq? m 'deposit) deposit]
          [else (error "Unknown request: MAKE-ACCOUNT" m)])
        (lambda (x) "Incorrect password")))
  dispatch)

(define (make-joint account original-password new-password)
  (define (withdraw amount)
    ((account original-password 'withdraw) amount))
  (define (deposit amount)
    ((account original-password 'deposit) amount))
  (define (dispatch p m)
    (if (eq? p new-password)
        (cond
          [(eq? m 'withdraw) withdraw]
          [(eq? m 'deposit) deposit]
          [else (error "Unknown request: MAKE-JOINT" m)])
        (lambda (x) "Incorrect password")))
  (if (number? ((account original-password 'deposit) 0)) dispatch "Incorrect password"))

(define peter-acc (make-account 100 'open-sesame))
(define paul-acc (make-joint peter-acc 'open-sesame 'rosebud))

((peter-acc 'open-sesame 'withdraw) 10)
((paul-acc 'rosebud 'withdraw) 10)
((paul-acc 'open-sesame 'withdraw) 10)
#+END_SRC

#+RESULTS:
: 90
: 80
: "Incorrect password"

***** DONE Exercise 3.8
:PROPERTIES:
:CUSTOM_ID: exercise-3.8
:END:

#+begin_quote
When we defined the evaluation model in section [[#section-1.1.3][1.1.3]], we said that the first step in evaluating an expression is to evaluate its subexpressions.  But we never specified the order in which the subexpressions should be evaluated (e.g., left to right or right to left).  When we introduce assignment, the order in which the arguments to a procedure are evaluated can make a difference to the result.  Define a simple procedure ~f~ such that evaluating ~(+ (f 0) (f 1))~ will return 0 if the arguments to ~+~ are evaluated from left to right but will return 1 if the arguments are evaluated from right to left.
#+end_quote

#+BEGIN_SRC racket :noweb yes
#lang sicp

(define f
  (let ([flag #f])
    (lambda (x)
      (if (= x 0)
          (begin
            (set! flag #t)
            0)
          (if flag x 0)))))

;; (+ (f 0) (f 1))
(+ (f 1) (f 0))
#+END_SRC

#+RESULTS:
: 0

*** DROPPED 3.2 The Environment Model of Evaluation
**** DONE 3.2.1 The Rules for Evaluation
**** DONE 3.2.2 Applying Simple Procedures
***** DONE Exercise 3.9
:PROPERTIES:
:CUSTOM_ID: exercise-3.9
:END:

#+begin_quote
In section [[#section-1.2.1][1.2.1]] we used the substitution model to analyze two procedures for computing factorials, a recursive version
#+end_quote

#+BEGIN_SRC scheme
(define (factorial n)
  (if (= n 1)
      1
      (* n (factorial (- n 1)))))
#+END_SRC

#+begin_quote
and an iterative version
#+end_quote

#+BEGIN_SRC scheme
(define (factorial n)
  (fact-iter 1 1 n))

(define (fact-iter product counter max-count)
  (if (> counter max-count)
      product
      (fact-iter (* counter product)
                 (+ counter 1)
                 max-count)))
#+END_SRC

#+begin_quote
Show the environment structures created by evaluating ~(factorial 6)~ using each version of the ~factorial~ procedure.[fn:142]
#+end_quote

http://community.schemewiki.org/?sicp-ex-3.9

#+begin_example
RECURSIVE VERSION

global  ________________________
env     | other var.            |
------->| factorial : *         |
        |             |         |
        |_____________|_________|
                      |     ^
                      |     |
                variables : n
                body: (if (= n 1) 1 (* n (factorial (- n 1))))

(factorial 6)

         _______            ^
  E1 -->| n : 6 |___________| GLOBAL
         -------
        (* 6 (factorial 5))
         _______            ^
  E2 -->| n : 5 |___________| GLOBAL
         -------
        (* 5 (factorial 4))
         _______            ^
  E3 -->| n : 4 |___________| GLOBAL
         -------
        (* 4 (factorial 3))
         _______            ^ 
  E4 -->| n : 3 |___________| GLOBAL
         -------
        (* 3 (factorial 2))
         _______            ^
  E5 -->| n : 2 |___________| GLOBAL
         -------
        (* 2 (factorial 1))
         _______            ^
  E6 -->| n : 1 |___________| GLOBAL
         -------
         1

ITERATIVE VERSON

global  ___________________________________
env     | other var.                       |
------->| factorial : *                    |
        | fact-iter : |               *    |
        |_____________|_______________|____|
                      |       ^       |  ^
                      |       |       |  |
                      |       |       variable : (product counter max-count)
                      |       |       body: (if (> counter max-count) 
                      |       |                 prod 
                      |       |                 (fact-iter (* counter product)
                      |       |                            (+ counter 1)
                      |       |                            max-count))
                      |       |
                variable: n
                body: (fact-iter 1 1 n)

(factorial 6)

         _______              ^
  E1 -->| n : 6 |_____________| GLOBAL  
         -------
         (fact-iter 1 1 n)

  E2 -->| product   : 1       ^
        | counter   : 1    ___| GLOBAL 
        | max-count : 6
         (fact-iter 1 2 6)

  E3 -->| product   : 1       ^
        | counter   : 2   ____| GLOBAL
        | max-count : 6
         (fact-iter 2 3 6)

  E4 -->| product   : 2       ^
        | counter   : 3  _____| GLOBAL
        | max-count : 6
         (fact-iter 6 4 6)

  E5 -->| product   : 6       ^
        | counter   : 4  _____| GLOBAL
        | max-count : 6
         (fact-iter 24 5 6)

  E6 -->| product   : 24      ^
        | counter   : 5  _____| GLOBAL
        | max-count : 6
         (fact-iter 120 6 6)

  E7 -->| product   : 120     ^
        | counter   : 6  _____| GLOBAL
        | max-count : 6
         (fact-iter 720 7 6)

  E8 -->| product   : 720     ^
        | counter   : 7  _____| GLOBAL
        | max-count : 6
         720

#+end_example

**** DONE 3.2.3 Frames as the Repository of Local State
***** DONE Exercise 3.10
:PROPERTIES:
:CUSTOM_ID: exercise-3.10
:END:

#+begin_quote
In the ~make-withdraw~ procedure, the local variable ~balance~ is created as a parameter of ~make-withdraw~.  We could also create the local state variable explicitly, using ~let~, as follows:
#+end_quote

#+BEGIN_SRC scheme
(define (make-withdraw initial-amount)
  (let ((balance initial-amount))
    (lambda (amount)
      (if (>= balance amount)
          (begin (set! balance (- balance amount))
                 balance)
          "Insufficient funds"))))
#+END_SRC

#+begin_quote
Recall from section [[#section-1.3.2][1.3.2]] that ~let~ is simply syntactic sugar for a procedure call:
#+end_quote

#+BEGIN_SRC scheme
(let ((<VAR> <EXP>)) <BODY>)
#+END_SRC

#+begin_quote
is interpreted as an alternate syntax for
#+end_quote

#+BEGIN_SRC scheme
((lambda (<VAR>) <BODY>) <EXP>)
#+END_SRC

#+begin_quote
Use the environment model to analyze this alternate version of ~make-withdraw~, drawing figures like the ones above to illustrate the interactions
#+end_quote

#+BEGIN_SRC scheme
(define W1 (make-withdraw 100))

(W1 50)

(define W2 (make-withdraw 100))
#+END_SRC

#+begin_quote
Show that the two versions of ~make-withdraw~ create objects with the same behavior.  How do the environment structures differ for the two versions?
#+end_quote

http://community.schemewiki.org/?sicp-ex-3.10

#+begin_example
(define W1 (make-withdraw 100))

When make-withdraw is evaluated, E0 is created with Frame A having the
initial-mount binding. Next, as a result of the evaluation of the 
anonymous function (generated by the set (Edit: let?) structure), Frame B is created
with the binding of balance (E1 is the pointer to this frame).

         _______________________
global->| make-withdraw : *     |
env.    | W1 :  *         |     |
         -------|---^-----|---^-
                |   |     |   |
                |   |     parameter: initial-mount
                |   |     body: ((lambda (balance) ((...))) initial-mount)
                |   |
                |  _|___Frame_A__________
                | | initial-mount : 100  |<- E0
                |  -^--------------------
                |   |
                |  _|__________Frame_B______
                | | balance : initial-mount | <- E1
                |  -^-----------------------
                |   |
                parameter: amount
                body: (if (>= balance amount) ... )

(W1 50)

Set! will affect Frame B, initial-mount remains unchanged in Frame A. 
         _______________________
global->| make-withdraw : *     |
env.    | W1 :  *         |     |
         -------|---^-----|---^-
                |   |     |   |
                |   |     parameter: initial-mount
                |   |     body: ((lambda (balance) ((...))) initial-mount)
                |   |
                |  _|___Frame_A__________
                | | initial-mount : 100  |<- E0
                |  -^--------------------
                |   |
                |  _|__________Frame_B___
                | | balance : 50         | <- E1
                |  -^--------------------
                |   |
                parameter: amount
                body: (if (>= balance amount) ... )
#+end_example

**** DONE 3.2.4 Internal Definitions
***** Exercise 3.11
:PROPERTIES:
:CUSTOM_ID: exercise-3.11
:END:

#+begin_quote
In section [[#section-3.2.3][3.2.3]] we saw how the environment model described the behavior of procedures with local state.  Now we have seen how internal definitions work.  A typical message-passing procedure contains both of these aspects.  Consider the bank account procedure of section [[#section-3.1.1][3.1.1]]:
#+end_quote

#+BEGIN_SRC scheme
(define (make-account balance)
  (define (withdraw amount)
    (if (>= balance amount)
        (begin (set! balance (- balance amount))
               balance)
        "Insufficient funds"))
  (define (deposit amount)
    (set! balance (+ balance amount))
    balance)
  (define (dispatch m)
    (cond ((eq? m 'withdraw) withdraw)
          ((eq? m 'deposit) deposit)
          (else (error "Unknown request - MAKE-ACCOUNT"
                       m))))
  dispatch)
#+END_SRC

#+begin_quote
Show the environment structure generated by the sequence of interactions
#+end_quote

#+BEGIN_SRC scheme
(define acc (make-account 50))

((acc 'deposit) 40)
90

((acc 'withdraw) 60)
30
#+END_SRC

#+begin_quote
Where is the local state for ~acc~ kept?  Suppose we define another account
#+end_quote

#+BEGIN_SRC scheme
(define acc2 (make-account 100))
#+END_SRC

#+begin_quote
How are the local states for the two accounts kept distinct?  Which parts of the environment structure are shared between ~acc~ and ~acc2~?
#+end_quote

http://community.schemewiki.org/?sicp-ex-3.11

#+begin_example
(define acc (make-account 50))

global   _________________________________
env  -->| make-account :*                 |
        | acc : *       |                 |
         -------|-------|---^-----------^-
                |       |   |           |
                |     ( * , * )         |
                |       |               |
                        parameter: balance
                |       body: (define (withdraw ... ))
                |                       |
                |                -------Frame 0-      (parameter, body)
                |               | balance  : 50 |      |
                |           E0->| withdraw : *--|--> ( * , * )  
                |               | deposit  : *--|--> ( * , * ) 
                |               | dispatch : *--|--> ( * , * )     
                |                -------^----^--           |
                |    ___________________|    |_____________| 
                |   |
              ( * , * )
                |
                parameter : m           
                body      : (cond ((eq? m ... )))               

((acc 'deposit) 40)

Frame 1 is created when (acc 'deposit is evaluated).
Next, Frame 2 is created when (deposit amount). Since deposit is defined
in E0, Frame 2 pointer is to environment E0.

global   _________________________________
env  -->| make-account :*                 |
        | acc : *                         |
         -------|-----------------------^-
                |                       |
                |                -------Frame 0-
                |               | balance  : 50 |
              ( *, *-)--------->| withdraw : *  |
                                | deposit  : *  |<- E0
                                | dispatch : *  |
                                 -^-----^------- (make-account balance)
                         _________|     |
                        |        -------Frame 1-
                        |       | m : 'deposit  |<- E1 
                        |        --------------- (dispatch m)
                 -------Frame 2-
                | amount : 40   |<- E2
                 --------------- (deposit amount)

After ((acc 'deposit) 40) evaluation balance is set to 90 in Frame 0 and
Frames 1 and 2 are not relevant anymore.

global   _________________________________
env  -->| make-account :*                 |
        | acc : *                         |
         -------|-----------------------^-
                |                       |
                |                -------Frame 0-
                |               | balance  : 90 |
              ( *, *-)--------->| withdraw : *  |
                                | deposit  : *  |<- E0
                                | dispatch : *  |
                                 --------------- 

((acc 'withdraw) 60)

global   _________________________________
env  -->| make-account :*                 |
        | acc : *                         |
         -------|-----------------------^-
                |                       |
                |                -------Frame 0-
                |               | balance  : 90 |
              ( *, *-)--------->| withdraw : *  |
                                | deposit  : *  |<- E0
                                | dispatch : *  |
                                 -^-----^------- (make-account balance)
                         _________|     |
                        |        -------Frame 3-
                        |       | m : 'withdraw |<- E3
                        |        --------------- (dispatch m)
                 -------Frame 4-
                | amount : 60   |<- E4
                 --------------- (withdraw amount)

After ((acc 'withdraw) 60)

global   _________________________________
env  -->| make-account :*                 |
        | acc : *                         |
         -------|-----------------------^-
                |                       |
                |                -------Frame 0-
                |               | balance  : 30 |
              ( *, *-)--------->| withdraw : *  |
                                | deposit  : *  |<- E0
                                | dispatch : *  |
                                 ---------------
#+end_example

*** 3.3 Modeling with Mutable Data
**** 3.3.1 Mutable List Structure
***** Exercise 3.12
:PROPERTIES:
:CUSTOM_ID: exercise-3.12
:END:

The following procedure for appending lists was introduced in section [[#section-2.2.1][2.2.1]]:

#+BEGIN_SRC scheme
(define (append x y)
  (if (null? x)
      y
      (cons (car x) (append (cdr x) y))))
#+END_SRC

~append~ forms a new list by successively 'cons'ing the elements of ~x~ onto ~y~.  The procedure ~append!~ is similar to ~append~, but it is a mutator rather than a constructor.  It appends the lists by splicing them together, modifying the final pair of ~x~ so that its ~cdr~ is now ~y~.  (It is an error to call ~append!~ with an empty ~x~.)

#+BEGIN_SRC scheme
(define (append! x y)
  (set-cdr! (last-pair x) y)
  x)
#+END_SRC

Here ~last-pair~ is a procedure that returns the last pair in its argument:

#+BEGIN_SRC scheme
(define (last-pair x)
  (if (null? (cdr x))
      x
      (last-pair (cdr x))))
#+END_SRC

Consider the interaction

#+BEGIN_SRC scheme
(define x (list 'a 'b))

(define y (list 'c 'd))

(define z (append x y))

z
(a b c d)

(cdr x)
<RESPONSE>

(define w (append! x y))

w
(a b c d)

(cdr x)
<RESPONSE>
#+END_SRC

What are the missing <RESPONSE>s?  Draw box-and-pointer diagrams to explain your answer.

***** Exercise 3.13
:PROPERTIES:
:CUSTOM_ID: exercise-3.13
:END:

Consider the following ~make-cycle~ procedure, which uses the ~last-pair~ procedure defined in [[#exercise-3.12][Exercise 3.12]]:

#+BEGIN_SRC scheme
(define (make-cycle x)
  (set-cdr! (last-pair x) x)
  x)
#+END_SRC

Draw a box-and-pointer diagram that shows the structure ~z~ created by

#+BEGIN_SRC scheme
(define z (make-cycle (list 'a 'b 'c)))
#+END_SRC

What happens if we try to compute ~(last-pair z)~?

***** Exercise 3.14
:PROPERTIES:
:CUSTOM_ID: exercise-3.14
:END:

The following procedure is quite useful, although obscure:

#+BEGIN_SRC scheme
(define (mystery x)
  (define (loop x y)
    (if (null? x)
        y
        (let ((temp (cdr x)))
          (set-cdr! x y)
          (loop temp x))))
  (loop x '()))
#+END_SRC

~loop~ uses the "temporary" variable ~temp~ to hold the old value of the ~cdr~ of ~x~, since the ~set-cdr!~ on the next line destroys the ~cdr~.  Explain what ~mystery~ does in general.  Suppose ~v~ is defined by ~(define v (list 'a 'b 'c 'd))~.  Draw the box-and-pointer diagram that represents the list to which ~v~ is bound.  Suppose that we now evaluate ~(define w (mystery v))~.  Draw box-and-pointer diagrams that show the structures ~v~ and ~w~ after evaluating this expression.  What would be printed as the values of ~v~ and ~w~?

*Sharing and identity*

We mentioned in section [[#section-3.1.3][3.1.3]] the theoretical issues of "sameness" and "change" raised by the introduction of assignment.  These issues arise in practice when individual pairs are <<i353>> shared among different data objects.  For example, consider the structure formed by

#+BEGIN_SRC scheme
(define x (list 'a 'b))
(define z1 (cons x x))
#+END_SRC

As shown in [[figure-3.16][Figure 3.16]], ~z1~ is a pair whose ~car~ and ~cdr~ both point to the same pair ~x~.  This sharing of ~x~ by the ~car~ and ~cdr~ of ~z1~ is a consequence of the straightforward way in which ~cons~ is implemented.  In general, using ~cons~ to construct lists will result in an interlinked structure of pairs in which many individual pairs are shared by many different structures.

<<figure-3.16>> The list ~z1~ formed by ~(cons x x)~.

#+BEGIN_EXAMPLE
       +---+---+
 z1 -->| * | * |
       +-|-+-|-+
         V   V
       +---+---+     +---+---+
  x -->| * | *-+---->| * | / |
       +-|-+---+     +-|-+---+
         V             V
       +---+         +---+
       | a |         | b |
       +---+         +---+
#+END_EXAMPLE

<<figure-3.17>> The list ~z2~ formed by ~(cons (list 'a 'b) (list 'a 'b))~.

#+BEGIN_EXAMPLE
       +---+---+     +---+---+     +---+---+
 z2 -->| * | *-+---->| * | *-+---->| * | / |
       +-|-+---+     +-|-+---+     +-|-+---+
         |             V             V
         |           +---+         +---+
         |           | a |         | b |
         |           +---+         +---+
         |             ^             ^
         |             |             |
         |           +-|-+---+     +-|-+---+
         +---------->| * | *-+---->| * | / |
                     +---+---+     +---+---+
#+END_EXAMPLE

In contrast to [[figure-3.16][Figure 3.16]], [[figure-3.17][Figure 3.17]] shows the structure created by

#+BEGIN_SRC scheme
(define z2 (cons (list 'a 'b) (list 'a 'b)))
#+END_SRC

In this structure, the pairs in the two ~(a b)~ lists are distinct, although the actual symbols are shared.[fn:147]

When thought of as a list, ~z1~ and ~z2~ both represent "the same" list, ~((a b) a b)~.  In general, sharing is completely undetectable if we operate on lists using only ~cons~, ~car~, and ~cdr~.  However, if we allow mutators on list structure, sharing becomes significant.  As an example of the difference that sharing can make, consider the following procedure, which modifies the ~car~ of the structure to which it is applied:

#+BEGIN_SRC scheme
(define (set-to-wow! x)
  (set-car! (car x) 'wow)
  x)
#+END_SRC

Even though ~z1~ and ~z2~ are "the same" structure, applying ~set-to-wow!~ to them yields different results.  With ~z1~, altering the ~car~ also changes the ~cdr~, because in ~z1~ the ~car~ and the ~cdr~ are the same pair.  With ~z2~, the ~car~ and ~cdr~ are distinct, so ~set-to-wow!~ modifies only the ~car~:

#+BEGIN_SRC scheme
z1
((a b) a b)

(set-to-wow! z1)
((wow b) wow b)

z2
((a b) a b)

(set-to-wow! z2)
((wow b) a b)
#+END_SRC

One way to detect sharing in list structures is to use the predicate ~eq?~, which we introduced in section [[#section-2.3.1][2.3.1]] as a way to test whether two symbols are equal.  More generally, ~(eq?  x y)~ tests whether ~x~ and ~y~ are the same object (that is, whether ~x~ and ~y~ are equal as pointers).  Thus, with ~z1~ and ~z2~ as defined in figures [[figure-3.16][Figure 3.16]] and [[figure-3.17][Figure 3.17]], ~(eq?  (car z1) (cdr z1))~ is true and ~(eq?  (car z2) (cdr z2))~ is false.

As will be seen in the following sections, we can exploit sharing to greatly extend the repertoire of data structures that can be represented by pairs.  On the other hand, sharing can also be dangerous, since modifications made to structures will also affect other structures that happen to share the modified parts.  The mutation operations ~set-car!~ and ~set-cdr!~ should be used with care; unless we have a good understanding of how our data objects are shared, mutation can have unanticipated results.[fn:148]

***** Exercise 3.15
:PROPERTIES:
:CUSTOM_ID: exercise-3.15
:END:

Draw box-and-pointer diagrams to explain the effect of ~set-to-wow!~ on the structures ~z1~ and ~z2~ above.

***** Exercise 3.16
:PROPERTIES:
:CUSTOM_ID: exercise-3.16
:END:

Ben Bitdiddle decides to write a procedure to count the number of pairs in any list structure.  "It's easy," he reasons.  "The number of pairs in any structure is the number in the ~car~ plus the number in the ~cdr~ plus one more to count the current pair."  So Ben writes the following procedure:

#+BEGIN_SRC scheme
(define (count-pairs x)
  (if (not (pair? x))
      0
      (+ (count-pairs (car x))
         (count-pairs (cdr x))
         1)))
#+END_SRC

Show that this procedure is not correct.  In particular, draw box-and-pointer diagrams representing list structures made up of exactly three pairs for which Ben's procedure would return 3; return 4; return 7; never return at all.

***** Exercise 3.17
:PROPERTIES:
:CUSTOM_ID: exercise-3.17
:END:

Devise a correct version of the ~count-pairs~ procedure of [[#exercise-3.16][Exercise 3.16]] that returns the number of distinct pairs in any structure.  (Hint: Traverse the structure, maintaining an auxiliary data structure that is used to keep track of which pairs have already been counted.)

***** Exercise 3.18
:PROPERTIES:
:CUSTOM_ID: exercise-3.18
:END:

Write a procedure that examines a list and determines whether it contains a cycle, that is, whether a program that tried to find the end of the list by taking successive ~cdr~s would go into an infinite loop.  [[#exercise-3.13][Exercise 3.13]] constructed such lists.

***** Exercise 3.19
:PROPERTIES:
:CUSTOM_ID: exercise-3.19
:END:

Redo [[#exercise-3.18][Exercise 3.18]] using an algorithm that takes only a constant amount of space.  (This requires a very clever idea.)

*Mutation is just assignment*

When we introduced compound data, we observed in section [[#section-2.1.3][2.1.3]] that pairs can be represented purely in terms of procedures:

#+BEGIN_SRC scheme
(define (cons x y)
  (define (dispatch m)
    (cond ((eq? m 'car) x)
          ((eq? m 'cdr) y)
          (else (error "Undefined operation - CONS" m))))
  dispatch)

(define (car z) (z 'car))

(define (cdr z) (z 'cdr))
#+END_SRC

The same observation is true for mutable data.  We can implement mutable data objects as procedures using assignment and local state.  For instance, we can extend the above pair implementation to handle ~set-car!~ and ~set-cdr!~ in a manner analogous to the way we implemented bank accounts using ~make-account~ in section [[#section-3.1.1][3.1.1]]:

#+BEGIN_SRC scheme
(define (cons x y)
  (define (set-x! v) (set! x v))
  (define (set-y! v) (set! y v))
  (define (dispatch m)
    (cond ((eq? m 'car) x)
          ((eq? m 'cdr) y)
          ((eq? m 'set-car!) set-x!)
          ((eq? m 'set-cdr!) set-y!)
          (else (error "Undefined operation - CONS" m))))
  dispatch)

(define (car z) (z 'car))

(define (cdr z) (z 'cdr))

(define (set-car! z new-value)
  ((z 'set-car!) new-value)
  z)

(define (set-cdr! z new-value)
  ((z 'set-cdr!) new-value)
  z)
#+END_SRC

Assignment is all that is needed, theoretically, to account for the behavior of mutable data.  As soon as we admit ~set!~ to our language, we raise all the issues, not only of assignment, but of mutable data in general.[fn:149]

***** Exercise 3.20
:PROPERTIES:
:CUSTOM_ID: exercise-3.20
:END:

Draw environment diagrams to illustrate the evaluation of the sequence of expressions

#+BEGIN_SRC scheme
(define x (cons 1 2))
(define z (cons x x))
(set-car! (cdr z) 17)

(car x)
17
#+END_SRC

using the procedural implementation of pairs given above.  (Compare [[#exercise-3.11][Exercise 3.11]].)

**** 3.3.2 Representing Queues
***** Exercise 3.21
:PROPERTIES:
:CUSTOM_ID: exercise-3.21
:END:

Ben Bitdiddle decides to test the queue implementation described above.  He types in the procedures to the Lisp interpreter and proceeds to try them out:

#+BEGIN_SRC scheme
(define q1 (make-queue))

(insert-queue! q1 'a)
((a) a)

(insert-queue! q1 'b)
((a b) b)

(delete-queue! q1)
((b) b)

(delete-queue! q1)
(() b)
#+END_SRC

"It's all wrong!"  he complains.  "The interpreter's response shows that the last item is inserted into the queue twice.  And when I delete both items, the second ~b~ is still there, so the queue isn't empty, even though it's supposed to be."  Eva Lu Ator suggests that Ben has misunderstood what is happening.  "It's not that the items are going into the queue twice," she explains.  "It's just that the standard Lisp printer doesn't know how to make sense of the queue representation.  If you want to see the queue printed correctly, you'll have to define your own print procedure for queues."  Explain what Eva Lu is talking about.  In particular, show why Ben's examples produce the printed results that they do.  Define a procedure ~print-queue~ that takes a queue as input and prints the sequence of items in the queue.

***** Exercise 3.22
:PROPERTIES:
:CUSTOM_ID: exercise-3.22
:END:

Instead of representing a queue as a pair of pointers, we can build a queue as a procedure with local state.  The local state will consist of pointers to the beginning and the end of an ordinary list.  Thus, the ~make-queue~ procedure will have the form

#+BEGIN_SRC scheme
(define (make-queue)
  (let ((front-ptr ... )
        (rear-ptr ... ))
    <DEFINITIONS OF INTERNAL PROCEDURES>
    (define (dispatch m) ...)
    dispatch))
#+END_SRC

Complete the definition of ~make-queue~ and provide implementations of the queue operations using this representation.

***** Exercise 3.23
:PROPERTIES:
:CUSTOM_ID: exercise-3.23
:END:

A <<i111>> deque ("double-ended queue") is a sequence in which items can be inserted and deleted at either the front or the rear.  Operations on deques are the constructor ~make-deque~, the predicate ~empty-deque?~, selectors ~front-deque~ and ~rear-deque~, and mutators ~front-insert-deque!~, ~rear-insert-deque!~, ~front-delete-deque!~, and ~rear-delete-deque!~.  Show how to represent deques using pairs, and give implementations of the operations.[fn:151] All operations should be accomplished in \theta(1) steps.

**** 3.3.3 Representing Tables
***** Exercise 3.24
:PROPERTIES:
:CUSTOM_ID: exercise-3.24
:END:

In the table implementations above, the keys are tested for equality using ~equal?~ (called by ~assoc~).  This is not always the appropriate test.  For instance, we might have a table with numeric keys in which we don't need an exact match to the number we're looking up, but only a number within some tolerance of it.  Design a table constructor ~make-table~ that takes as an argument a ~same-key?~ procedure that will be used to test "equality" of keys.  ~make-table~ should return a ~dispatch~ procedure that can be used to access appropriate ~lookup~ and ~insert!~ procedures for a local table.

***** Exercise 3.25
:PROPERTIES:
:CUSTOM_ID: exercise-3.25
:END:

Generalizing one- and two-dimensional tables, show how to implement a table in which values are stored under an arbitrary number of keys and different values may be stored under different numbers of keys.  The ~lookup~ and ~insert!~ procedures should take as input a list of keys used to access the table.

***** Exercise 3.26
:PROPERTIES:
:CUSTOM_ID: exercise-3.26
:END:

To search a table as implemented above, one needs to scan through the list of records.  This is basically the unordered list representation of section [[#section-2.3.3][2.3.3]].  For large tables, it may be more efficient to structure the table in a different manner.  Describe a table implementation where the (key, value) records are organized using a binary tree, assuming that keys can be ordered in some way (e.g., numerically or alphabetically).  (Compare [[#exercise-2.66][Exercise 2.66]] of [[#section-2][Chapter 2]].)

***** Exercise 3.27
:PROPERTIES:
:CUSTOM_ID: exercise-3.27
:END:

<<i229>> Memoization (also called <<i387>> tabulation) is a technique that enables a procedure to record, in a local table, values that have previously been computed.  This technique can make a vast difference in the performance of a program.  A memoized procedure maintains a table in which values of previous calls are stored using as keys the arguments that produced the values.  When the memoized procedure is asked to compute a value, it first checks the table to see if the value is already there and, if so, just returns that value.  Otherwise, it computes the new value in the ordinary way and stores this in the table.  As an example of memoization, recall from section [[#section-1.2.2][1.2.2]] the exponential process for computing Fibonacci numbers:

#+BEGIN_SRC scheme
(define (fib n)
  (cond ((= n 0) 0)
        ((= n 1) 1)
        (else (+ (fib (- n 1))
                 (fib (- n 2))))))
#+END_SRC

The memoized version of the same procedure is

#+BEGIN_SRC scheme
(define memo-fib
  (memoize (lambda (n)
             (cond ((= n 0) 0)
                   ((= n 1) 1)
                   (else (+ (memo-fib (- n 1))
                            (memo-fib (- n 2))))))))
#+END_SRC

where the memoizer is defined as

#+BEGIN_SRC scheme
(define (memoize f)
  (let ((table (make-table)))
    (lambda (x)
      (let ((previously-computed-result (lookup x table)))
        (or previously-computed-result
            (let ((result (f x)))
              (insert! x result table)
              result))))))
#+END_SRC

Draw an environment diagram to analyze the computation of ~(memo-fib 3)~.  Explain why ~memo-fib~ computes the nth Fibonacci number in a number of steps proportional to n.  Would the scheme still work if we had simply defined ~memo-fib~ to be ~(memoize fib)~?

**** 3.3.4 A Simulator for Digital Circuits
***** Exercise 3.28
:PROPERTIES:
:CUSTOM_ID: exercise-3.28
:END:

Define an or-gate as a primitive function box.  Your ~or-gate~ constructor should be similar to ~and-gate~.

***** Exercise 3.29
:PROPERTIES:
:CUSTOM_ID: exercise-3.29
:END:

Another way to construct an or-gate is as a compound digital logic device, built from and-gates and inverters.  Define a procedure ~or-gate~ that accomplishes this.  What is the delay time of the or-gate in terms of ~and-gate-delay~ and ~inverter-delay~?

***** Exercise 3.30
:PROPERTIES:
:CUSTOM_ID: exercise-3.30
:END:

[[figure-3.27][Figure 3.27]] shows a <<i336>> ripple-carry adder formed by stringing together n full-adders.  This is the simplest form of parallel adder for adding two n-bit binary numbers.  The inputs A_1, A_2, A_3, ..., A_n and B_1, B_2, B_3, ..., B_n are the two binary numbers to be added (each A_k and B_k is a 0 or a 1).  The circuit generates S_1, S_2, S_3, ..., S_n, the n bits of the sum, and C, the carry from the addition.  Write a procedure ~ripple-carry-adder~ that generates this circuit.  The procedure should take as arguments three lists of n wires each--the A_k, the B_k, and the S_k--and also another wire C. The major drawback of the ripple-carry adder is the need to wait for the carry signals to propagate.  What is the delay needed to obtain the complete output from an n-bit ripple-carry adder, expressed in terms of the delays for and-gates, or-gates, and inverters?

***** Exercise 3.31
:PROPERTIES:
:CUSTOM_ID: exercise-3.31
:END:

The internal procedure ~accept-action-procedure!~ defined in ~make-wire~ specifies that when a new action procedure is added to a wire, the procedure is immediately run.  Explain why this initialization is necessary.  In particular, trace through the half-adder example in the paragraphs above and say how the system's response would differ if we had defined ~accept-action-procedure!~ as

#+BEGIN_SRC scheme
(define (accept-action-procedure! proc)
  (set! action-procedures (cons proc action-procedures)))
#+END_SRC

***** Exercise 3.32
:PROPERTIES:
:CUSTOM_ID: exercise-3.32
:END:

The procedures to be run during each time segment of the agenda are kept in a queue.  Thus, the procedures for each segment are called in the order in which they were added to the agenda (first in, first out).  Explain why this order must be used.  In particular, trace the behavior of an and-gate whose inputs change from 0,1 to 1,0 in the same segment and say how the behavior would differ if we stored a segment's procedures in an ordinary list, adding and removing procedures only at the front (last in, first out).

**** 3.3.5 Propagation of Constraints
***** Exercise 3.33
:PROPERTIES:
:CUSTOM_ID: exercise-3.33
:END:

Using primitive multiplier, adder, and constant constraints, define a procedure ~averager~ that takes three connectors ~a~, ~b~, and ~c~ as inputs and establishes the constraint that the value of ~c~ is the average of the values of ~a~ and ~b~.

***** Exercise 3.34
:PROPERTIES:
:CUSTOM_ID: exercise-3.34
:END:

Louis Reasoner wants to build a squarer, a constraint device with two terminals such that the value of connector ~b~ on the second terminal will always be the square of the value ~a~ on the first terminal.  He proposes the following simple device made from a multiplier:

#+BEGIN_SRC scheme
(define (squarer a b)
  (multiplier a a b))
#+END_SRC

There is a serious flaw in this idea.  Explain.

***** Exercise 3.35
:PROPERTIES:
:CUSTOM_ID: exercise-3.35
:END:

Ben Bitdiddle tells Louis that one way to avoid the trouble in [[#exercise-3.34][Exercise 3.34]] is to define a squarer as a new primitive constraint.  Fill in the missing portions in Ben's outline for a procedure to implement such a constraint:

#+BEGIN_SRC scheme
(define (squarer a b)
  (define (process-new-value)
    (if (has-value? b)
        (if (< (get-value b) 0)
            (error "square less than 0 - SQUARER" (get-value b))
            <ALTERNATIVE1>)
        <ALTERNATIVE2>))
  (define (process-forget-value) <BODY1>)
  (define (me request) <BODY2>)
  <REST OF DEFINITION>
  me)
#+END_SRC

***** Exercise 3.36
:PROPERTIES:
:CUSTOM_ID: exercise-3.36
:END:

Suppose we evaluate the following sequence of expressions in the global environment:

#+BEGIN_SRC scheme
(define a (make-connector))
(define b (make-connector))
(set-value! a 10 'user)
#+END_SRC

At some time during evaluation of the ~set-value!~, the following expression from the connector's local procedure is evaluated:

#+BEGIN_SRC scheme
(for-each-except setter inform-about-value constraints)
#+END_SRC

Draw an environment diagram showing the environment in which the above expression is evaluated.

***** Exercise 3.37
:PROPERTIES:
:CUSTOM_ID: exercise-3.37
:END:

The ~celsius-fahrenheit-converter~ procedure is cumbersome when compared with a more expression-oriented style of definition, such as

#+BEGIN_SRC scheme
(define (celsius-fahrenheit-converter x)
  (c+ (c* (c/ (cv 9) (cv 5))
          x)
      (cv 32)))

(define C (make-connector))
(define F (celsius-fahrenheit-converter C))
#+END_SRC

Here ~c+~, ~c*~, etc.  are the "constraint" versions of the arithmetic operations.  For example, ~c+~ takes two connectors as arguments and returns a connector that is related to these by an adder constraint:

#+BEGIN_SRC scheme
(define (c+ x y)
  (let ((z (make-connector)))
    (adder x y z)
    z))
#+END_SRC

Define analogous procedures ~c-~, ~c*~, ~c/~, and ~cv~ (constant value) that enable us to define compound constraints as in the converter example above.[fn:161]

*** 3.4 Concurrency: Time Is of the Essence
**** 3.4.1 The Nature of Time in Concurrent Systems
**** 3.4.2 Mechanisms for Controlling Concurrency
*** 3.5 Streams
**** 3.5.1 Streams Are Delayed Lists
**** 3.5.2 Infinite Streams
**** 3.5.3 Exploiting the Stream Paradigm
**** 3.5.4 Streams and Delayed Evaluation
**** 3.5.5 Modularity of Functional Programs and Modularity of Objects
** 4 Metalinguistic Abstraction
*** 4.1 The Metacircular Evaluator
**** 4.1.1 The Core of the Evaluator
**** 4.1.2 Representing Expressions
**** 4.1.3 Evaluator Data Structures
**** 4.1.4 Running the Evaluator as a Program
**** 4.1.5 Data as Programs
**** 4.1.6 Internal Definitions
**** 4.1.7 Separating Syntactic Analysis from Execution
*** 4.2 Variations on a Scheme — Lazy Evaluation
**** 4.2.1 Normal Order and Applicative Order
**** 4.2.2 An Interpreter with Lazy Evaluation
**** 4.2.3 Streams as Lazy Lists
*** 4.3 Variations on a Scheme — Nondeterministic Computing
**** 4.3.1 Amb and Search
**** 4.3.2 Examples of Nondeterministic Programs
**** 4.3.3 Implementing the Amb Evaluator
*** 4.4 Logic Programming
**** 4.4.1 Deductive Information Retrieval
**** 4.4.2 How the Query System Works
**** 4.4.3 Is Logic Programming Mathematical Logic?
**** 4.4.4 Implementing the Query System
**** 4.4.4.1 The Driver Loop and Instantiation
**** 4.4.4.2 The Evaluator
**** 4.4.4.3 Finding Assertions by Pattern Matching
**** 4.4.4.4 Rules and Unification
**** 4.4.4.5 Maintaining the Data Base
**** 4.4.4.6 Stream Operations
**** 4.4.4.7 Query Syntax Procedures
**** 4.4.4.8 Frames and Bindings
** 5 Computing with Register Machines
*** 5.1 Designing Register Machines
**** 5.1.1 A Language for Describing Register Machines
**** 5.1.2 Abstraction in Machine Design
**** 5.1.3 Subroutines
**** 5.1.4 Using a Stack to Implement Recursion
**** 5.1.5 Instruction Summary
*** 5.2 A Register-Machine Simulator
**** 5.2.1 The Machine Model
**** 5.2.2 The Assembler
**** 5.2.3 Generating Execution Procedures for Instructions
**** 5.2.4 Monitoring Machine Performance
*** 5.3 Storage Allocation and Garbage Collection
**** 5.3.1 Memory as Vectors
**** 5.3.2 Maintaining the Illusion of Infinite Memory
*** 5.4 The Explicit-Control Evaluator
**** 5.4.1 The Core of the Explicit-Control Evaluator
**** 5.4.2 Sequence Evaluation and Tail Recursion
**** 5.4.3 Conditionals, Assignments, and Definitions
**** 5.4.4 Running the Evaluator
*** 5.5 Compilation
**** 5.5.1 Structure of the Compiler
**** 5.5.2 Compiling Expressions
**** 5.5.3 Compiling Combinations
**** 5.5.4 Combining Instruction Sequences
**** 5.5.5 An Example of Compiled Code
**** 5.5.6 Lexical Addressing
**** 5.5.7 Interfacing Compiled Code to the Evaluator
